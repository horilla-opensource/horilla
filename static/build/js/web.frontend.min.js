/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (/* binding */ module_default)
  /* harmony export */ });
  // packages/alpinejs/src/scheduler.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
    queue.length = 0;
    flushing = false;
  }
  
  // packages/alpinejs/src/reactivity.js
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, {scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    }});
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i) => i());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  
  // packages/alpinejs/src/mutation.js
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i) => i());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, {subtree: true, childList: true, attributes: true, attributeOldValue: true});
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var recordQueue = [];
  var willProcessRecordQueue = false;
  function flushObserver() {
    recordQueue = recordQueue.concat(observer.takeRecords());
    if (recordQueue.length && !willProcessRecordQueue) {
      willProcessRecordQueue = true;
      queueMicrotask(() => {
        processRecordQueue();
        willProcessRecordQueue = false;
      });
    }
  }
  function processRecordQueue() {
    onMutate(recordQueue);
    recordQueue.length = 0;
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = [];
    let addedAttributes = new Map();
    let removedAttributes = new Map();
    for (let i = 0; i < mutations.length; i++) {
      if (mutations[i].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i].type === "childList") {
        mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
        mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
      }
      if (mutations[i].type === "attributes") {
        let el = mutations[i].target;
        let name = mutations[i].attributeName;
        let oldValue = mutations[i].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({name, value: el.getAttribute(name)});
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i) => i(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.includes(node))
        continue;
      onElRemoveds.forEach((i) => i(node));
      if (node._x_cleanups) {
        while (node._x_cleanups.length)
          node._x_cleanups.pop()();
      }
    }
    addedNodes.forEach((node) => {
      node._x_ignoreSelf = true;
      node._x_ignore = true;
    });
    for (let node of addedNodes) {
      if (removedNodes.includes(node))
        continue;
      if (!node.isConnected)
        continue;
      delete node._x_ignoreSelf;
      delete node._x_ignore;
      onElAddeds.forEach((i) => i(node));
      node._x_ignore = true;
      node._x_ignoreSelf = true;
    }
    addedNodes.forEach((node) => {
      delete node._x_ignoreSelf;
      delete node._x_ignore;
    });
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  
  // packages/alpinejs/src/scope.js
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
    };
  }
  function refreshScope(element, scope2) {
    let existingScope = element._x_dataStack[0];
    Object.entries(scope2).forEach(([key, value]) => {
      existingScope[key] = value;
    });
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    let thisProxy = new Proxy({}, {
      ownKeys: () => {
        return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
      },
      has: (target, name) => {
        return objects.some((obj) => obj.hasOwnProperty(name));
      },
      get: (target, name) => {
        return (objects.find((obj) => {
          if (obj.hasOwnProperty(name)) {
            let descriptor = Object.getOwnPropertyDescriptor(obj, name);
            if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
              return true;
            }
            if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
              let getter = descriptor.get;
              let setter = descriptor.set;
              let property = descriptor;
              getter = getter && getter.bind(thisProxy);
              setter = setter && setter.bind(thisProxy);
              if (getter)
                getter._x_alreadyBound = true;
              if (setter)
                setter._x_alreadyBound = true;
              Object.defineProperty(obj, name, {
                ...property,
                get: getter,
                set: setter
              });
            }
            return true;
          }
          return false;
        }) || {})[name];
      },
      set: (target, name, value) => {
        let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
        if (closestObjectWithKey) {
          closestObjectWithKey[name] = value;
        } else {
          objects[objects.length - 1][name] = value;
        }
        return true;
      }
    });
    return thisProxy;
  }
  
  // packages/alpinejs/src/interceptor.js
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, {value, enumerable}]) => {
        if (enumerable === false || value === void 0)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  
  // packages/alpinejs/src/magics.js
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          let [utilities, cleanup2] = getElementBoundUtilities(el);
          utilities = {interceptor, ...utilities};
          onElRemoved(el, cleanup2);
          return callback(el, utilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  
  // packages/alpinejs/src/utils/error.js
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e) {
      handleError(e, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    Object.assign(error2, {el, expression});
    console.warn(`Alpine Expression Error: ${error2.message}
  
  ${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  
  // packages/alpinejs/src/evaluator.js
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    callback();
    shouldAutoEvaluateFunctions = cache;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, {scope: scope2 = {}, params = []} = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)\s/.test(expression) ? `(() => { ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, {scope: scope2 = {}, params = []} = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else {
      receiver(value);
    }
  }
  
  // packages/alpinejs/src/directives.js
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({name, value}));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i) => i());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler3 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler3.inline && handler3.inline(el, directive2, utilities);
      handler3 = handler3.bind(handler3, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({name, value}) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return {name, value};
  };
  var into = (i) => i;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({name, value}) => {
      let {name: newName, value: newValue} = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, {name, value});
      if (newName !== name)
        callback(newName, name);
      return {name: newName, value: newValue};
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({name}) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({name, value}) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i) => i.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "radio",
    "tabs",
    "switch",
    "disclosure",
    "menu",
    "listbox",
    "list",
    "item",
    "combobox",
    "bind",
    "init",
    "for",
    "mask",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a, b) {
    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  
  // packages/alpinejs/src/utils/dispatch.js
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(new CustomEvent(name, {
      detail,
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  
  // packages/alpinejs/src/nextTick.js
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  
  // packages/alpinejs/src/utils/walk.js
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback, false);
      node = node.nextElementSibling;
    }
  }
  
  // packages/alpinejs/src/utils/warn.js
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  
  // packages/alpinejs/src/lifecycle.js
  function start() {
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  function initTree(el, walker = walk) {
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        directives(el2, el2.attributes).forEach((handle) => handle());
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root) {
    walk(root, (el) => cleanupAttributes(el));
  }
  
  // packages/alpinejs/src/utils/classes.js
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i) => {
      if (el.classList.contains(i)) {
        el.classList.remove(i);
        removed.push(i);
      }
    });
    forAdd.forEach((i) => {
      if (!el.classList.contains(i)) {
        el.classList.add(i);
        added.push(i);
      }
    });
    return () => {
      removed.forEach((i) => el.classList.add(i));
      added.forEach((i) => el.classList.remove(i));
    };
  }
  
  // packages/alpinejs/src/utils/styles.js
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  
  // packages/alpinejs/src/utils/once.js
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  
  // packages/alpinejs/src/directives/x-transition.js
  directive("transition", (el, {value, modifiers, expression}, {evaluate: evaluate2}) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (!expression) {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      enter: (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      leave: (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0);
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: {during: defaultValue, start: defaultValue, end: defaultValue},
        leave: {during: defaultValue, start: defaultValue, end: defaultValue},
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning.beforeCancel(() => reject({isFromCancelledTransition: true}));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i]) => i());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e) => {
            if (!e.isFromCancelledTransition)
              throw e;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, {during, start: start2, end} = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  
  // packages/alpinejs/src/clone.js
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  
  // packages/alpinejs/src/utils/bind.js
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (el.type === "radio") {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    } else if (el.type === "checkbox") {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function isBooleanAttr(attrName) {
    const booleanAttributes = [
      "disabled",
      "checked",
      "required",
      "readonly",
      "hidden",
      "open",
      "selected",
      "autofocus",
      "itemscope",
      "multiple",
      "novalidate",
      "allowfullscreen",
      "allowpaymentrequest",
      "formnovalidate",
      "autoplay",
      "controls",
      "loop",
      "muted",
      "playsinline",
      "default",
      "ismap",
      "reversed",
      "async",
      "defer",
      "nomodule"
    ];
    return booleanAttributes.includes(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  
  // packages/alpinejs/src/utils/debounce.js
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  // packages/alpinejs/src/utils/throttle.js
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  
  // packages/alpinejs/src/plugin.js
  function plugin(callback) {
    callback(alpine_default);
  }
  
  // packages/alpinejs/src/store.js
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
    initInterceptors(stores[name]);
  }
  function getStores() {
    return stores;
  }
  
  // packages/alpinejs/src/binds.js
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({name, value}));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
  }
  
  // packages/alpinejs/src/datas.js
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  
  // packages/alpinejs/src/alpine.js
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.10.5",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    setReactivityEngine,
    closestDataStack,
    skipDuringClone,
    addRootSelector,
    addInitSelector,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    setEvaluator,
    mergeProxies,
    findClosest,
    closestRoot,
    interceptor,
    transition,
    setStyles,
    mutateDom,
    directive,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    bound: getBinding,
    $data: scope,
    data,
    bind: bind2
  };
  var alpine_default = Alpine;
  
  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var EMPTY_OBJ =  true ? Object.freeze({}) : 0;
  var EMPTY_ARR =  true ? Object.freeze([]) : 0;
  var extend = Object.assign;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  
  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  var targetMap = new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol( true ? "iterate" : 0);
  var MAP_KEY_ITERATE_KEY = Symbol( true ? "Map key iterate" : 0);
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const {deps} = effect3;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = method.apply(arr, args);
      if (res === -1 || res === false) {
        return method.apply(arr, args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      pauseTracking();
      const res = method.apply(this, args);
      resetTracking();
      return res;
    };
  });
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const {has: has2} = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const {has: has2, get: get3} = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const {has: has2, get: get3} = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget =  true ? isMap(target) ? new Map(target) : new Set(target) : 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const {value, done} = innerIterator.next();
          return done ? {value, done} : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  var mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = new WeakMap();
  var shallowReactiveMap = new WeakMap();
  var readonlyMap = new WeakMap();
  var shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed["__v_raw"]) || observed;
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  
  // packages/alpinejs/src/magics/$nextTick.js
  magic("nextTick", () => nextTick);
  
  // packages/alpinejs/src/magics/$dispatch.js
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  
  // packages/alpinejs/src/magics/$watch.js
  magic("watch", (el, {evaluateLater: evaluateLater2, effect: effect3}) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let firstTime = true;
    let oldValue;
    let effectReference = effect3(() => evaluate2((value) => {
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    }));
    el._x_effects.delete(effectReference);
  });
  
  // packages/alpinejs/src/magics/$store.js
  magic("store", getStores);
  
  // packages/alpinejs/src/magics/$data.js
  magic("data", (el) => scope(el));
  
  // packages/alpinejs/src/magics/$root.js
  magic("root", (el) => closestRoot(el));
  
  // packages/alpinejs/src/magics/$refs.js
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    let currentEl = el;
    while (currentEl) {
      if (currentEl._x_refs)
        refObjects.push(currentEl._x_refs);
      currentEl = currentEl.parentNode;
    }
    return refObjects;
  }
  
  // packages/alpinejs/src/ids.js
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  
  // packages/alpinejs/src/magics/$id.js
  magic("id", (el) => (name, key = null) => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
  
  // packages/alpinejs/src/magics/$el.js
  magic("el", (el) => el);
  
  // packages/alpinejs/src/magics/index.js
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  
  // packages/alpinejs/src/directives/x-modelable.js
  directive("modelable", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i) => result = i);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, {scope: {__placeholder: val}});
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      effect3(() => innerSet(outerGet()));
      effect3(() => outerSet(innerGet()));
    });
  });
  
  // packages/alpinejs/src/directives/x-teleport.js
  directive("teleport", (el, {expression}, {cleanup: cleanup2}) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = document.querySelector(expression);
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e) => {
          e.stopPropagation();
          el.dispatchEvent(new e.constructor(e.type, e));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      target.appendChild(clone2);
      initTree(clone2);
      clone2._x_ignore = true;
    });
    cleanup2(() => clone2.remove());
  });
  
  // packages/alpinejs/src/directives/x-ignore.js
  var handler = () => {
  };
  handler.inline = (el, {modifiers}, {cleanup: cleanup2}) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  
  // packages/alpinejs/src/directives/x-effect.js
  directive("effect", (el, {expression}, {effect: effect3}) => effect3(evaluateLater(el, expression)));
  
  // packages/alpinejs/src/utils/on.js
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler3 = (e) => callback(e);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("prevent"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.preventDefault();
        next(e);
      });
    if (modifiers.includes("stop"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.stopPropagation();
        next(e);
      });
    if (modifiers.includes("self"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.target === el && next(e);
      });
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler3 = wrapHandler(handler3, (next, e) => {
        if (el.contains(e.target))
          return;
        if (e.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e);
      });
    }
    if (modifiers.includes("once")) {
      handler3 = wrapHandler(handler3, (next, e) => {
        next(e);
        listenerTarget.removeEventListener(event, handler3, options);
      });
    }
    handler3 = wrapHandler(handler3, (next, e) => {
      if (isKeyEvent(event)) {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
          return;
        }
      }
      next(e);
    });
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = debounce(handler3, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = throttle(handler3, wait);
    }
    listenerTarget.addEventListener(event, handler3, options);
    return () => {
      listenerTarget.removeEventListener(event, handler3, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter((i) => {
      return !["window", "document", "prevent", "stop", "once"].includes(i);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyToModifiers(e.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      ctrl: "control",
      slash: "/",
      space: "-",
      spacebar: "-",
      cmd: "meta",
      esc: "escape",
      up: "arrow-up",
      down: "arrow-down",
      left: "arrow-left",
      right: "arrow-right",
      period: ".",
      equal: "="
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  
  // packages/alpinejs/src/directives/x-model.js
  directive("model", (el, {modifiers, expression}, {effect: effect3, cleanup: cleanup2}) => {
    let evaluate2 = evaluateLater(el, expression);
    let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    let evaluateAssignment = evaluateLater(el, assignmentExpression);
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);
    let removeListener = on(el, event, modifiers, (e) => {
      evaluateAssignment(() => {
      }, {scope: {
        $event: e,
        rightSideOfExpression: assigmentFunction
      }});
    });
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);
    el._x_model = {
      get() {
        let result;
        evaluate2((value) => result = value);
        return result;
      },
      set(value) {
        evaluateSetModel(() => {
        }, {scope: {__placeholder: value}});
      }
    };
    el._x_forceModelUpdate = () => {
      evaluate2((value) => {
        if (value === void 0 && expression.match(/\./))
          value = "";
        window.fromModel = true;
        mutateDom(() => bind(el, "value", value));
        delete window.fromModel;
      });
    };
    effect3(() => {
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate();
    });
  });
  function generateAssignmentFunction(el, modifiers, expression) {
    if (el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    return (event, currentValue) => {
      return mutateDom(() => {
        if (event instanceof CustomEvent && event.detail !== void 0) {
          return event.detail || event.target.value;
        } else if (el.type === "checkbox") {
          if (Array.isArray(currentValue)) {
            let newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;
            return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
          } else {
            return event.target.checked;
          }
        } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
          return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          }) : Array.from(event.target.selectedOptions).map((option) => {
            return option.value || option.text;
          });
        } else {
          let rawValue = event.target.value;
          return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
        }
      });
    };
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  
  // packages/alpinejs/src/directives/x-cloak.js
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  
  // packages/alpinejs/src/directives/x-init.js
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, {expression}, {evaluate: evaluate2}) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  
  // packages/alpinejs/src/directives/x-text.js
  directive("text", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  
  // packages/alpinejs/src/directives/x-html.js
  directive("html", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  
  // packages/alpinejs/src/directives/x-bind.js
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  directive("bind", (el, {value, modifiers, expression, original}, {effect: effect3}) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, {scope: bindingProviders});
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
  });
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  
  // packages/alpinejs/src/directives/x-data.js
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", skipDuringClone((el, {expression}, {cleanup: cleanup2}) => {
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, {scope: dataProviderContext});
    if (data2 === void 0)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  }));
  
  // packages/alpinejs/src/directives/x-show.js
  directive("show", (el, {modifiers, expression}, {effect: effect3}) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once((value) => value ? show() : hide(), (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    });
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  
  // packages/alpinejs/src/directives/x-for.js
  directive("for", (el, {expression}, {effect: effect3, cleanup: cleanup2}) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(el, el._x_keyExpression || "index");
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => el2.remove());
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i) => typeof i === "object" && !Array.isArray(i);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i) => i + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => keys.push(value2), {scope: {index: key, ...scope2}});
          scopes.push(scope2);
        });
      } else {
        for (let i = 0; i < items.length; i++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
          evaluateKey((value) => keys.push(value), {scope: {index: i, ...scope2}});
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i = 0; i < prevKeys.length; i++) {
        let key = prevKeys[i];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i, 0, key);
          adds.push([lastKey, i]);
        } else if (prevIndex !== i) {
          let keyInSpot = prevKeys.splice(i, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i = 0; i < removes.length; i++) {
        let key = removes[i];
        if (!!lookup[key]._x_effects) {
          lookup[key]._x_effects.forEach(dequeueJob);
        }
        lookup[key].remove();
        lookup[key] = null;
        delete lookup[key];
      }
      for (let i = 0; i < moves.length; i++) {
        let [keyInSpot, keyForSpot] = moves[i];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i = 0; i < adds.length; i++) {
        let [lastKey2, index] = adds[i];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        addScopeToNode(clone2, reactive(scope2), templateEl);
        mutateDom(() => {
          lastEl.after(clone2);
          initTree(clone2);
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i = 0; i < sames.length; i++) {
        refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
      names.forEach((name, i) => {
        scopeVariables[name] = item[i];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  
  // packages/alpinejs/src/directives/x-ref.js
  function handler2() {
  }
  handler2.inline = (el, {expression}, {cleanup: cleanup2}) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler2);
  
  // packages/alpinejs/src/directives/x-if.js
  directive("if", (el, {expression}, {effect: effect3, cleanup: cleanup2}) => {
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        initTree(clone2);
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        walk(clone2, (node) => {
          if (!!node._x_effects) {
            node._x_effects.forEach(dequeueJob);
          }
        });
        clone2.remove();
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  
  // packages/alpinejs/src/directives/x-id.js
  directive("id", (el, {expression}, {evaluate: evaluate2}) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  
  // packages/alpinejs/src/directives/x-on.js
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, {value, modifiers, expression}, {cleanup: cleanup2}) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e) => {
      evaluate2(() => {
      }, {scope: {$event: e}, params: [e]});
    });
    cleanup2(() => removeListener());
  }));
  
  // packages/alpinejs/src/directives/index.js
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName2, slug) {
    directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  
  // packages/alpinejs/src/index.js
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({reactive: reactive2, effect: effect2, release: stop, raw: toRaw});
  var src_default = alpine_default;
  
  // packages/alpinejs/builds/module.js
  var module_default = src_default;
  
  
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Calendar.js":
  /*!**********************************************!*\
    !*** ./src/js/modules/dashboard/Calendar.js ***!
    \**********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var js_datepicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-datepicker */ "./node_modules/js-datepicker/dist/datepicker.min.js");
  /* harmony import */ var js_datepicker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_datepicker__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var js_datepicker_dist_datepicker_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-datepicker/dist/datepicker.min.css */ "./node_modules/js-datepicker/dist/datepicker.min.css");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  var Calendar = /*#__PURE__*/function () {
    function Calendar() {
      _classCallCheck(this, Calendar);
      this.events();
    }
  
    // Events
    _createClass(Calendar, [{
      key: "events",
      value: function events() {
        // Calendar Selector
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.initCalendar.bind(this));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.initCalendarEmbed.bind(this));
      }
  
      // Methods
  
      /**
       * Initialize Calendar
       */
    }, {
      key: "initCalendar",
      value: function initCalendar(e) {
        var calEls = document.querySelectorAll(".oh-calendar-input");
        calEls.forEach(function (calEl) {
          js_datepicker__WEBPACK_IMPORTED_MODULE_1___default()(calEl, {
            customDays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            formatter: function formatter(input, date, instance) {
              var value = date.toLocaleDateString();
              input.value = value;
            }
          });
        });
      }
  
      /**
       * Embedded Calendar
       */
    }, {
      key: "initCalendarEmbed",
      value: function initCalendarEmbed(e) {
        var calStartEls = document.querySelector(".oh-timeoff-date--start");
        var calEndEls = document.querySelector(".oh-timeoff-date--end");
        if (calStartEls && calEndEls) {
          js_datepicker__WEBPACK_IMPORTED_MODULE_1___default()(".oh-timeoff-date--start", {
            id: 1,
            alwaysShow: false,
            customDays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            formatter: function formatter(input, date, instance) {
              var value = date.toLocaleDateString();
              input.value = value;
            }
          });
          js_datepicker__WEBPACK_IMPORTED_MODULE_1___default()(".oh-timeoff-date--end", {
            id: 1,
            alwaysShow: false,
            customDays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            formatter: function formatter(input, date, instance) {
              var value = date.toLocaleDateString();
              input.value = value;
            }
          });
        }
      }
    }]);
    return Calendar;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Calendar);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Chat.js":
  /*!******************************************!*\
    !*** ./src/js/modules/dashboard/Chat.js ***!
    \******************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var Chat = /*#__PURE__*/function () {
    function Chat() {
      _classCallCheck(this, Chat);
      this.sideBarBtn = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-chat--sidebar-toggle-btn");
      this.events();
    }
  
    // Events
    _createClass(Chat, [{
      key: "events",
      value: function events() {
        // Dashboard Event Slider
        this.sideBarBtn.on("click", this.toggleSidebar.bind(this));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-chat__sidebar-close-btn").on("click", this.closeSidebar.bind(this));
      }
      // Methods
  
      /**
       * Toggle Sidebar
       */
    }, {
      key: "toggleSidebar",
      value: function toggleSidebar(e) {
        var sidebarEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-chat__sidebar");
        sidebarEl.toggleClass("oh-chat__sidebar--show");
      }
      /**
       * Close Sidebar
       */
    }, {
      key: "closeSidebar",
      value: function closeSidebar(e) {
        var sidebarEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-chat__sidebar");
        sidebarEl.removeClass("oh-chat__sidebar--show");
      }
    }]);
    return Chat;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Chat);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Dashboard.js":
  /*!***********************************************!*\
    !*** ./src/js/modules/dashboard/Dashboard.js ***!
    \***********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var Dashboard = /*#__PURE__*/function () {
    function Dashboard() {
      _classCallCheck(this, Dashboard);
      this.events();
    }
  
    // Events
    _createClass(Dashboard, [{
      key: "events",
      value: function events() {
        // Dashboard Event Slider
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__events-nav-item").on("click", this.moveSlider.bind(this));
        // Move Dashboard Event Slider Automatically
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.moveSliderAuto.bind(this));
        // Add Random colors to slides
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.applySlideColors.bind(this));
      }
  
      // Methods
  
      /**
       * Events slider: Move slides
       */
    }, {
      key: "moveSlider",
      value: function moveSlider(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-dashboard__events-nav-item");
        var targetSlideNumber = +clickedEl.data("target");
        var sliderReel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashbaord__events-reel");
        if (targetSlideNumber >= 0 && sliderReel.length > 0) {
          sliderReel[0].style.transform = "translateX(-".concat(targetSlideNumber * 100, "%)");
          // Remove existing active class
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__events-nav-item--active").removeClass("oh-dashboard__events-nav-item--active");
          clickedEl.addClass("oh-dashboard__events-nav-item--active");
        }
      }
  
      /**
       * Events slider: Move slider periodically
       */
    }, {
      key: "moveSliderAuto",
      value: function moveSliderAuto() {
        var slideElements = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__events-nav-item");
        if (slideElements.length > 0) {
          var sliderReel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashbaord__events-reel");
  
          // Iterator
          var i = 0;
  
          // Move slider in an interval of 5 seconds
          setInterval(function () {
            // Increment iterator
            i++;
            // Reset iterator
            if (i == slideElements.length) {
              i = 0;
            }
            sliderReel[0].style.transform = "translateX(-".concat(i * 100, "%)");
            var currSlide = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__events-nav-item[data-target=\"".concat(i, "\"]"));
            // Remove existing active class
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__events-nav-item--active").removeClass("oh-dashboard__events-nav-item--active");
            // Add active class to new slide
            currSlide.addClass("oh-dashboard__events-nav-item--active");
          }, 5000);
        }
      }
  
      /**
       * Event Slider: Apply Random Colors
       */
    }, {
      key: "applySlideColors",
      value: function applySlideColors() {
        // Get slider elements
        var sliderEls = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__event");
        if (sliderEls.length > 0) {
          var colors = ["#16a085", "#2980b9", "#e74c3c", "#8e44ad", "#f39c12", "#c0392b", "#6F1E51", "#5758BB"];
          sliderEls.each(function (index, sliderEl) {
            // Generate a color key based on a random number between the number of colors
            var colorKey = Math.floor(Math.random() * colors.length);
            if (sliderEl) {
              sliderEl.style.backgroundColor = colors[colorKey];
            }
          });
        }
      }
    }]);
    return Dashboard;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dashboard);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Generic.js":
  /*!*********************************************!*\
    !*** ./src/js/modules/dashboard/Generic.js ***!
    \*********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/core */ "./node_modules/jquery-ui/ui/core.js");
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/ui/widgets/sortable */ "./node_modules/jquery-ui/ui/widgets/sortable.js");
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! select2 */ "./node_modules/select2/dist/js/select2.js");
  /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(select2__WEBPACK_IMPORTED_MODULE_3__);
  /* harmony import */ var select2_dist_css_select2_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! select2/dist/css/select2.css */ "./node_modules/select2/dist/css/select2.css");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  
  
  var Generic = /*#__PURE__*/function () {
    function Generic() {
      _classCallCheck(this, Generic);
      this.events();
    }
    // Events
    _createClass(Generic, [{
      key: "events",
      value: function events() {
        // Select 2 Trigger
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.loadSelect2.bind(this));
        // Hide dropdown on click outside
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on("click", this.hideOnClickOutside.bind(this));
        // Editable Trigger
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-editable-input-trigger").on("click", this.makeEditable.bind(this));
        // Clone Element
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("[data-action='clone']").on("click", function () {
          var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data("target");
          var cloneTo = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data("clone");
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).clone(true, true).appendTo(cloneTo);
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-permission-table--toggle").on("click", this.collapsePermissionTable.bind(this));
        // Accordion
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-accordion-header").on("click", this.toggleAccordion.bind(this));
        // Toggle Element
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-d-toggle").on("click", this.toggleView.bind(this));
        // Hide target
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-d-hide").on("click", this.hideView.bind(this));
        // Accordion Meta
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-accordion-meta__item").on("click", this.toggleAccordionMeta.bind(this));
        // Stop Propagation
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-stop-prop").on("click", this.ohStopPropagation.bind(this));
        // Sidebar Reveal on hover
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("#sidebar").on("mouseover", this.sidebarReveal.bind(this));
        // Navbar Toggler
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-navbar__toggle-link").on("click", this.sidebarToggle.bind(this));
        // Navbar Toggler
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-onboarding-card__collapse-header").on("click", this.registrationCollapse.bind(this));
        // Toggle Dropdown
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dropdown--trigger").on("click", this.dropDownTrigger.bind(this));
        // Remove Keayboard
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("keyup", this.keyboardRemove.bind(this));
  
        // Dashboard Cards Movable ss
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dashboard__movable-cards").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-card-dashboard--moveable"
        });
      }
  
      // Methods
  
      /**
       *  Make input editable
       */
    }, {
      key: "makeEditable",
      value: function makeEditable(e) {
        var targetEl = e.target.closest(".oh-editable-input-trigger").dataset.target;
      }
  
      /**
       * Clone element
       */
    }, {
      key: "cloneElement",
      value: function cloneElement(e) {
        var targetEl = e.target.dataset.target;
        var cloneSectionEl = e.target.dataset.clone;
        if (targetEl && cloneSectionEl) {
          document.querySelector(cloneSectionEl).insertAdjacentElement("afterbegin", document.querySelector(targetEl).cloneNode(true));
        }
      }
  
      /**
       * Initialize Select 2
       */
    }, {
      key: "loadSelect2",
      value: function loadSelect2() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-select-2").select2();
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh--dynamic-select-2").select2({
          tags: true,
          tokenSeparators: [",", " "]
        }).on("select2:select", function (e) {
          var selectedText = e.params.data.text;
          var tags = selectedText.split(/[, ]+/);
          var ajaxMethod = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr("data-ajax-name");
          console.log(ajaxMethod);
          var optionElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find("option[value=".concat(tags[0], "]"));
          if (ajaxMethod) {
            window[ajaxMethod](optionElement);
          }
        });
  
        // Select 2 with image
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-select-image").select2({
          placeholder: "Search",
          templateResult: this.imageFormatState,
          templateSelection: this.imageFormatState
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-select-no-search").select2({
          minimumResultsForSearch: Infinity
        });
      }
  
      /**
       * Image Format State
       */
    }, {
      key: "imageFormatState",
      value: function imageFormatState(state) {
        if (!state.id) {
          return state.text;
        }
        var $state = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<span><img src="' + jquery__WEBPACK_IMPORTED_MODULE_0___default()(state.element).attr("data-src") + '" class="oh-select-image__img" /> ' + state.text + "</span>");
        return $state;
      }
  
      // Toggle Display View
    }, {
      key: "toggleView",
      value: function toggleView(e) {
        // e.preventDefault();
        var targetEl = e.target.closest(".oh-d-toggle").dataset.target;
        if (targetEl) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).removeClass("d-none");
        }
      }
  
      /**
       * Show / Collapse Permission list row.
       */
    }, {
      key: "collapsePermissionTable",
      value: function collapsePermissionTable(e) {
        e.stopPropagation();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-permission-table--toggle");
        var parentRow = clickedEl.parents(".oh-permission-table__tr");
        // let collapsedPanel = parentRow.find(".oh-collapse-panel");
        var count = parentRow.data("count");
        var labelText = parentRow.data("label");
        // Count number of permissions.
        // let permissionCount = collapsedPanel.length;
        var cellEl = parentRow.find(".oh-collapse-panel").parents(".oh-sticky-table__td");
        // Label
        var labelEl = null;
        if (labelText) {
          if (count > 1) {
            labelEl = "<span class='oh-permission-count'>".concat(count, " ").concat(labelText, "s</span>");
          } else {
            labelEl = "<span class='oh-permission-count'>".concat(count, " ").concat(labelText, "</span>");
          }
        }
        // Collapse / Hide Permission Panels
        parentRow.toggleClass("oh-permission-table--collapsed");
        if (parentRow.hasClass("oh-permission-table--collapsed")) {
          if (labelEl) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(cellEl).append(labelEl);
          }
        } else {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(cellEl).find(".oh-permission-count").remove();
        }
      }
  
      // Hide View
    }, {
      key: "hideView",
      value: function hideView(e) {
        var targetEl = e.target.dataset.target;
        if (targetEl) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).addClass("d-none");
        }
      }
  
      // Hide on click outside
    }, {
      key: "hideOnClickOutside",
      value: function hideOnClickOutside(e) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-dropdown__close-outside-click").length > 0 || jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-tabs__new-tab-config").length > 0) return;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dropdown__close-outside-click").addClass("d-none");
      }
  
      /**
       * Togggle Accordion
       */
    }, {
      key: "toggleAccordion",
      value: function toggleAccordion(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-accordion-header");
        var accordionEl = clickedEl.parent(".oh-accordion");
        accordionEl.toggleClass("oh-accordion--show");
      }
  
      /**
       * Toggle Accordion
       */
    }, {
      key: "keyboardRemove",
      value: function keyboardRemove(e) {
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()("[data-action='keyboard-remove']");
        if (targetEl.length == 0) return;
        var pressedKey = targetEl.data("key");
        if (e.keyCode === pressedKey) {
          var classRemove = targetEl.data("class");
          targetEl.addClass(classRemove);
        }
      }
  
      /**
       * Toggle Accordion Meta
       */
    }, {
      key: "toggleAccordionMeta",
      value: function toggleAccordionMeta(e) {
        e.preventDefault;
        e.stopPropagation;
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-accordion-meta__header");
        var accordionItemBody = clickedEl.parent(".oh-accordion-meta__item").find(".oh-accordion-meta__body");
        if (clickedEl) {
          clickedEl.toggleClass("oh-accordion-meta__header--show");
        }
        if (accordionItemBody) {
          accordionItemBody.toggleClass("d-none");
        }
      }
  
      /**
       * Stop Propagation
       */
    }, {
      key: "ohStopPropagation",
      value: function ohStopPropagation(e) {
        e.stopPropagation();
      }
  
      /**
       * Sidebar reaveal on hover
       */
    }, {
      key: "sidebarReveal",
      value: function sidebarReveal(e) {
        e.preventDefault();
        var sidebarContainer = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-wrapper-main");
        if (sidebarContainer.hasClass("oh-wrapper-main--closed")) {
          sidebarContainer.removeClass("oh-wrapper-main--closed");
        }
      }
      /**
       * Sidebar show/reaveal on click
       */
    }, {
      key: "sidebarToggle",
      value: function sidebarToggle(e) {
        e.preventDefault();
        var sidebarContainer = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-wrapper-main");
        if (sidebarContainer.hasClass("oh-wrapper-main--closed")) {
          sidebarContainer.removeClass("oh-wrapper-main--closed");
        } else {
          sidebarContainer.addClass("oh-wrapper-main--closed");
        }
      }
      /**
       * Registration Collapse
       */
    }, {
      key: "registrationCollapse",
      value: function registrationCollapse(e) {
        var collapseEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-onboarding-card__collapse-header").parent(".oh-onboarding-card__collapse");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(collapseEl).toggleClass("oh-onboarding-card__collapse--show");
      }
  
      /**
       * Toggle Dropdown
       */
    }, {
      key: "dropDownTrigger",
      value: function dropDownTrigger(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-dropdown--trigger");
        var dropdownEl = clickedEl.children(".oh-dropdown__menu");
        if (dropdownEl && (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).hasClass("oh-dropdown--button") || jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parent().hasClass("oh-dropdown--button"))) {
          // Get the height of dropdown
          dropdownEl.toggleClass("oh-dropdown__menu--hidden");
        }
      }
    }]);
    return Generic;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Generic);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/ImageSelect.js":
  /*!*************************************************!*\
    !*** ./src/js/modules/dashboard/ImageSelect.js ***!
    \*************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var SelectDropDown = /*#__PURE__*/function () {
    function SelectDropDown() {
      _classCallCheck(this, SelectDropDown);
      this.events();
    }
  
    // Events
    _createClass(SelectDropDown, [{
      key: "events",
      value: function events() {
        // Picker Event
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('load', this.imageSelectInit.bind(this));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__btn-select').on('click', this.imageSelectSelect.bind(this));
        // Toggle Class
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-action="toggle"]').on('click', this.genericToggleClass.bind(this));
      }
  
      // Methods
  
      /**
       *  Initialize Image Selector
       */
    }, {
      key: "imageSelectInit",
      value: function imageSelectInit() {
        var itemArray = [];
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector option').each(function () {
          var img = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr("data-thumbnail");
          var text = this.innerText;
          var value = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val();
          var item = '<li class="oh-image-selector__item"><img src="' + img + '" alt="" value="' + value + '"/><span>' + text + '</span></li>';
          itemArray.push(item);
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__list').html(itemArray);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__btn-select').html(itemArray[0]);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__btn-select').attr('value', 'en');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__item').on('click', function () {
          var img = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('img').attr("src");
          var value = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('img').attr('value');
          var text = this.innerText;
          var item = '<li><img src="' + img + '" alt="" /><span>' + text + '</span></li>';
          jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__btn-select').html(item);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-image-selector__btn-select').attr('value', value);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-image-selector__list-container").toggle();
        });
      }
  
      /**
        *  Make Image Selector Selection
        */
    }, {
      key: "imageSelectSelect",
      value: function imageSelectSelect() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-image-selector__list-container").toggle();
      }
  
      /**
       *  Toggle Class
      */
    }, {
      key: "genericToggleClass",
      value: function genericToggleClass(e) {
        e.preventDefault();
        var targetSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data('target');
        var classToToggle = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data('class');
        if (targetSelector && classToToggle) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetSelector).toggleClass(classToToggle);
        }
      }
    }]);
    return SelectDropDown;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectDropDown);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/ImageUpload.js":
  /*!*************************************************!*\
    !*** ./src/js/modules/dashboard/ImageUpload.js ***!
    \*************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var ImageUpload = /*#__PURE__*/function () {
    function ImageUpload() {
      _classCallCheck(this, ImageUpload);
      this.events();
    }
  
    // Events
    _createClass(ImageUpload, [{
      key: "events",
      value: function events() {
        // Change image on upload.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-upload-input").on("change", this.uploadImage.bind(this));
        // Remove uploaded image preview.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-remove-image").on("click", this.removeImage.bind(this));
      }
  
      // Methods
  
      /**
       *  Upload Image
       */
    }, {
      key: "uploadImage",
      value: function uploadImage(e) {
        var inputEl = e.target.closest('.oh-upload-input');
        var targetSelector = inputEl.dataset.target;
        this.readUploadPath(inputEl, targetSelector);
      }
      /**
       *  Read Uploaded Image Path
       */
    }, {
      key: "readUploadPath",
      value: function readUploadPath(input, renderTarget) {
        if (input.files && input.files[0]) {
          var reader = new FileReader();
          reader.onload = function (e) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(renderTarget).attr("src", e.target.result);
          };
          reader.readAsDataURL(input.files[0]);
        }
      }
      /**
        *  Remove Uploaded Image Preview
        */
    }, {
      key: "removeImage",
      value: function removeImage(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.oh-remove-image');
        var targetSelector = clickedEl.data('target');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetSelector).attr('src', '/static/images/ui/user.jpg');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-upload-input').val('');
      }
    }]);
    return ImageUpload;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageUpload);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Inputs.js":
  /*!********************************************!*\
    !*** ./src/js/modules/dashboard/Inputs.js ***!
    \********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var Inputs = /*#__PURE__*/function () {
    function Inputs() {
      _classCallCheck(this, Inputs);
      this.events();
    }
  
    // Events
    _createClass(Inputs, [{
      key: "events",
      value: function events() {
        // Picker Event
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-input-picker").on("click", this.togglePicker.bind(this));
        // // Selection Edit
        // $(".oh-btn--section-edit").on("click", this.editSection.bind(this));
        // Selection Edit
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-btn--section-edit").on("click", this.editSectionShow.bind(this));
        // // Selection Edit Cancel
        // $(".oh-section-edit--cancel").on("click", this.cancelSection.bind(this));
        // Selection Edit Cancel
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-section-edit--cancel").on("click", this.cancelSectionHide.bind(this));
        // Password Input Toggle
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-password-input--toggle").on("click", this.passwordShowToggle.bind(this));
        // Input Resize Automatic
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-input--resize").on("keyup", this.resizeInput.bind(this));
      }
  
      // Methods
  
      /**
       *  Toggling Input Picker
       */
    }, {
      key: "togglePicker",
      value: function togglePicker(e) {
        var targetEl = e.target.closest(".oh-input-picker");
        var targetInput = targetEl.querySelector("input");
        if (targetEl && targetInput) {
          targetInput.checked = true;
          var currentSelections = targetEl.parentElement.querySelectorAll(".oh-input-picker--selected");
          currentSelections.forEach(function (currentSelection) {
            currentSelection.classList.remove("oh-input-picker--selected");
          });
          targetEl.classList.add("oh-input-picker--selected");
        }
      }
  
      /**
       * Section Edit
       */
    }, {
      key: "editSection",
      value: function editSection(e) {
        e.preventDefault();
        var closestTargetEl = e.target.closest(".oh-btn--section-edit");
        var targetEl = closestTargetEl.dataset.target;
        var parentEl = closestTargetEl.parentElement;
  
        // Hide Edit Button
        closestTargetEl.classList.add('d-none');
        // Inputs
        var inputEls = parentEl.querySelectorAll("".concat(targetEl, " input"));
        inputEls.forEach(function (element) {
          element.disabled = false;
        });
        // Selects
        var selectEl = parentEl.querySelectorAll("".concat(targetEl, " select"));
        selectEl.forEach(function (element) {
          element.disabled = false;
        });
        var actionDiv = document.createElement("div");
        actionDiv.classList.add('oh-list__actions');
        parentEl.appendChild(actionDiv);
  
        // Create and add save, delete and cancel button to the DOM
        var deleteBtn = document.createElement("a");
        var deleteBtnEl = document.createTextNode("Delete");
        deleteBtn.appendChild(deleteBtnEl);
        deleteBtn.href = "#";
        deleteBtn.classList.add("oh-btn");
        deleteBtn.classList.add("oh-btn--danger-link");
        deleteBtn.classList.add("oh-section-edit--delete");
        deleteBtn.addEventListener("click", this.cancelSection.bind(this));
        actionDiv.appendChild(deleteBtn);
        var cancelBtn = document.createElement("a");
        var cancelLinkEl = document.createTextNode("Cancel");
        cancelBtn.appendChild(cancelLinkEl);
        cancelBtn.href = "#";
        cancelBtn.classList.add("oh-btn");
        cancelBtn.classList.add("oh-btn--light");
        cancelBtn.classList.add("me-2");
        cancelBtn.classList.add("oh-section-edit--cancel");
        cancelBtn.addEventListener("click", this.cancelSection.bind(this));
        actionDiv.appendChild(cancelBtn);
        var saveBtn = document.createElement("a");
        var saveLinkEl = document.createTextNode("Save");
        saveBtn.appendChild(saveLinkEl);
        saveBtn.href = "#";
        saveBtn.classList.add("oh-btn");
        saveBtn.classList.add("oh-btn--secondary");
        saveBtn.classList.add("oh-section-edit--save");
        saveBtn.classList.add("d-inline-flex");
        actionDiv.appendChild(saveBtn);
      }
  
      /**
       * Section Show
       */
    }, {
      key: "editSectionShow",
      value: function editSectionShow(e) {
        e.preventDefault();
        var closestTargetEl = e.target.closest(".oh-btn--section-edit");
        var targetEl = closestTargetEl.dataset.target;
        var parentEl = closestTargetEl.parentElement;
  
        // Hide Edit Button
        closestTargetEl.classList.add('d-none');
        // Inputs
        var inputEls = parentEl.querySelectorAll("".concat(targetEl, " input"));
        inputEls.forEach(function (element) {
          element.disabled = false;
        });
        // Selects
        var selectEl = parentEl.querySelectorAll("".concat(targetEl, " select"));
        selectEl.forEach(function (element) {
          element.disabled = false;
        });
        // Hide/Show Actions Detail
        var parentContainerEl = closestTargetEl.closest('.oh-section-edit');
        var actionsContainerEl = parentContainerEl.querySelector('.oh-list__actions');
        actionsContainerEl.classList.remove('d-none');
      }
  
      //  /**
      //  * Cancel Section Edit
      //  */
      //  cancelSection(e) {
      //   e.preventDefault();
      //   let closestTargetEl = e.target.closest(".oh-section-edit--cancel");
      //   let parentEl = closestTargetEl.closest('.oh-section-edit');
      //   // Show Edit Button
      //   closestTargetEl.classList.remove('d-none');
      //   // Inputs
      //   let inputEls = parentEl.querySelectorAll('input');
      //   inputEls.forEach(function (element) {
      //     element.disabled = true;
      //   });
      //   // Selects
      //   let selectEl = parentEl.querySelectorAll('select');
      //   selectEl.forEach(function (element) {
      //     element.disabled = true;
      //   });
  
      //   // Remove cancel and save button
      //   parentEl.querySelector('.oh-section-edit--cancel').remove();
      //   parentEl.querySelector('.oh-section-edit--save').remove();
      //   parentEl.querySelector('.oh-section-edit--delete').remove();
      //   parentEl.querySelector('.oh-btn--section-edit').classList.remove('d-none');
      // }
  
      /**
      * Section Hide
      */
    }, {
      key: "cancelSectionHide",
      value: function cancelSectionHide(e) {
        e.preventDefault();
        var closestTargetEl = e.target.closest(".oh-section-edit--cancel");
        var parentEl = closestTargetEl.closest('.oh-section-edit');
        parentEl.querySelector('.oh-btn--section-edit ').classList.remove('d-none');
        // Inputs
        var inputEls = parentEl.querySelectorAll("input");
        inputEls.forEach(function (element) {
          element.disabled = true;
        });
        // Selects
        var selectEl = parentEl.querySelectorAll("select");
        selectEl.forEach(function (element) {
          element.disabled = true;
        });
        // Hide/Show Actions Detail
        var actionsContainerEl = parentEl.querySelector('.oh-list__actions');
        actionsContainerEl.classList.add('d-none');
      }
  
      /**
       *  Password Show/Hide Toggle
       */
    }, {
      key: "passwordShowToggle",
      value: function passwordShowToggle(e) {
        e.preventDefault();
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.oh-password-input--toggle');
        var showIcon = targetEl.find('.oh-passowrd-input__show-icon');
        var hideIcon = targetEl.find('.oh-passowrd-input__hide-icon');
        var passwordInput = targetEl.parent().find('.oh-input--password');
        if (passwordInput.attr('type') == 'password') {
          passwordInput.attr('type', 'text');
          showIcon.addClass('d-none');
          hideIcon.removeClass('d-none');
        } else {
          passwordInput.attr('type', 'password');
          showIcon.removeClass('d-none');
          hideIcon.addClass('d-none');
        }
      }
  
      /**
       *  Resize Input
       */
    }, {
      key: "resizeInput",
      value: function resizeInput(e) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).attr('size', jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).val().length);
      }
    }]);
    return Inputs;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Inputs);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Kanban.js":
  /*!********************************************!*\
    !*** ./src/js/modules/dashboard/Kanban.js ***!
    \********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/core */ "./node_modules/jquery-ui/ui/core.js");
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/ui/widgets/sortable */ "./node_modules/jquery-ui/ui/widgets/sortable.js");
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  
  var Kanban = /*#__PURE__*/function () {
    function Kanban() {
      _classCallCheck(this, Kanban);
      this.events();
      // Add New Section Form Handler
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__add-section-form").on("submit", this.addKanbanSection.bind(this));
      // Edit Form Handler
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__edit-modal-form").on("submit", this.editFormHandler.bind(this));
      // Kanban Group Collapse
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban-group__head").on("click", this.kanbanGroupToggle.bind(this));
      this.registerKanbanEvents();
    }
  
    // Events
    _createClass(Kanban, [{
      key: "events",
      value: function events() {
        // Kanban Section Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-kanban__section",
          placeholder: "oh-kanban__section--highlight"
        });
        // Kanban Card-Section Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__section-body").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-kanban__card",
          connectWith: ".oh-kanban__section-body",
          placeholder: "oh-kanban__card--highlight"
        });
        // Trigger Kanban Card Highlight Color
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__select").on("change", this.changeCardHighlight.bind(this));
      }
  
      // Kanban Actions
    }, {
      key: "registerKanbanEvents",
      value: function registerKanbanEvents() {
        // Remove existing event listers to avoid conflict.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__dropdown-toggle, .oh-kanban__section-delete, .oh-kanban__add-card-btn, .oh-kanban__add-card-cancel-btn, input[name='kanban-card-name'], .oh-kanban__card-body-collapse").off("click");
  
        // Add New Card Form Handler
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__add-card-form").on("submit", this.addKanbanCard.bind(this));
  
        // Toggle Kanban Dropdown
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__dropdown-toggle").on("click", this.toggleKanbanDropdown.bind(this));
        // Delete Kanban
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__section-delete").on("click", this.deleteKanbanSection.bind(this));
        // Delete Kanban Card
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__card-delete").on("click", this.deleteKanbanCard.bind(this));
        // Show Kanban Card Prompt
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__add-card-btn").on("click", this.showKanbanCardForm.bind(this));
        // Show Kanban Card Prompt
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban-group__add-card").on("click", this.showKanbanCardGroup.bind(this));
        // Hide Kanban Card Prompt
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__add-card-cancel-btn").on("click", this.hideKanbanCardForm.bind(this));
        // Check for valid input
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("input[name='kanban-card-name']").on("keyup", this.checkValid.bind(this));
  
        // Edit Modal
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("[data-toggle='oh-kanban-toggle']").on("click", this.openEditModal.bind(this));
  
        // Hide Dropdown
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("click", this.hideKanbanDropdown.bind(this));
  
        // Kanban Toggle
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-kanban__card-body-collapse').on("click", this.toggleKanbanCardBody.bind(this));
      }
  
      // Methods
  
      /**
       * Open Edit Kanban Modal
       */
    }, {
      key: "openEditModal",
      value: function openEditModal(e) {
        if (e.target != null) {
          // Get modal target.
          var targetEl = e.target.dataset.target;
          // Get element where the UUID for section / card is stored as the ID.
          var keyStemEl = e.target.dataset.key;
          // Get the UUID
          var key = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(keyStemEl).attr("id");
          // Get label value of the section / card.
          if (key) {
            var labelEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#".concat(key, " [data-type='label']"));
            var labelText = "";
            if (labelEl.length > 1) {
              labelText = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#".concat(key, " [data-type='label']")).first().text();
            } else {
              labelText = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#".concat(key, " [data-type='label']")).text();
            }
            // Assign as the value of modal input
            jquery__WEBPACK_IMPORTED_MODULE_0___default()("".concat(targetEl, " input[name='edit-value']")).val(labelText);
            jquery__WEBPACK_IMPORTED_MODULE_0___default()("".concat(targetEl, " .oh-kanban__edit-modal-form")).data("target", "#".concat(key));
          }
          // Show modal dialog
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).addClass("oh-modal--show");
        }
      }
  
      /**
       * Edit Form Handler
       */
    }, {
      key: "editFormHandler",
      value: function editFormHandler(e) {
        e.preventDefault();
        // Get form data.
        var formData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).serializeArray();
        // Get the target of which element to update.
        var targetSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data("target");
        if (targetSelector) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default().each(formData, function (i, field) {
            if (field.name === "edit-value" && field.value.length > 0) {
              // Get the changed value.
              var changedValue = field.value;
              // Update the target element text.
              jquery__WEBPACK_IMPORTED_MODULE_0___default()("".concat(targetSelector, " [data-type='label']")).first().text(changedValue);
              // Close Form
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-modal").removeClass("oh-modal--show");
            }
          });
        }
      }
  
      /**
       * Add Kanban Section
       */
    }, {
      key: "addKanbanSection",
      value: function addKanbanSection(e) {
        e.preventDefault();
        var formData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).serializeArray();
        jquery__WEBPACK_IMPORTED_MODULE_0___default().each(formData, function (i, field) {
          if (field.name === "kanban-section-name" && field.value.length > 0) {
            var kanbanSection = "\n        <div class=\"oh-kanban__section\" id=".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(), ">\n        <div class=\"oh-kanban__section-head\">\n          <span class=\"oh-kanban__section-title\" data-type='label'\n            >").concat(field.value.trim(), "</span\n          >\n          <div class=\"oh-kanban__head-actions oh-kanban__dropdown\">\n            <button\n              class=\"oh-btn oh-btn--small oh-btn--transparent oh-kanban__btn oh-kanban__dropdown-toggle\"\n            >\n              <ion-icon name=\"ellipsis-vertical-sharp\"></ion-icon>\n            </button>\n            <div class=\"oh-dropdown oh-kanban__dropdown-menu d-none\">\n              <div\n                class=\"oh-dropdown__menu oh-dropdown__menu--right\"\n              >\n                <ul class=\"oh-dropdown__items\">\n                  <li class=\"oh-dropdown__item\">\n                    <a href=\"#\" class=\"oh-dropdown__link\" data-toggle=\"oh-kanban-toggle\"\n                    data-target=\"#editDialog\" data-key=\".oh-kanban__section\">Rename</a>\n                  </li>\n                  <li class=\"oh-dropdown__item\">\n                    <a href=\"#\" class=\"oh-dropdown__link oh-dropdown__link--danger oh-kanban__section-delete\">Delete</a>\n                  </li>\n                </ul>\n              </div>\n            </div>\n            <button\n              class=\"oh-btn oh-btn--small oh-btn--transparent oh-kanban__btn oh-kanban__add-card-btn\" \n            >\n              <ion-icon name=\"add-sharp\"></ion-icon>\n            </button>\n          </div>\n        </div>\n        <div class=\"oh-kanban__section-body\">\n        <div class=\"oh-card oh-kanban__add-card-container d-none mb-2\">\n                    <form class=\"oh-kanban__add-card-form\">\n                      <input type=\"text\" name=\"kanban-card-name\" class=\"oh-input oh-input--small w-100\" placeholder=\"Candidate name\" autofocus  autocomplete=\"off\"/>\n                      <div class=\"d-flex align-items-center justify-content-end\">\n                        <a  href=\"#\" role=\"button\" class=\"oh-btn oh-btn--light-dark-text oh-btn--x-small oh-kanban__add-card-cancel-btn me-2 mt-2\">Cancel</a>\n                        <button type=\"submit\" class=\"oh-btn oh-btn--secondary oh-btn--x-small mt-2\" disabled>Add</button>\n                      </div>\n                    </form>\n                  </div>\n        </div>\n      </div>\n      ");
            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban .oh-kanban__section:nth-last-child(2)").length > 0) {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(kanbanSection).insertAfter(".oh-kanban .oh-kanban__section:nth-last-child(2)");
            } else {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(kanbanSection).insertBefore(".oh-kanban__add-container");
            }
          }
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("input[name='kanban-section-name']").val("");
        this.events();
        this.registerKanbanEvents();
      }
      /**
       * Add Kanban Card
       */
    }, {
      key: "addKanbanCard",
      value: function addKanbanCard(e) {
        e.preventDefault();
        // Get Type of the form
        var type = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data("type");
        var formData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).serializeArray();
        jquery__WEBPACK_IMPORTED_MODULE_0___default().each(formData, function (i, field) {
          if (field.name === "kanban-card-name" && field.value) {
            if (type === "asset") {
              var kanbanCard = "\n          <div class=\"oh-kanban__card oh-kanban__card--status oh-kanban__card--blue\"  id=".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(), ">\n            <div class=\"oh-kanban__card-head\">\n              <div class=\"oh-profile oh-profile--md\">\n                <span class=\"oh-profile__name oh-text--dark\" data-type='label'\n                  >").concat(field.value.trim(), "</span\n                >\n              </div>\n              <div class=\"oh-kanban__card-actions oh-kanban__dropdown\">\n                        <button\n                          class=\"oh-btn oh-btn--small oh-btn--transparent oh-kanban__btn oh-kanban__dropdown-toggle\"\n                        >\n                          <ion-icon name=\"ellipsis-vertical-sharp\"></ion-icon>\n                        </button>\n                        \n                        <div class=\"oh-dropdown oh-kanban__dropdown-menu d-none\">\n                          <div\n                            class=\"oh-dropdown__menu oh-dropdown__menu--right\"\n                          >\n                            <ul class=\"oh-dropdown__items\">\n                              <li class=\"oh-dropdown__item\">\n                                <a href=\"#\" class=\"oh-dropdown__link oh-dropdown__link--danger oh-kanban__card-delete\">Delete</a>\n                              </li>\n                            </ul>\n                          </div>\n                        </div>\n                        \n                      </div>\n            </div>\n            <div class=\"oh-kanban__card-body\">\n              <button class=\"oh-kanban__card-body-collapse\" aria-label=\"Toggle Options\"></button>\n              <div class=\"oh-kanban__card-content\">\n                <label class=\"oh-label oh-label--sm d-block\">Label</label>\n                <select class=\"oh-select oh-select--sm oh-select-no-search\">\n                  <option>Status #1</option>\n                  <option>Status #2</option>\n                  <option>Status #3</option>\n                </select>\n              </div>\n            </div>\n            <div class=\"oh-kanban__card-footer py-0\">\n              <select class=\"oh-kanban__select oh-select oh-select--sm oh-select-2 oh-select-no-search\">\n                <option value='1'>Assigned</option>\n                <option value='2'>Free</option>\n                <option value='3'>On Repair</option>\n                <option value='4'>Unavailable</option>\n              </select>\n            </div>\n          </div>\n          ");
              // Add the card to section body
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-kanban-group__body").append(kanbanCard);
            } else {
              var _kanbanCard = "\n            <div class=\"oh-kanban__card\"  id=".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__["default"])(), ">\n              <div class=\"oh-kanban__card-head\">\n                <div class=\"oh-profile oh-profile--md\">\n                  <div class=\"oh-profile__avatar mr-1\">\n                    <img\n                      src=\"https://ui-avatars.com/api/?name=").concat(field.value.trim(), "&background=random\"\n                      class=\"oh-profile__image\"\n                      alt=\"").concat(field.value.trim(), "\"\n                    />\n                  </div>\n                  <span class=\"oh-profile__name oh-text--dark\" data-type='label'\n                    >").concat(field.value.trim(), "</span\n                  >\n                </div>\n                <div class=\"oh-kanban__card-actions oh-kanban__dropdown\">\n                          <button\n                            class=\"oh-btn oh-btn--small oh-btn--transparent oh-kanban__btn oh-kanban__dropdown-toggle\"\n                          >\n                            <ion-icon name=\"ellipsis-vertical-sharp\"></ion-icon>\n                          </button>\n                          \n                          <div class=\"oh-dropdown oh-kanban__dropdown-menu d-none\">\n                            <div\n                              class=\"oh-dropdown__menu oh-dropdown__menu--right\"\n                            >\n                              <ul class=\"oh-dropdown__items\">\n                                <li class=\"oh-dropdown__item\">\n                                  <a href=\"#\" class=\"oh-dropdown__link oh-dropdown__link--danger oh-kanban__card-delete\">Delete</a>\n                                </li>\n                              </ul>\n                            </div>\n                          </div>\n                          \n                        </div>\n              </div>\n              <div class=\"oh-kanban__card-body\">\n              <button class=\"oh-kanban__card-body-collapse\" aria-label=\"Toggle Options\"></button>\n              <div class=\"oh-kanban__card-content\">\n                <label class=\"oh-label oh-label--sm d-block\">Label</label>\n                <select class=\"oh-select oh-select--sm oh-select-no-search\">\n                  <option>Status #1</option>\n                  <option>Status #2</option>\n                  <option>Status #3</option>\n                </select>\n              </div>\n            </div>\n              <div class=\"oh-kanban__card-footer\">\n                <span class=\"oh-kanban__card-footer-text oh-text--light\"\n                  >Candidate</span\n                >\n              </div>\n            </div>\n            ");
              // Add the card to section body
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-kanban__section-body").append(_kanbanCard);
            }
            // Close the dialog
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-kanban__add-card-container").addClass("d-none");
            // Clear the dialog
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).find('input[name="kanban-card-name"]').val("");
          }
        });
        this.events();
        this.registerKanbanEvents();
      }
  
      /**
       * Kanban Dropdown
       */
    }, {
      key: "toggleKanbanDropdown",
      value: function toggleKanbanDropdown(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban__dropdown-toggle");
        var parentEl = clickedEl.parents(".oh-kanban__dropdown");
        parentEl.find(".oh-kanban__dropdown-menu").toggleClass("d-none");
      }
  
      /**
       * Kanban Hide Dropdown
       */
    }, {
      key: "hideKanbanDropdown",
      value: function hideKanbanDropdown(e) {
        e.stopPropagation();
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target);
        if (targetEl.hasClass(".oh-dropdown__items").length || targetEl.hasClass(".oh-dropdown__item").length || targetEl.hasClass(".oh-dropdown__link").length || targetEl.hasClass(".oh-kanban__dropdown-menu").length || targetEl.closest(".oh-kanban__dropdown-toggle").length > 0) {
          return;
        }
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-kanban__dropdown-menu").addClass("d-none");
      }
  
      /**
       * Kanban Delete Section
       */
    }, {
      key: "deleteKanbanSection",
      value: function deleteKanbanSection(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban__section-delete");
        clickedEl.parents(".oh-kanban__section").remove();
      }
      /**
       * Kanban Delete Card
       */
    }, {
      key: "deleteKanbanCard",
      value: function deleteKanbanCard(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban__card-delete");
        clickedEl.parents(".oh-kanban__card").remove();
      }
  
      /**
       * Kanban Card Body Collapse
       */
    }, {
      key: "toggleKanbanCardBody",
      value: function toggleKanbanCardBody(e) {
        e.preventDefault();
        var cardBodyEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents('.oh-kanban__card-body').find('.oh-kanban__card-content');
        var cardCollapseBtn = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents('.oh-kanban__card-body').find('.oh-kanban__card-body-collapse');
        if (cardBodyEl.length > 0) {
          cardBodyEl.toggleClass('oh-kanban__card-content--hide');
          cardCollapseBtn.toggleClass('oh-kanban__card-collapse--down');
        }
      }
      /**
       * Kanban Card Form
       */
    }, {
      key: "showKanbanCardForm",
      value: function showKanbanCardForm(e) {
        console.log('Hello');
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban__add-card-btn");
        if (clickedEl.length > 0) {
          clickedEl.parents(".oh-kanban__section").find(".oh-kanban__add-card-container").removeClass("d-none");
        }
      }
  
      /**
       * Show Kanban Card Group
       */
    }, {
      key: "showKanbanCardGroup",
      value: function showKanbanCardGroup(e) {
        e.stopPropagation();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban-group__add-card");
        if (clickedEl.length > 0) {
          clickedEl.parents(".oh-kanban-group").find(".oh-kanban__add-card-container").removeClass("d-none");
        }
      }
  
      /**
       * Hide Kanban Card Form
       */
    }, {
      key: "hideKanbanCardForm",
      value: function hideKanbanCardForm(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban__add-card-cancel-btn");
        if (clickedEl.length > 0) {
          clickedEl.parents(".oh-kanban__add-card-container").addClass("d-none");
        }
      }
  
      /**
       * Check for valid input
       */
    }, {
      key: "checkValid",
      value: function checkValid(e) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).val().length > 0) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parent().find("button[type='submit']").attr("disabled", false);
        } else {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parent().find("button[type='submit']").attr("disabled", true);
        }
      }
  
      /**
       * Kanban Collapse Toggle
       */
    }, {
      key: "kanbanGroupToggle",
      value: function kanbanGroupToggle(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-kanban-group");
        clickedEl.toggleClass("oh-kanban-card--collapsed");
      }
  
      /**
       * Change Kanban Card Highlight
       */
    }, {
      key: "changeCardHighlight",
      value: function changeCardHighlight(e) {
        e.preventDefault();
        var highlightClass = "oh-kanban__card--";
        var patentCardEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-kanban__card");
        switch (e.target.value) {
          case "1":
            highlightClass += "blue";
            break;
          case "2":
            highlightClass += "green";
            break;
          case "3":
            highlightClass += "amber";
            break;
          case "4":
            highlightClass += "red";
            break;
        }
        // Remove existing class
        if (patentCardEl) {
          if (patentCardEl.hasClass("oh-kanban__card--blue")) {
            patentCardEl.removeClass("oh-kanban__card--blue");
          } else if (patentCardEl.hasClass("oh-kanban__card--red")) {
            patentCardEl.removeClass("oh-kanban__card--red");
          } else if (patentCardEl.hasClass("oh-kanban__card--amber")) {
            patentCardEl.removeClass("oh-kanban__card--amber");
          } else {
            patentCardEl.removeClass("oh-kanban__card--green");
          }
          // Add new class
          patentCardEl.addClass(highlightClass);
        }
      }
    }]);
    return Kanban;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Kanban);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/LoadLayout.js":
  /*!************************************************!*\
    !*** ./src/js/modules/dashboard/LoadLayout.js ***!
    \************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var LoadLayout = /*#__PURE__*/function () {
    function LoadLayout() {
      _classCallCheck(this, LoadLayout);
      this.events();
    }
  
    // Events
    _createClass(LoadLayout, [{
      key: "events",
      value: function events() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('load', this.loadHeader.bind(this));
      }
  
      // Methods
  
      /**
       *  Loads header from the templates.
       */
    }, {
      key: "loadHeader",
      value: function loadHeader() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("#sidebar").load("./../../templates/sidebar.html");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("#mainNav").load("./../../templates/navbar.html");
      }
    }]);
    return LoadLayout;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoadLayout);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/ModalDialog.js":
  /*!*************************************************!*\
    !*** ./src/js/modules/dashboard/ModalDialog.js ***!
    \*************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var ModalDialog = /*#__PURE__*/function () {
    function ModalDialog() {
      _classCallCheck(this, ModalDialog);
      this.events();
    }
  
    // Events
    _createClass(ModalDialog, [{
      key: "events",
      value: function events() {
        // Generic Modal Events
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("[data-toggle='oh-modal-toggle']").on('click', this.openModal.bind(this));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-modal__close, .oh-modal__cancel').on('click', this.closeModal.bind(this));
        // Activity Sidebar Events
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-activity-sidebar__open').on('click', this.openActivitySidebar.bind(this));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-activity-sidebar__close').on('click', this.closeActivitySidebar.bind(this));
      }
  
      // Methods
  
      /**
       *  Opem modal dialog
       */
    }, {
      key: "openModal",
      value: function openModal(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('[data-toggle = "oh-modal-toggle"]');
        if (clickedEl != null) {
          var targetEl = clickedEl.data('target');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).addClass('oh-modal--show');
        }
      }
  
      /**
       *  Close modal dialog
       */
    }, {
      key: "closeModal",
      value: function closeModal() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-modal--show').removeClass('oh-modal--show');
      }
  
      /**
       *  Open activity sidebar dialog
       */
    }, {
      key: "openActivitySidebar",
      value: function openActivitySidebar(e) {
        var targetEl = e.target.dataset.target;
        if (targetEl) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).addClass('oh-activity-sidebar--show');
        }
      }
  
      /**
       *  Close activity sidebar dialog
       */
    }, {
      key: "closeActivitySidebar",
      value: function closeActivitySidebar(e) {
        var targetEl = e.target.dataset.target;
        if (targetEl) {
          e.target.closest(targetEl).classList.remove('oh-activity-sidebar--show');
        }
      }
    }]);
    return ModalDialog;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModalDialog);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/OrgChart.js":
  /*!**********************************************!*\
    !*** ./src/js/modules/dashboard/OrgChart.js ***!
    \**********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  __webpack_require__(/*! orgchart */ "./node_modules/orgchart/dist/js/jquery.orgchart.min.js");
  var OrgChart = /*#__PURE__*/function () {
    function OrgChart() {
      _classCallCheck(this, OrgChart);
      this.events();
    }
  
    // Events
    _createClass(OrgChart, [{
      key: "events",
      value: function events() {
        // Trigger OrgChart initialization on window load.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.initOrgChart.bind(this));
      }
  
      // Methods
  
      /**
       * Initialize OrgChart
       */
    }, {
      key: "initOrgChart",
      value: function initOrgChart() {
        var chartDisplayEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chart-container");
        if (chartDisplayEl.length > 0) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chart-container").orgchart({
            data: datascource,
            nodeContent: "title"
          });
        }
      }
    }]);
    return OrgChart;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrgChart);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Recruitment.js":
  /*!*************************************************!*\
    !*** ./src/js/modules/dashboard/Recruitment.js ***!
    \*************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var Recruitment = /*#__PURE__*/function () {
    function Recruitment() {
      _classCallCheck(this, Recruitment);
      this.events();
    }
  
    // Events
    _createClass(Recruitment, [{
      key: "events",
      value: function events() {
        // Calendar Selector
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-recruitment-action--create-tab").on("click", this.addNewTab.bind(this));
      }
  
      // Methods
  
      /**
       * Add New Tab
       */
    }, {
      key: "addNewTab",
      value: function addNewTab(e) {
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-recruitment-action--create-tab");
        var emptyParentEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parent('.oh-empty');
        var targetEl = clickedEl.data("target");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).removeClass("d-none");
        emptyParentEl.addClass("d-none");
      }
    }]);
    return Recruitment;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Recruitment);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/ResizeInput.js":
  /*!*************************************************!*\
    !*** ./src/js/modules/dashboard/ResizeInput.js ***!
    \*************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  var SelectDropDown = /*#__PURE__*/function () {
    function SelectDropDown() {
      _classCallCheck(this, SelectDropDown);
      this.events();
    }
  
    // Events
    _createClass(SelectDropDown, [{
      key: "events",
      value: function events() {
        // $(document).on('load', this.defineEditableInputSize.bind(this));;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-editable-input--w-auto").on('input', this.autoResizeInput.bind(this));
        ;
      }
  
      // Methods
  
      /**
       *  Define Editable input size on load.
       */
      // defineEditableInputSize(e) {
  
      //   $(".oh-editable-input--w-auto") = e.target.value.length + "ch";
      // }
      /**
       *  Auto resize input base on the input value.
       */
    }, {
      key: "autoResizeInput",
      value: function autoResizeInput(e) {
        e.target.style.width = e.target.value.length + "ch";
      }
    }]);
    return SelectDropDown;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectDropDown);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Specifics.js":
  /*!***********************************************!*\
    !*** ./src/js/modules/dashboard/Specifics.js ***!
    \***********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! select2 */ "./node_modules/select2/dist/js/select2.js");
  /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(select2__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var select2_dist_css_select2_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! select2/dist/css/select2.css */ "./node_modules/select2/dist/css/select2.css");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  var Specifics = /*#__PURE__*/function () {
    function Specifics() {
      _classCallCheck(this, Specifics);
      this.events();
    }
  
    // Events
    _createClass(Specifics, [{
      key: "events",
      value: function events() {
        // Select 2 Trigger
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("load", this.loadSelect2.bind(this));
      }
  
      // Methods
  
      /**
       * Initialize Select 2
       */
    }, {
      key: "loadSelect2",
      value: function loadSelect2() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-select--qa-change").each(function (item, element) {
          var targetDiv = element.closest(".oh-section-edit");
          var optionDiv = targetDiv.querySelector(".oh-link__expanded");
          var selectedValue = element.options[element.selectedIndex].text;
          if (selectedValue == "Multi-choices") {
            optionDiv.classList.remove("d-none");
          } else {
            optionDiv.classList.add("d-none");
          }
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-select--qa-change").on("select2:select", function (e) {
          var data = e.params.data;
          var targetDiv = e.target.closest(".oh-section-edit");
          var optionDiv = targetDiv.querySelector(".oh-link__expanded");
          if (data.text == "Multi-choices") {
            optionDiv.classList.remove("d-none");
          } else {
            optionDiv.classList.add("d-none");
          }
        });
      }
    }]);
    return Specifics;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Specifics);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Tables.js":
  /*!********************************************!*\
    !*** ./src/js/modules/dashboard/Tables.js ***!
    \********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/core */ "./node_modules/jquery-ui/ui/core.js");
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/ui/widgets/sortable */ "./node_modules/jquery-ui/ui/widgets/sortable.js");
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__);
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  var Tables = /*#__PURE__*/function () {
    function Tables() {
      _classCallCheck(this, Tables);
      this.events();
      // Editable Table Inputs
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__editable-input").on("click", this.makeEditable.bind(this));
      // Editable Table Inputs
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__editable-input").on("keypress", this.disableEditableOnReturn.bind(this));
      // Add Table Row
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__add-row").on("click", this.addRow.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
      // Add Table Column
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__add-column").on("click", this.addColumn.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
      // Delete Table Row
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table-config__close-tr").on("click", this.removeRow.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
      // Delete Table Columns
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table-config__close-th").on("click", this.removeColumn.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
      // Toggle Collapse Table
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__toggle-parent").on("click", this.toggleCollapseTable.bind(this));
      // Sticky Table Dropdown
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-sticky-table__dropdown-button").on("click", this.toggleTableDropdown.bind(this));
      // Disable editable table input on click outside
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("click", this.disableEditable.bind(this));
      // Close Tabledropdown
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("click", this.hideTableDropdown.bind(this));
    }
  
    // Events
    _createClass(Tables, [{
      key: "events",
      value: function events() {
        // Make tables with the 'oh-table--sortable' class sortable.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--sortable tbody").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: "tr"
        });
        // For sticky tables.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--sortable .oh-sticky-table__tbody").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tr"
        });
  
        // Multi-Table Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-multiple-table-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-multiple-table-sort__movable"
        });
  
        // Collapsable Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__collaspable-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: "tbody"
        });
  
        // Collapsable sort. - Sticky
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__sticky-collaspable-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tbody"
        });
  
        // Inter-Table Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--inter-sortable").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tr",
          connectWith: ".oh-sticky-table__tbody"
        });
      }
  
      // Methods
  
      // Editable Input
    }, {
      key: "makeEditable",
      value: function makeEditable(e) {
        e.stopPropagation();
        var targetEl = e.target.closest(".oh-table__editable-input");
        targetEl.readOnly = false;
      }
  
      // Disable Input
    }, {
      key: "disableEditable",
      value: function disableEditable() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__editable-input").prop("readonly", true);
      }
  
      // Disable Input on Pressing Return
    }, {
      key: "disableEditableOnReturn",
      value: function disableEditableOnReturn(e) {
        var code = e.keyCode || e.which;
        if (code == 13) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table__editable-input").prop("readonly", true);
        }
      }
  
      // Add Row
    }, {
      key: "addRow",
      value: function addRow(e) {
        var $tr = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parent().find(".oh-table-config__tr").last();
        var $clone = $tr.clone(true, true);
        $clone.find(":text").val("");
        $clone.find(":text").attr("placeholder", "Edit Here");
        $tr.after($clone);
      }
  
      // Add Column
    }, {
      key: "addColumn",
      value: function addColumn(e) {
        var table = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table--configurable");
        var tableRows = table.find(".oh-table-config__tr");
        tableRows.each(function (index, item) {
          var childElements = item.children;
          var cloneTd = null;
          for (var i = 0; i < childElements.length; i++) {
            if (childElements[i].classList.contains("oh-table-config__th")) {
              if (i == childElements.length - 2) {
                cloneTd = jquery__WEBPACK_IMPORTED_MODULE_0___default()(childElements[i]).clone(true, true);
              }
            } else {
              if (i == childElements.length - 1) {
                cloneTd = jquery__WEBPACK_IMPORTED_MODULE_0___default()(childElements[i]).clone(true, true);
              }
            }
          }
          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(item).find(".oh-table-config__th").length > 0) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(cloneTd).insertBefore(jquery__WEBPACK_IMPORTED_MODULE_0___default()(item).children(".oh-table-config__th").last());
          } else {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(item).append(cloneTd);
          }
        });
      }
  
      // Remove Row
    }, {
      key: "removeRow",
      value: function removeRow(e) {
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table-config__close-tr");
        var rowToDelete = targetEl.parents(".oh-table-config__tr");
        if (rowToDelete) {
          rowToDelete.remove();
        }
      }
  
      // Remove removeColumn
    }, {
      key: "removeColumn",
      value: function removeColumn(e) {
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table-config__close-th");
        var targetColumnIndex = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table-config__th").index();
        var allRows = targetEl.parents(".oh-table--configurable").find(".oh-table-config__tr");
        allRows.each(function (index, item) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(item).children().eq(targetColumnIndex).remove();
        });
      }
  
      // Toggle Collapsable
    }, {
      key: "toggleCollapseTable",
      value: function toggleCollapseTable(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-table__toggle-parent");
        var targetSelector = clickedEl.data("target");
        var toggleBtn = clickedEl.find(".oh-table__toggle-button");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()("[data-group='".concat(targetSelector, "']")).toggleClass("oh-table__toggle-child--show");
        if (toggleBtn) {
          toggleBtn.toggleClass("oh-table__toggle-button--show");
        }
      }
  
      // Stick Table Dropdown
    }, {
      key: "toggleTableDropdown",
      value: function toggleTableDropdown(e) {
        e.preventDefault();
        var clickedEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-sticky-table__dropdown-button");
        var caretIcon = clickedEl.find(".oh-sticky-table__dropdown-caret");
        var dropdownMenuEl = clickedEl.parents(".oh-sticky-table__dropdown").find(".oh-dropdown__menu");
        if (dropdownMenuEl && caretIcon) {
          if (dropdownMenuEl.hasClass("d-none")) {
            dropdownMenuEl.removeClass("d-none");
            caretIcon.css({
              transform: "rotate(180deg)"
            });
          } else {
            dropdownMenuEl.addClass("d-none");
            caretIcon.css({
              transform: "rotate(0deg)"
            });
          }
        }
      }
  
      // Sticky Table Dropdown
    }, {
      key: "hideTableDropdown",
      value: function hideTableDropdown(e) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-sticky-table__dropdown").length == 0) {
          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-sticky-table__dropdown .oh-dropdown__menu:not(".d-none")').length > 0) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-dropdown__menu").addClass("d-none");
          }
        }
      }
    }]);
    return Tables;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tables);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Tabs.js":
  /*!******************************************!*\
    !*** ./src/js/modules/dashboard/Tabs.js ***!
    \******************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/core */ "./node_modules/jquery-ui/ui/core.js");
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/ui/widgets/sortable */ "./node_modules/jquery-ui/ui/widgets/sortable.js");
  /* harmony import */ var jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_sortable__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
  /* harmony import */ var _Tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tables */ "./src/js/modules/dashboard/Tables.js");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
  
  
  
  
  
  var Tabs = /*#__PURE__*/function (_Tables) {
    _inherits(Tabs, _Tables);
    var _super = _createSuper(Tabs);
    function Tabs() {
      var _this;
      _classCallCheck(this, Tabs);
      _this = _super.call(this);
      _this.events();
      // Switch Tab
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab").on("click", _this.switchTab.bind(_assertThisInitialized(_this)));
      // Add New Tab
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__new-tab").on("click", _this.addTab.bind(_assertThisInitialized(_this)));
      // Add New Config Tab
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__advanced-form").on("submit", _this.addConfigTab.bind(_assertThisInitialized(_this)));
      // Add Table Rows
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__add-row-form").on("submit", _this.addTableRow.bind(_assertThisInitialized(_this)));
      // Close Tab
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__close-btn").on("click", _this.closeTab.bind(_assertThisInitialized(_this)));
      // Collapse Movable Dialog
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__movable-header").on("click", _this.collapseMovable.bind(_assertThisInitialized(_this)));
      // Prevent inheriting parent funciton
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__movable-header .oh-btn").on("click", _this.preventCollapseMovable.bind(_assertThisInitialized(_this)));
      // Add New Movable Table
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__action-new-table").on("click", _this.addNewMovaleTable.bind(_assertThisInitialized(_this)));
      // Remove Movable Table
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__movable-close").on("click", _this.removeMovaleTable.bind(_assertThisInitialized(_this)));
      // General Tab
      jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-action="general-tab"]').on("click", _this.switchGeneralTab.bind(_assertThisInitialized(_this)));
  
      // Close dialog on click outside
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on("click", _this.closeOnClickOutside.bind(_assertThisInitialized(_this)));
      return _this;
    }
  
    // Events
    _createClass(Tabs, [{
      key: "events",
      value: function events() {
        // Movable Tabs
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__movable-area, .pipeline-header").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-tabs__movable"
        });
        // Inter-Table Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--inter-sortable").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tr",
          connectWith: ".oh-sticky-table__tbody"
        });
  
        /* ======= EVENTS FROM TABLE.JS {TEMP} ======= */
        // Make tables with the 'oh-table--sortable' class sortable.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--sortable tbody").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: "tr"
        });
        // For sticky tables.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--sortable .oh-sticky-table__tbody").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tr"
        });
  
        // Multi-Table Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-multiple-table-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-multiple-table-sort__movable"
        });
  
        // Collapsable Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__collaspable-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: "tbody"
        });
  
        // Collapsable sort. - Sticky
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table__sticky-collaspable-sort").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tbody"
        });
  
        // Inter-Table Sort.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-table--inter-sortable").sortable({
          cursor: "row-resize",
          opacity: "0.55",
          items: ".oh-sticky-table__tr",
          connectWith: ".oh-sticky-table__tbody",
          placeholder: "oh-sticky-table__tbody--highlight"
        });
      }
  
      // Methods
  
      // Switch Tab
    }, {
      key: "switchTab",
      value: function switchTab(e) {
        var parentContainerEl = e.target.closest(".oh-tabs");
        var tabElement = e.target.closest(".oh-tabs__tab");
        if (tabElement.classList.contains("oh-tabs__new-tab")) return;
        var targetSelector = e.target.dataset.target;
        var targetEl = parentContainerEl ? parentContainerEl.querySelector(targetSelector) : null;
  
        // Highlight active tabs
        if (tabElement && !tabElement.classList.contains("oh-tabs__tab--active")) {
          parentContainerEl.querySelectorAll(".oh-tabs__tab--active").forEach(function (item) {
            item.classList.remove("oh-tabs__tab--active");
          });
          if (!tabElement.classList.contains("oh-tabs__new-tab")) {
            tabElement.classList.add("oh-tabs__tab--active");
          }
        }
  
        // Switch tabs
        if (targetEl && !targetEl.classList.contains("oh-tabs__content--active")) {
          parentContainerEl.querySelectorAll(".oh-tabs__content--active").forEach(function (item) {
            item.classList.remove("oh-tabs__content--active");
          });
          targetEl.classList.add("oh-tabs__content--active");
        }
      }
  
      // Add Tab
    }, {
      key: "addTab",
      value: function addTab(e) {
        var targetEl = e.target.closest(".oh-tabs__new-tab");
        var targetDiv = e.target.closest(".oh-tabs__tablist");
        var tabContentEl = targetDiv.closest(".oh-tabs").querySelector(".oh-tabs__contents");
        var previousTabId = targetEl.previousElementSibling.dataset.target;
        var nextID = +previousTabId.split("_")[1] + 1;
  
        // Add New Tab
        this.createTabElement(nextID, targetEl, targetDiv, tabContentEl, "New Tab");
      }
  
      // Add Tab with Config.
    }, {
      key: "addConfigTab",
      value: function addConfigTab(e) {
        e.preventDefault();
        var formEl = e.target.closest("form");
        var tabTitle = formEl[formEl.dataset.title].value;
        var targetEl = e.target.closest(".oh-tabs__new-tab-config");
        var targetDiv = e.target.closest(".oh-tabs__tablist");
        var tabContentEl = targetDiv.closest(".oh-tabs").querySelector(".oh-tabs__contents");
        var previousTabId = targetEl.previousElementSibling.dataset.target;
        var nextID = +previousTabId.split("_")[1] + 1;
  
        // Add New Tab
        this.createTabElement(nextID, targetEl, targetDiv, tabContentEl, tabTitle);
  
        // Remove close button if there's only one tab left.
        this.showHideCloseButton(targetDiv.closest(".oh-tabs"));
        var submitBtn = formEl.querySelector('button[type="submit"]');
        if (submitBtn.classList.contains("oh-d-hide")) {
          var _targetEl = submitBtn.dataset.target;
          if (_targetEl) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(_targetEl).addClass("d-none");
          }
        }
  
        // Reset form
        formEl.reset();
      }
  
      // Close Tab
    }, {
      key: "closeTab",
      value: function closeTab(e) {
        var clickedTabEl = e.target.closest(".oh-tabs__close-btn").closest(".oh-tabs__tab");
        var tabContainerEl = e.target.closest(".oh-tabs__close-btn").closest(".oh-tabs__tab").closest(".oh-tabs");
        var targetId = clickedTabEl.dataset.target;
  
        // Find if sibilings exists
        var prevTab = clickedTabEl.previousElementSibling ? clickedTabEl.previousElementSibling.dataset.target : null;
        var nextTab = clickedTabEl.nextElementSibling.dataset.target ? clickedTabEl.nextElementSibling.dataset.target : null;
        if (nextTab && !clickedTabEl.nextElementSibling.classList.contains("oh-tabs__new-tab-config")) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab[data-target='".concat(nextTab, "']")).addClass("oh-tabs__tab--active");
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextTab).addClass("oh-tabs__content--active");
        } else if (prevTab) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab[data-target='".concat(prevTab, "']")).addClass("oh-tabs__tab--active");
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(prevTab).addClass("oh-tabs__content--active");
        }
        // Remove tab & content
        if (prevTab || nextTab) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__content".concat(targetId)).remove();
          clickedTabEl.remove();
        }
        // Remove close button if there's only one tab left.
        this.showHideCloseButton(tabContainerEl);
      }
  
      // Construct Tab Elementn
    }, {
      key: "createTabElement",
      value: function createTabElement(nextID, targetEl, targetDiv, tabContentEl, tabTitle) {
        // Create Tab Element
        var newTab = document.createElement("li");
        var newTabText = document.createTextNode(tabTitle);
        newTab.appendChild(newTabText);
        newTab.classList.add("oh-tabs__tab");
        newTab.dataset.target = "#tab_".concat(nextID);
  
        // Add tab switch event listener to the new tab.
        newTab.addEventListener("click", this.switchTab.bind(this));
  
        // Create and add close button to tab.
        var closeBtn = document.createElement("button");
        // Close button classes
        closeBtn.classList.add("oh-btn");
        closeBtn.classList.add("oh-btn--sq-sm");
        closeBtn.classList.add("oh-btn--transparent");
        closeBtn.classList.add("oh-tabs__close-btn");
        // Close button icon
        closeBtn.innerHTML = '<ion-icon name="close-outline"></ion-icon>';
        // Link close tab event.
        closeBtn.addEventListener("click", this.closeTab.bind(this));
        newTab.appendChild(closeBtn);
        targetDiv.insertBefore(newTab, targetEl);
  
        // Create Tab Content
        var newTabContent = document.createElement("div");
        newTabContent.classList.add("oh-tabs__content");
        newTabContent.id = "tab_".concat(nextID);
        newTabContent.addEventListener("click", this.switchTab.bind(this));
        tabContentEl.appendChild(newTabContent);
  
        // Display close button if more than 1 tab exists
        var tabsLeft = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab").length - 1;
        if (tabsLeft > 1) {
          targetDiv.closest(".oh-tabs").querySelector(".oh-tabs__close-btn").classList.remove("d-none");
        }
  
        // Remove focus from currenlty active tabs and content.
        targetDiv.querySelectorAll(".oh-tabs__tab--active").forEach(function (item) {
          item.classList.remove("oh-tabs__tab--active");
        });
        tabContentEl.querySelectorAll(".oh-tabs__content--active").forEach(function (item) {
          item.classList.remove("oh-tabs__content--active");
        });
  
        // Swtich to newly inserted tab.
        targetDiv.querySelector("[data-target='#tab_".concat(nextID, "']")).classList.add("oh-tabs__tab--active");
        tabContentEl.querySelector("#tab_".concat(nextID)).classList.add("oh-tabs__content--active");
      }
  
      // Show / Hide Close Button
    }, {
      key: "showHideCloseButton",
      value: function showHideCloseButton(tabContainerEl) {
        var tabsLeft = 0;
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__new-tab-config").length > 0) {
          tabsLeft = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab").length;
        } else {
          tabsLeft = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-tabs__tab").length - 1;
        }
        if (tabsLeft == 1) {
          tabContainerEl.querySelector(".oh-tabs__close-btn").classList.add("d-none");
        } else {
          // Remove d-none from the first tab
          tabContainerEl.querySelector(".oh-tabs__close-btn").classList.remove("d-none");
        }
      }
  
      // Show / Hide Movable Dialog
    }, {
      key: "collapseMovable",
      value: function collapseMovable(e) {
        e.stopPropagation();
        var clickedEl = e.target.closest(".oh-tabs__movable-header");
        var movableDialogEl = clickedEl.closest(".oh-tabs__movable");
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(movableDialogEl).find(".oh-tabs__movable-body").toggleClass("d-none");
      }
  
      // Prevent inheriting toggle function
    }, {
      key: "preventCollapseMovable",
      value: function preventCollapseMovable(e) {
        e.stopPropagation();
      }
  
      // Add New Movable Table
    }, {
      key: "addNewMovaleTable",
      value: function addNewMovaleTable(e) {
        var _parentEl$find;
        // ID
        var uniqueID = (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])();
        // Selectors
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-tabs__action-new-table");
        var parentEl = targetEl.parents(".oh-tabs__content");
        var movableAreaEl = parentEl.find(".oh-tabs__movable-area");
        var cloneEl = parentEl.find(".oh-tabs__movable").last().clone(); // Do not deep clone for jQuery sortable won't work if you do.
        var dropDownCloneEl = (_parentEl$find = parentEl.find(".oh-dropdown__menu")) === null || _parentEl$find === void 0 ? void 0 : _parentEl$find.last().clone(true, true); // Clone dialog
  
        // Add event to add row button
        cloneEl.find('.oh-d-toggle').attr('data-target', "#".concat(uniqueID));
        cloneEl.find('.oh-d-toggle').on("click", function (e) {
          e.preventDefault();
          var targetEl = e.target.closest(".oh-d-toggle").dataset.target;
          if (targetEl) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(targetEl).removeClass("d-none");
          }
        });
        // Add ID to dropdown
        dropDownCloneEl.attr('id', uniqueID);
        cloneEl.find(":text").val("");
        cloneEl.find(":text").attr("placeholder", "Edit");
        cloneEl.find(".oh-sticky-table__tbody .oh-sticky-table__tr").filter(":not(.oh-sticky-table__tbody .oh-sticky-table__tr:first-child)").remove();
        if (movableAreaEl) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(movableAreaEl).append(cloneEl).append(dropDownCloneEl);
          this.events();
          jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-input--resize').on("keyup", function (e) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).attr('size', jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).val().length);
          });
          /* =========== Register Events =========== */
  
          this.tableTabsEvents(cloneEl);
        }
      }
  
      // Register Table Events
    }, {
      key: "tableTabsEvents",
      value: function tableTabsEvents(parentEl) {
        // Editable Table Inputs
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table__editable-input").on("click", this.makeEditable.bind(this));
        // Editable Table Inputs
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table__editable-input").on("keypress", this.disableEditableOnReturn.bind(this));
        // Add Table Row
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table__add-row").on("click", this.addRow.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
        // Add Table Column
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table__add-column").on("click", this.addColumn.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
        // Delete Table Row
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table-config__close-tr").on("click", this.removeRow.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
        // Delete Table Columns
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-table-config__close-th").on("click", this.removeColumn.bind(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));
        // Remove Movable Table
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-tabs__movable-close").on("click", this.removeMovaleTable.bind(this));
        // Collapse Movable Dialog
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parentEl).find(".oh-tabs__movable-header").on("click", this.collapseMovable.bind(this));
      }
  
      // Remove Movable Table
    }, {
      key: "removeMovaleTable",
      value: function removeMovaleTable(e) {
        e.stopPropagation();
        var targetEl = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(".oh-tabs__movable-close");
        var closeEl = targetEl.parents(".oh-tabs__movable");
        var dropdown = closeEl.next('.oh-dropdown__menu');
        closeEl === null || closeEl === void 0 ? void 0 : closeEl.remove();
        dropdown === null || dropdown === void 0 ? void 0 : dropdown.remove();
      }
  
      // Switch General Tab
    }, {
      key: "switchGeneralTab",
      value: function switchGeneralTab(e) {
        // DO NOT USE GENERAL TABS TWICE ON A SINGLE PAGE.
        e.preventDefault();
        var clickedEl = e.target.closest(".oh-general__tab-link");
        var targetSelector = clickedEl.dataset.target;
  
        // Remove active class from all the tabs
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-general__tab-link").removeClass("oh-general__tab-link--active");
        // Remove active class to the clicked tab
        clickedEl.classList.add("oh-general__tab-link--active");
  
        // Hide all the general tabs
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-general__tab-target").addClass("d-none");
        // Show the tab with the chosen target
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(".oh-general__tab-target".concat(targetSelector)).removeClass("d-none");
      }
  
      // Add New Table Row
    }, {
      key: "addTableRow",
      value: function addTableRow(e) {
        e.preventDefault();
        // Parent containing both table and the dropdown menu
        var parentSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data("parent");
        // Table on to which the new row is to be attached
        var targetSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).data("target");
        // Dropdown menu
        var parentContainer = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parents(".oh-dropdown__menu");
  
        // Get form data
        var formData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).serializeArray();
  
        // Check if both the parent container and table exists
        if (parentSelector && targetSelector) {
          // Row Start
          var tableRow = "<div class=\"oh-sticky-table__tr oh-table-config__tr ui-sortable-handle\" draggable=\"true\">";
          jquery__WEBPACK_IMPORTED_MODULE_0___default().each(formData, function (i, field) {
            // Check if the first cell, if so add profile image and close button.
            if (i == 0) {
              tableRow += "\n            <div class=\"oh-sticky-table__sd oh-table-config__td\">\n                <button class=\"oh-table-config__close-tr\">\n                  <ion-icon name=\"close-outline\" role=\"img\" class=\"md hydrated\" aria-label=\"close outline\"></ion-icon>\n                </button>\n                <div class=\"oh-profile oh-profile--md\">\n                  <div class=\"oh-profile__avatar mr-1\">\n                    <img src=\"https://ui-avatars.com/api/?name=".concat(field.value, "&amp;background=random\" class=\"oh-profile__image\" alt=\"User\">\n                  </div>\n                  <input class=\"oh-table__editable-input\" placeholder=\"Edit\" value=\"").concat(field.value, "\" readonly>\n                </div>\n            </div>");
            } else {
              tableRow += "\n            <div class=\"oh-sticky-table__sd oh-table-config__td\">\n              <input class=\"oh-table__editable-input\" placeholder=\"Edit\" value=\"".concat(field.value, "\" readonly>   \n            </div>");
            }
          });
  
          // Row End
          tableRow += "</div>";
          var attachTarget = parentContainer.prev('.oh-tabs__movable').find("".concat(targetSelector)).last();
  
          // Append new row to the table [[ Check if we're adding on to the right parent ]]
  
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(tableRow).insertAfter(attachTarget);
  
          // Clear all form inputs
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).find("input").val("");
          // Close the dropdown
          parentContainer.addClass("d-none");
  
          // Re-register events
          this.tableTabsEvents(parentSelector);
        }
      }
  
      // Close new table row dialog on click outside
    }, {
      key: "closeOnClickOutside",
      value: function closeOnClickOutside(e) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.oh-table__add-row-dropdown').length > 0 || jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.oh-d-toggle').length > 0) return;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.oh-table__add-row-dropdown').addClass('d-none');
      }
    }]);
    return Tabs;
  }(_Tables__WEBPACK_IMPORTED_MODULE_3__["default"]);
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tabs);
  
  /***/ }),
  
  /***/ "./src/js/modules/dashboard/Tooltip.js":
  /*!*********************************************!*\
    !*** ./src/js/modules/dashboard/Tooltip.js ***!
    \*********************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
  /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/core */ "./node_modules/jquery-ui/ui/core.js");
  /* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var jquery_ui_ui_widgets_tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/ui/widgets/tooltip */ "./node_modules/jquery-ui/ui/widgets/tooltip.js");
  /* harmony import */ var jquery_ui_ui_widgets_tooltip__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_tooltip__WEBPACK_IMPORTED_MODULE_2__);
  /* harmony import */ var jquery_ui_themes_base_core_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jquery-ui/themes/base/core.css */ "./node_modules/jquery-ui/themes/base/core.css");
  /* harmony import */ var jquery_ui_themes_base_theme_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jquery-ui/themes/base/theme.css */ "./node_modules/jquery-ui/themes/base/theme.css");
  /* harmony import */ var jquery_ui_themes_base_tooltip_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery-ui/themes/base/tooltip.css */ "./node_modules/jquery-ui/themes/base/tooltip.css");
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  
  
  
  
  
  
  var Tooltip = /*#__PURE__*/function () {
    function Tooltip() {
      _classCallCheck(this, Tooltip);
      this.events();
    }
  
    // Events
    _createClass(Tooltip, [{
      key: "events",
      value: function events() {
        // Initialize tooltip.
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).tooltip();
      }
  
      // Methods
    }]);
    return Tooltip;
  }();
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/core.css":
  /*!***************************************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/core.css ***!
    \***************************************************************************************************************************************************************************************************************/
  /***/ ((module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
  // Imports
  
  var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
  // Module
  ___CSS_LOADER_EXPORT___.push([module.id, "/*!\n * jQuery UI CSS Framework 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/theming/\n */\n\n/* Layout helpers\n----------------------------------*/\n.ui-helper-hidden {\n\tdisplay: none;\n}\n.ui-helper-hidden-accessible {\n\tborder: 0;\n\tclip: rect(0 0 0 0);\n\theight: 1px;\n\tmargin: -1px;\n\toverflow: hidden;\n\tpadding: 0;\n\tposition: absolute;\n\twidth: 1px;\n}\n.ui-helper-reset {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\toutline: 0;\n\tline-height: 1.3;\n\ttext-decoration: none;\n\tfont-size: 100%;\n\tlist-style: none;\n}\n.ui-helper-clearfix:before,\n.ui-helper-clearfix:after {\n\tcontent: \"\";\n\tdisplay: table;\n\tborder-collapse: collapse;\n}\n.ui-helper-clearfix:after {\n\tclear: both;\n}\n.ui-helper-zfix {\n\twidth: 100%;\n\theight: 100%;\n\ttop: 0;\n\tleft: 0;\n\tposition: absolute;\n\topacity: 0;\n\t-ms-filter: \"alpha(opacity=0)\"; /* support: IE8 */\n}\n\n.ui-front {\n\tz-index: 100;\n}\n\n\n/* Interaction Cues\n----------------------------------*/\n.ui-state-disabled {\n\tcursor: default !important;\n\tpointer-events: none;\n}\n\n\n/* Icons\n----------------------------------*/\n.ui-icon {\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tmargin-top: -.25em;\n\tposition: relative;\n\ttext-indent: -99999px;\n\toverflow: hidden;\n\tbackground-repeat: no-repeat;\n}\n\n.ui-widget-icon-block {\n\tleft: 50%;\n\tmargin-left: -8px;\n\tdisplay: block;\n}\n\n/* Misc visuals\n----------------------------------*/\n\n/* Overlays */\n.ui-widget-overlay {\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n", ""]);
  // Exports
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
  
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/theme.css":
  /*!****************************************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/theme.css ***!
    \****************************************************************************************************************************************************************************************************************/
  /***/ ((module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
  /* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1__);
  /* harmony import */ var _images_ui_icons_444444_256x240_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./images/ui-icons_444444_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png");
  /* harmony import */ var _images_ui_icons_555555_256x240_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./images/ui-icons_555555_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png");
  /* harmony import */ var _images_ui_icons_ffffff_256x240_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./images/ui-icons_ffffff_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png");
  /* harmony import */ var _images_ui_icons_777620_256x240_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./images/ui-icons_777620_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png");
  /* harmony import */ var _images_ui_icons_cc0000_256x240_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./images/ui-icons_cc0000_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png");
  /* harmony import */ var _images_ui_icons_777777_256x240_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./images/ui-icons_777777_256x240.png */ "./node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png");
  // Imports
  
  
  
  
  
  
  
  
  var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
  var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_444444_256x240_png__WEBPACK_IMPORTED_MODULE_2__["default"]);
  var ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_555555_256x240_png__WEBPACK_IMPORTED_MODULE_3__["default"]);
  var ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_ffffff_256x240_png__WEBPACK_IMPORTED_MODULE_4__["default"]);
  var ___CSS_LOADER_URL_REPLACEMENT_3___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_777620_256x240_png__WEBPACK_IMPORTED_MODULE_5__["default"]);
  var ___CSS_LOADER_URL_REPLACEMENT_4___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_cc0000_256x240_png__WEBPACK_IMPORTED_MODULE_6__["default"]);
  var ___CSS_LOADER_URL_REPLACEMENT_5___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_1___default()(_images_ui_icons_777777_256x240_png__WEBPACK_IMPORTED_MODULE_7__["default"]);
  // Module
  ___CSS_LOADER_EXPORT___.push([module.id, "/*!\n * jQuery UI CSS Framework 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/theming/\n *\n * To view and modify this theme, visit http://jqueryui.com/themeroller/\n */\n\n\n/* Component containers\n----------------------------------*/\n.ui-widget {\n\tfont-family: Arial,Helvetica,sans-serif/*{ffDefault}*/;\n\tfont-size: 1em/*{fsDefault}*/;\n}\n.ui-widget .ui-widget {\n\tfont-size: 1em;\n}\n.ui-widget input,\n.ui-widget select,\n.ui-widget textarea,\n.ui-widget button {\n\tfont-family: Arial,Helvetica,sans-serif/*{ffDefault}*/;\n\tfont-size: 1em;\n}\n.ui-widget.ui-widget-content {\n\tborder: 1px solid #c5c5c5/*{borderColorDefault}*/;\n}\n.ui-widget-content {\n\tborder: 1px solid #dddddd/*{borderColorContent}*/;\n\tbackground: #ffffff/*{bgColorContent}*/ /*{bgImgUrlContent}*/ /*{bgContentXPos}*/ /*{bgContentYPos}*/ /*{bgContentRepeat}*/;\n\tcolor: #333333/*{fcContent}*/;\n}\n.ui-widget-content a {\n\tcolor: #333333/*{fcContent}*/;\n}\n.ui-widget-header {\n\tborder: 1px solid #dddddd/*{borderColorHeader}*/;\n\tbackground: #e9e9e9/*{bgColorHeader}*/ /*{bgImgUrlHeader}*/ /*{bgHeaderXPos}*/ /*{bgHeaderYPos}*/ /*{bgHeaderRepeat}*/;\n\tcolor: #333333/*{fcHeader}*/;\n\tfont-weight: bold;\n}\n.ui-widget-header a {\n\tcolor: #333333/*{fcHeader}*/;\n}\n\n/* Interaction states\n----------------------------------*/\n.ui-state-default,\n.ui-widget-content .ui-state-default,\n.ui-widget-header .ui-state-default,\n.ui-button,\n\n/* We use html here because we need a greater specificity to make sure disabled\nworks properly when clicked or hovered */\nhtml .ui-button.ui-state-disabled:hover,\nhtml .ui-button.ui-state-disabled:active {\n\tborder: 1px solid #c5c5c5/*{borderColorDefault}*/;\n\tbackground: #f6f6f6/*{bgColorDefault}*/ /*{bgImgUrlDefault}*/ /*{bgDefaultXPos}*/ /*{bgDefaultYPos}*/ /*{bgDefaultRepeat}*/;\n\tfont-weight: normal/*{fwDefault}*/;\n\tcolor: #454545/*{fcDefault}*/;\n}\n.ui-state-default a,\n.ui-state-default a:link,\n.ui-state-default a:visited,\na.ui-button,\na:link.ui-button,\na:visited.ui-button,\n.ui-button {\n\tcolor: #454545/*{fcDefault}*/;\n\ttext-decoration: none;\n}\n.ui-state-hover,\n.ui-widget-content .ui-state-hover,\n.ui-widget-header .ui-state-hover,\n.ui-state-focus,\n.ui-widget-content .ui-state-focus,\n.ui-widget-header .ui-state-focus,\n.ui-button:hover,\n.ui-button:focus {\n\tborder: 1px solid #cccccc/*{borderColorHover}*/;\n\tbackground: #ededed/*{bgColorHover}*/ /*{bgImgUrlHover}*/ /*{bgHoverXPos}*/ /*{bgHoverYPos}*/ /*{bgHoverRepeat}*/;\n\tfont-weight: normal/*{fwDefault}*/;\n\tcolor: #2b2b2b/*{fcHover}*/;\n}\n.ui-state-hover a,\n.ui-state-hover a:hover,\n.ui-state-hover a:link,\n.ui-state-hover a:visited,\n.ui-state-focus a,\n.ui-state-focus a:hover,\n.ui-state-focus a:link,\n.ui-state-focus a:visited,\na.ui-button:hover,\na.ui-button:focus {\n\tcolor: #2b2b2b/*{fcHover}*/;\n\ttext-decoration: none;\n}\n\n.ui-visual-focus {\n\tbox-shadow: 0 0 3px 1px rgb(94, 158, 214);\n}\n.ui-state-active,\n.ui-widget-content .ui-state-active,\n.ui-widget-header .ui-state-active,\na.ui-button:active,\n.ui-button:active,\n.ui-button.ui-state-active:hover {\n\tborder: 1px solid #003eff/*{borderColorActive}*/;\n\tbackground: #007fff/*{bgColorActive}*/ /*{bgImgUrlActive}*/ /*{bgActiveXPos}*/ /*{bgActiveYPos}*/ /*{bgActiveRepeat}*/;\n\tfont-weight: normal/*{fwDefault}*/;\n\tcolor: #ffffff/*{fcActive}*/;\n}\n.ui-icon-background,\n.ui-state-active .ui-icon-background {\n\tborder: #003eff/*{borderColorActive}*/;\n\tbackground-color: #ffffff/*{fcActive}*/;\n}\n.ui-state-active a,\n.ui-state-active a:link,\n.ui-state-active a:visited {\n\tcolor: #ffffff/*{fcActive}*/;\n\ttext-decoration: none;\n}\n\n/* Interaction Cues\n----------------------------------*/\n.ui-state-highlight,\n.ui-widget-content .ui-state-highlight,\n.ui-widget-header .ui-state-highlight {\n\tborder: 1px solid #dad55e/*{borderColorHighlight}*/;\n\tbackground: #fffa90/*{bgColorHighlight}*/ /*{bgImgUrlHighlight}*/ /*{bgHighlightXPos}*/ /*{bgHighlightYPos}*/ /*{bgHighlightRepeat}*/;\n\tcolor: #777620/*{fcHighlight}*/;\n}\n.ui-state-checked {\n\tborder: 1px solid #dad55e/*{borderColorHighlight}*/;\n\tbackground: #fffa90/*{bgColorHighlight}*/;\n}\n.ui-state-highlight a,\n.ui-widget-content .ui-state-highlight a,\n.ui-widget-header .ui-state-highlight a {\n\tcolor: #777620/*{fcHighlight}*/;\n}\n.ui-state-error,\n.ui-widget-content .ui-state-error,\n.ui-widget-header .ui-state-error {\n\tborder: 1px solid #f1a899/*{borderColorError}*/;\n\tbackground: #fddfdf/*{bgColorError}*/ /*{bgImgUrlError}*/ /*{bgErrorXPos}*/ /*{bgErrorYPos}*/ /*{bgErrorRepeat}*/;\n\tcolor: #5f3f3f/*{fcError}*/;\n}\n.ui-state-error a,\n.ui-widget-content .ui-state-error a,\n.ui-widget-header .ui-state-error a {\n\tcolor: #5f3f3f/*{fcError}*/;\n}\n.ui-state-error-text,\n.ui-widget-content .ui-state-error-text,\n.ui-widget-header .ui-state-error-text {\n\tcolor: #5f3f3f/*{fcError}*/;\n}\n.ui-priority-primary,\n.ui-widget-content .ui-priority-primary,\n.ui-widget-header .ui-priority-primary {\n\tfont-weight: bold;\n}\n.ui-priority-secondary,\n.ui-widget-content .ui-priority-secondary,\n.ui-widget-header .ui-priority-secondary {\n\topacity: .7;\n\t-ms-filter: \"alpha(opacity=70)\"; /* support: IE8 */\n\tfont-weight: normal;\n}\n.ui-state-disabled,\n.ui-widget-content .ui-state-disabled,\n.ui-widget-header .ui-state-disabled {\n\topacity: .35;\n\t-ms-filter: \"alpha(opacity=35)\"; /* support: IE8 */\n\tbackground-image: none;\n}\n.ui-state-disabled .ui-icon {\n\t-ms-filter: \"alpha(opacity=35)\"; /* support: IE8 - See #6059 */\n}\n\n/* Icons\n----------------------------------*/\n\n/* states and images */\n.ui-icon {\n\twidth: 16px;\n\theight: 16px;\n}\n.ui-icon,\n.ui-widget-content .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ")/*{iconsContent}*/;\n}\n.ui-widget-header .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ")/*{iconsHeader}*/;\n}\n.ui-state-hover .ui-icon,\n.ui-state-focus .ui-icon,\n.ui-button:hover .ui-icon,\n.ui-button:focus .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ")/*{iconsHover}*/;\n}\n.ui-state-active .ui-icon,\n.ui-button:active .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ")/*{iconsActive}*/;\n}\n.ui-state-highlight .ui-icon,\n.ui-button .ui-state-highlight.ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ")/*{iconsHighlight}*/;\n}\n.ui-state-error .ui-icon,\n.ui-state-error-text .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ")/*{iconsError}*/;\n}\n.ui-button .ui-icon {\n\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ")/*{iconsDefault}*/;\n}\n\n/* positioning */\n/* Three classes needed to override `.ui-button:hover .ui-icon` */\n.ui-icon-blank.ui-icon-blank.ui-icon-blank {\n\tbackground-image: none;\n}\n.ui-icon-caret-1-n { background-position: 0 0; }\n.ui-icon-caret-1-ne { background-position: -16px 0; }\n.ui-icon-caret-1-e { background-position: -32px 0; }\n.ui-icon-caret-1-se { background-position: -48px 0; }\n.ui-icon-caret-1-s { background-position: -65px 0; }\n.ui-icon-caret-1-sw { background-position: -80px 0; }\n.ui-icon-caret-1-w { background-position: -96px 0; }\n.ui-icon-caret-1-nw { background-position: -112px 0; }\n.ui-icon-caret-2-n-s { background-position: -128px 0; }\n.ui-icon-caret-2-e-w { background-position: -144px 0; }\n.ui-icon-triangle-1-n { background-position: 0 -16px; }\n.ui-icon-triangle-1-ne { background-position: -16px -16px; }\n.ui-icon-triangle-1-e { background-position: -32px -16px; }\n.ui-icon-triangle-1-se { background-position: -48px -16px; }\n.ui-icon-triangle-1-s { background-position: -65px -16px; }\n.ui-icon-triangle-1-sw { background-position: -80px -16px; }\n.ui-icon-triangle-1-w { background-position: -96px -16px; }\n.ui-icon-triangle-1-nw { background-position: -112px -16px; }\n.ui-icon-triangle-2-n-s { background-position: -128px -16px; }\n.ui-icon-triangle-2-e-w { background-position: -144px -16px; }\n.ui-icon-arrow-1-n { background-position: 0 -32px; }\n.ui-icon-arrow-1-ne { background-position: -16px -32px; }\n.ui-icon-arrow-1-e { background-position: -32px -32px; }\n.ui-icon-arrow-1-se { background-position: -48px -32px; }\n.ui-icon-arrow-1-s { background-position: -65px -32px; }\n.ui-icon-arrow-1-sw { background-position: -80px -32px; }\n.ui-icon-arrow-1-w { background-position: -96px -32px; }\n.ui-icon-arrow-1-nw { background-position: -112px -32px; }\n.ui-icon-arrow-2-n-s { background-position: -128px -32px; }\n.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }\n.ui-icon-arrow-2-e-w { background-position: -160px -32px; }\n.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }\n.ui-icon-arrowstop-1-n { background-position: -192px -32px; }\n.ui-icon-arrowstop-1-e { background-position: -208px -32px; }\n.ui-icon-arrowstop-1-s { background-position: -224px -32px; }\n.ui-icon-arrowstop-1-w { background-position: -240px -32px; }\n.ui-icon-arrowthick-1-n { background-position: 1px -48px; }\n.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }\n.ui-icon-arrowthick-1-e { background-position: -32px -48px; }\n.ui-icon-arrowthick-1-se { background-position: -48px -48px; }\n.ui-icon-arrowthick-1-s { background-position: -64px -48px; }\n.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }\n.ui-icon-arrowthick-1-w { background-position: -96px -48px; }\n.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }\n.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }\n.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }\n.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }\n.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }\n.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }\n.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }\n.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }\n.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }\n.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }\n.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }\n.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }\n.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }\n.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }\n.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }\n.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }\n.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }\n.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }\n.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }\n.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }\n.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }\n.ui-icon-arrow-4 { background-position: 0 -80px; }\n.ui-icon-arrow-4-diag { background-position: -16px -80px; }\n.ui-icon-extlink { background-position: -32px -80px; }\n.ui-icon-newwin { background-position: -48px -80px; }\n.ui-icon-refresh { background-position: -64px -80px; }\n.ui-icon-shuffle { background-position: -80px -80px; }\n.ui-icon-transfer-e-w { background-position: -96px -80px; }\n.ui-icon-transferthick-e-w { background-position: -112px -80px; }\n.ui-icon-folder-collapsed { background-position: 0 -96px; }\n.ui-icon-folder-open { background-position: -16px -96px; }\n.ui-icon-document { background-position: -32px -96px; }\n.ui-icon-document-b { background-position: -48px -96px; }\n.ui-icon-note { background-position: -64px -96px; }\n.ui-icon-mail-closed { background-position: -80px -96px; }\n.ui-icon-mail-open { background-position: -96px -96px; }\n.ui-icon-suitcase { background-position: -112px -96px; }\n.ui-icon-comment { background-position: -128px -96px; }\n.ui-icon-person { background-position: -144px -96px; }\n.ui-icon-print { background-position: -160px -96px; }\n.ui-icon-trash { background-position: -176px -96px; }\n.ui-icon-locked { background-position: -192px -96px; }\n.ui-icon-unlocked { background-position: -208px -96px; }\n.ui-icon-bookmark { background-position: -224px -96px; }\n.ui-icon-tag { background-position: -240px -96px; }\n.ui-icon-home { background-position: 0 -112px; }\n.ui-icon-flag { background-position: -16px -112px; }\n.ui-icon-calendar { background-position: -32px -112px; }\n.ui-icon-cart { background-position: -48px -112px; }\n.ui-icon-pencil { background-position: -64px -112px; }\n.ui-icon-clock { background-position: -80px -112px; }\n.ui-icon-disk { background-position: -96px -112px; }\n.ui-icon-calculator { background-position: -112px -112px; }\n.ui-icon-zoomin { background-position: -128px -112px; }\n.ui-icon-zoomout { background-position: -144px -112px; }\n.ui-icon-search { background-position: -160px -112px; }\n.ui-icon-wrench { background-position: -176px -112px; }\n.ui-icon-gear { background-position: -192px -112px; }\n.ui-icon-heart { background-position: -208px -112px; }\n.ui-icon-star { background-position: -224px -112px; }\n.ui-icon-link { background-position: -240px -112px; }\n.ui-icon-cancel { background-position: 0 -128px; }\n.ui-icon-plus { background-position: -16px -128px; }\n.ui-icon-plusthick { background-position: -32px -128px; }\n.ui-icon-minus { background-position: -48px -128px; }\n.ui-icon-minusthick { background-position: -64px -128px; }\n.ui-icon-close { background-position: -80px -128px; }\n.ui-icon-closethick { background-position: -96px -128px; }\n.ui-icon-key { background-position: -112px -128px; }\n.ui-icon-lightbulb { background-position: -128px -128px; }\n.ui-icon-scissors { background-position: -144px -128px; }\n.ui-icon-clipboard { background-position: -160px -128px; }\n.ui-icon-copy { background-position: -176px -128px; }\n.ui-icon-contact { background-position: -192px -128px; }\n.ui-icon-image { background-position: -208px -128px; }\n.ui-icon-video { background-position: -224px -128px; }\n.ui-icon-script { background-position: -240px -128px; }\n.ui-icon-alert { background-position: 0 -144px; }\n.ui-icon-info { background-position: -16px -144px; }\n.ui-icon-notice { background-position: -32px -144px; }\n.ui-icon-help { background-position: -48px -144px; }\n.ui-icon-check { background-position: -64px -144px; }\n.ui-icon-bullet { background-position: -80px -144px; }\n.ui-icon-radio-on { background-position: -96px -144px; }\n.ui-icon-radio-off { background-position: -112px -144px; }\n.ui-icon-pin-w { background-position: -128px -144px; }\n.ui-icon-pin-s { background-position: -144px -144px; }\n.ui-icon-play { background-position: 0 -160px; }\n.ui-icon-pause { background-position: -16px -160px; }\n.ui-icon-seek-next { background-position: -32px -160px; }\n.ui-icon-seek-prev { background-position: -48px -160px; }\n.ui-icon-seek-end { background-position: -64px -160px; }\n.ui-icon-seek-start { background-position: -80px -160px; }\n/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */\n.ui-icon-seek-first { background-position: -80px -160px; }\n.ui-icon-stop { background-position: -96px -160px; }\n.ui-icon-eject { background-position: -112px -160px; }\n.ui-icon-volume-off { background-position: -128px -160px; }\n.ui-icon-volume-on { background-position: -144px -160px; }\n.ui-icon-power { background-position: 0 -176px; }\n.ui-icon-signal-diag { background-position: -16px -176px; }\n.ui-icon-signal { background-position: -32px -176px; }\n.ui-icon-battery-0 { background-position: -48px -176px; }\n.ui-icon-battery-1 { background-position: -64px -176px; }\n.ui-icon-battery-2 { background-position: -80px -176px; }\n.ui-icon-battery-3 { background-position: -96px -176px; }\n.ui-icon-circle-plus { background-position: 0 -192px; }\n.ui-icon-circle-minus { background-position: -16px -192px; }\n.ui-icon-circle-close { background-position: -32px -192px; }\n.ui-icon-circle-triangle-e { background-position: -48px -192px; }\n.ui-icon-circle-triangle-s { background-position: -64px -192px; }\n.ui-icon-circle-triangle-w { background-position: -80px -192px; }\n.ui-icon-circle-triangle-n { background-position: -96px -192px; }\n.ui-icon-circle-arrow-e { background-position: -112px -192px; }\n.ui-icon-circle-arrow-s { background-position: -128px -192px; }\n.ui-icon-circle-arrow-w { background-position: -144px -192px; }\n.ui-icon-circle-arrow-n { background-position: -160px -192px; }\n.ui-icon-circle-zoomin { background-position: -176px -192px; }\n.ui-icon-circle-zoomout { background-position: -192px -192px; }\n.ui-icon-circle-check { background-position: -208px -192px; }\n.ui-icon-circlesmall-plus { background-position: 0 -208px; }\n.ui-icon-circlesmall-minus { background-position: -16px -208px; }\n.ui-icon-circlesmall-close { background-position: -32px -208px; }\n.ui-icon-squaresmall-plus { background-position: -48px -208px; }\n.ui-icon-squaresmall-minus { background-position: -64px -208px; }\n.ui-icon-squaresmall-close { background-position: -80px -208px; }\n.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }\n.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }\n.ui-icon-grip-solid-vertical { background-position: -32px -224px; }\n.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }\n.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }\n.ui-icon-grip-diagonal-se { background-position: -80px -224px; }\n\n\n/* Misc visuals\n----------------------------------*/\n\n/* Corner radius */\n.ui-corner-all,\n.ui-corner-top,\n.ui-corner-left,\n.ui-corner-tl {\n\tborder-top-left-radius: 3px/*{cornerRadius}*/;\n}\n.ui-corner-all,\n.ui-corner-top,\n.ui-corner-right,\n.ui-corner-tr {\n\tborder-top-right-radius: 3px/*{cornerRadius}*/;\n}\n.ui-corner-all,\n.ui-corner-bottom,\n.ui-corner-left,\n.ui-corner-bl {\n\tborder-bottom-left-radius: 3px/*{cornerRadius}*/;\n}\n.ui-corner-all,\n.ui-corner-bottom,\n.ui-corner-right,\n.ui-corner-br {\n\tborder-bottom-right-radius: 3px/*{cornerRadius}*/;\n}\n\n/* Overlays */\n.ui-widget-overlay {\n\tbackground: #aaaaaa/*{bgColorOverlay}*/ /*{bgImgUrlOverlay}*/ /*{bgOverlayXPos}*/ /*{bgOverlayYPos}*/ /*{bgOverlayRepeat}*/;\n\topacity: .3/*{opacityOverlay}*/;\n\t-ms-filter: \"alpha(opacity=30)\"/*{opacityFilterOverlay}*/; /* support: IE8 */\n}\n.ui-widget-shadow {\n\tbox-shadow: 0/*{offsetLeftShadow}*/ 0/*{offsetTopShadow}*/ 5px/*{thicknessShadow}*/ #666666/*{bgColorShadow}*/;\n}\n", ""]);
  // Exports
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
  
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/tooltip.css":
  /*!******************************************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/tooltip.css ***!
    \******************************************************************************************************************************************************************************************************************/
  /***/ ((module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
  // Imports
  
  var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
  // Module
  ___CSS_LOADER_EXPORT___.push([module.id, "/*!\n * jQuery UI Tooltip 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/tooltip/#theming\n */\n.ui-tooltip {\n\tpadding: 8px;\n\tposition: absolute;\n\tz-index: 9999;\n\tmax-width: 300px;\n}\nbody .ui-tooltip {\n\tborder-width: 2px;\n}\n", ""]);
  // Exports
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
  
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/js-datepicker/dist/datepicker.min.css":
  /*!**********************************************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/js-datepicker/dist/datepicker.min.css ***!
    \**********************************************************************************************************************************************************************************************************************/
  /***/ ((module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
  // Imports
  
  var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
  // Module
  ___CSS_LOADER_EXPORT___.push([module.id, ".qs-datepicker-container{-webkit-box-orient:vertical;-webkit-box-direction:normal;background:#fff;border:1px solid grey;border-radius:.263921875em;-webkit-box-shadow:0 1.25em 1.25em -.9375em rgba(0,0,0,.3);box-shadow:0 1.25em 1.25em -.9375em rgba(0,0,0,.3);color:#000;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;font-family:sans-serif;font-size:1rem;overflow:hidden;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:15.625em;z-index:9001}.qs-datepicker-container *{-webkit-box-sizing:border-box;box-sizing:border-box}.qs-centered{left:50%;position:fixed;top:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.qs-hidden{display:none}.qs-overlay{-webkit-box-orient:vertical;-webkit-box-direction:normal;background:rgba(0,0,0,.75);color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;height:100%;left:0;opacity:1;padding:.5em;position:absolute;top:0;-webkit-transition:opacity .3s;transition:opacity .3s;width:100%;z-index:1}.qs-overlay.qs-hidden{opacity:0;z-index:-1}.qs-overlay .qs-overlay-year{background:transparent;border:none;border-bottom:1px solid #fff;border-radius:0;color:#fff;display:block;font-size:.875em;margin:0 auto;padding:.25em 0;text-align:center;width:80%}.qs-overlay .qs-overlay-year::-webkit-inner-spin-button{-webkit-appearance:none}.qs-overlay .qs-close{cursor:pointer;padding:.5em;position:absolute;right:0;top:0}.qs-overlay .qs-submit{background:hsla(0,0%,50%,.4);border:1px solid #fff;border-radius:.263921875em;cursor:pointer;margin:0 auto auto;padding:.5em}.qs-overlay .qs-submit.qs-disabled{border-color:grey;color:grey;cursor:not-allowed}.qs-overlay .qs-overlay-month-container{-webkit-box-flex:1;-ms-flex-positive:1;display:-webkit-box;display:-ms-flexbox;display:flex;flex-grow:1;-ms-flex-wrap:wrap;flex-wrap:wrap}.qs-overlay .qs-overlay-month{-webkit-box-pack:center;-ms-flex-pack:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;display:-webkit-box;display:-ms-flexbox;display:flex;justify-content:center;opacity:.5;-webkit-transition:opacity .15s;transition:opacity .15s;width:calc(100% / 3)}.qs-overlay .qs-overlay-month.active,.qs-overlay .qs-overlay-month:hover{opacity:1}.qs-controls{-webkit-box-pack:justify;-ms-flex-pack:justify;-webkit-box-align:center;-ms-flex-align:center;-webkit-box-flex:1;-ms-flex-positive:1;-ms-flex-negative:0;align-items:center;background:#d3d3d3;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-filter:blur(0);filter:blur(0);flex-grow:1;flex-shrink:0;justify-content:space-between;-webkit-transition:-webkit-filter .3s;transition:-webkit-filter .3s;transition:filter .3s;transition:filter .3s, -webkit-filter .3s;transition:filter .3s,-webkit-filter .3s;width:100%}.qs-controls.qs-blur{-webkit-filter:blur(5px);filter:blur(5px)}.qs-arrow{border-radius:.263921875em;cursor:pointer;height:1.5625em;position:relative;-webkit-transition:background .15s;transition:background .15s;width:1.5625em}.qs-arrow:hover{background:rgba(0,0,0,.1)}.qs-arrow:hover.qs-left:after{border-right-color:#000}.qs-arrow:hover.qs-right:after{border-left-color:#000}.qs-arrow:after{border:.390625em solid transparent;content:\"\";position:absolute;top:50%;-webkit-transition:border .2s;transition:border .2s}.qs-arrow.qs-left:after{border-right-color:grey;right:50%;-webkit-transform:translate(25%,-50%);-ms-transform:translate(25%,-50%);transform:translate(25%,-50%)}.qs-arrow.qs-right:after{border-left-color:grey;left:50%;-webkit-transform:translate(-25%,-50%);-ms-transform:translate(-25%,-50%);transform:translate(-25%,-50%)}.qs-month-year{border-bottom:1px solid transparent;font-weight:700;-webkit-transition:border .2s;transition:border .2s}.qs-month-year:not(.qs-disabled-year-overlay){cursor:pointer}.qs-month-year:not(.qs-disabled-year-overlay):hover{border-bottom:1px solid grey}.qs-month-year:active:focus,.qs-month-year:focus{outline:none}.qs-month{padding-right:.5ex}.qs-year{padding-left:.5ex}.qs-squares{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-filter:blur(0);filter:blur(0);-ms-flex-wrap:wrap;flex-wrap:wrap;padding:.3125em;-webkit-transition:-webkit-filter .3s;transition:-webkit-filter .3s;transition:filter .3s;transition:filter .3s, -webkit-filter .3s;transition:filter .3s,-webkit-filter .3s}.qs-squares.qs-blur{-webkit-filter:blur(5px);filter:blur(5px)}.qs-square{-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:center;-ms-flex-pack:center;align-items:center;border-radius:.263921875em;cursor:pointer;display:-webkit-box;display:-ms-flexbox;display:flex;height:1.5625em;justify-content:center;-webkit-transition:background .1s;transition:background .1s;width:calc(100% / 7)}.qs-square:not(.qs-empty):not(.qs-disabled):not(.qs-day):not(.qs-active):hover{background:orange}.qs-current{font-weight:700;text-decoration:underline}.qs-active,.qs-range-end,.qs-range-start{background:#add8e6}.qs-range-start:not(.qs-range-6){border-bottom-right-radius:0;border-top-right-radius:0}.qs-range-middle{background:#d4ebf2}.qs-range-middle:not(.qs-range-0):not(.qs-range-6){border-radius:0}.qs-range-middle.qs-range-0{border-bottom-right-radius:0;border-top-right-radius:0}.qs-range-end:not(.qs-range-0),.qs-range-middle.qs-range-6{border-bottom-left-radius:0;border-top-left-radius:0}.qs-disabled,.qs-outside-current-month{opacity:.2}.qs-disabled{cursor:not-allowed}.qs-day,.qs-empty{cursor:default}.qs-day{color:grey;font-weight:700}.qs-event{position:relative}.qs-event:after{background:#07f;border-radius:50%;bottom:0;content:\"\";height:.46875em;position:absolute;right:0;width:.46875em}", ""]);
  // Exports
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
  
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/select2/dist/css/select2.css":
  /*!*************************************************************************************************************************************************************************************************************!*\
    !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/select2/dist/css/select2.css ***!
    \*************************************************************************************************************************************************************************************************************/
  /***/ ((module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
  /* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
  // Imports
  
  var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
  // Module
  ___CSS_LOADER_EXPORT___.push([module.id, ".select2-container {\n  box-sizing: border-box;\n  display: inline-block;\n  margin: 0;\n  position: relative;\n  vertical-align: middle; }\n  .select2-container .select2-selection--single {\n    box-sizing: border-box;\n    cursor: pointer;\n    display: block;\n    height: 28px;\n    -moz-user-select: none;\n         user-select: none;\n    -webkit-user-select: none; }\n    .select2-container .select2-selection--single .select2-selection__rendered {\n      display: block;\n      padding-left: 8px;\n      padding-right: 20px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap; }\n    .select2-container .select2-selection--single .select2-selection__clear {\n      background-color: transparent;\n      border: none;\n      font-size: 1em; }\n  .select2-container[dir=\"rtl\"] .select2-selection--single .select2-selection__rendered {\n    padding-right: 8px;\n    padding-left: 20px; }\n  .select2-container .select2-selection--multiple {\n    box-sizing: border-box;\n    cursor: pointer;\n    display: block;\n    min-height: 32px;\n    -moz-user-select: none;\n         user-select: none;\n    -webkit-user-select: none; }\n    .select2-container .select2-selection--multiple .select2-selection__rendered {\n      display: inline;\n      list-style: none;\n      padding: 0; }\n    .select2-container .select2-selection--multiple .select2-selection__clear {\n      background-color: transparent;\n      border: none;\n      font-size: 1em; }\n  .select2-container .select2-search--inline .select2-search__field {\n    box-sizing: border-box;\n    border: none;\n    font-size: 100%;\n    margin-top: 5px;\n    margin-left: 5px;\n    padding: 0;\n    max-width: 100%;\n    resize: none;\n    height: 18px;\n    vertical-align: bottom;\n    font-family: sans-serif;\n    overflow: hidden;\n    word-break: keep-all; }\n    .select2-container .select2-search--inline .select2-search__field::-webkit-search-cancel-button {\n      -webkit-appearance: none; }\n\n.select2-dropdown {\n  background-color: white;\n  border: 1px solid #aaa;\n  border-radius: 4px;\n  box-sizing: border-box;\n  display: block;\n  position: absolute;\n  left: -100000px;\n  width: 100%;\n  z-index: 1051; }\n\n.select2-results {\n  display: block; }\n\n.select2-results__options {\n  list-style: none;\n  margin: 0;\n  padding: 0; }\n\n.select2-results__option {\n  padding: 6px;\n  -moz-user-select: none;\n       user-select: none;\n  -webkit-user-select: none; }\n\n.select2-results__option--selectable {\n  cursor: pointer; }\n\n.select2-container--open .select2-dropdown {\n  left: 0; }\n\n.select2-container--open .select2-dropdown--above {\n  border-bottom: none;\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0; }\n\n.select2-container--open .select2-dropdown--below {\n  border-top: none;\n  border-top-left-radius: 0;\n  border-top-right-radius: 0; }\n\n.select2-search--dropdown {\n  display: block;\n  padding: 4px; }\n  .select2-search--dropdown .select2-search__field {\n    padding: 4px;\n    width: 100%;\n    box-sizing: border-box; }\n    .select2-search--dropdown .select2-search__field::-webkit-search-cancel-button {\n      -webkit-appearance: none; }\n  .select2-search--dropdown.select2-search--hide {\n    display: none; }\n\n.select2-close-mask {\n  border: 0;\n  margin: 0;\n  padding: 0;\n  display: block;\n  position: fixed;\n  left: 0;\n  top: 0;\n  min-height: 100%;\n  min-width: 100%;\n  height: auto;\n  width: auto;\n  opacity: 0;\n  z-index: 99;\n  background-color: #fff;\n  filter: alpha(opacity=0); }\n\n.select2-hidden-accessible {\n  border: 0 !important;\n  clip: rect(0 0 0 0) !important;\n  -webkit-clip-path: inset(50%) !important;\n  clip-path: inset(50%) !important;\n  height: 1px !important;\n  overflow: hidden !important;\n  padding: 0 !important;\n  position: absolute !important;\n  width: 1px !important;\n  white-space: nowrap !important; }\n\n.select2-container--default .select2-selection--single {\n  background-color: #fff;\n  border: 1px solid #aaa;\n  border-radius: 4px; }\n  .select2-container--default .select2-selection--single .select2-selection__rendered {\n    color: #444;\n    line-height: 28px; }\n  .select2-container--default .select2-selection--single .select2-selection__clear {\n    cursor: pointer;\n    float: right;\n    font-weight: bold;\n    height: 26px;\n    margin-right: 20px;\n    padding-right: 0px; }\n  .select2-container--default .select2-selection--single .select2-selection__placeholder {\n    color: #999; }\n  .select2-container--default .select2-selection--single .select2-selection__arrow {\n    height: 26px;\n    position: absolute;\n    top: 1px;\n    right: 1px;\n    width: 20px; }\n    .select2-container--default .select2-selection--single .select2-selection__arrow b {\n      border-color: #888 transparent transparent transparent;\n      border-style: solid;\n      border-width: 5px 4px 0 4px;\n      height: 0;\n      left: 50%;\n      margin-left: -4px;\n      margin-top: -2px;\n      position: absolute;\n      top: 50%;\n      width: 0; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--single .select2-selection__clear {\n  float: left; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--single .select2-selection__arrow {\n  left: 1px;\n  right: auto; }\n\n.select2-container--default.select2-container--disabled .select2-selection--single {\n  background-color: #eee;\n  cursor: default; }\n  .select2-container--default.select2-container--disabled .select2-selection--single .select2-selection__clear {\n    display: none; }\n\n.select2-container--default.select2-container--open .select2-selection--single .select2-selection__arrow b {\n  border-color: transparent transparent #888 transparent;\n  border-width: 0 4px 5px 4px; }\n\n.select2-container--default .select2-selection--multiple {\n  background-color: white;\n  border: 1px solid #aaa;\n  border-radius: 4px;\n  cursor: text;\n  padding-bottom: 5px;\n  padding-right: 5px;\n  position: relative; }\n  .select2-container--default .select2-selection--multiple.select2-selection--clearable {\n    padding-right: 25px; }\n  .select2-container--default .select2-selection--multiple .select2-selection__clear {\n    cursor: pointer;\n    font-weight: bold;\n    height: 20px;\n    margin-right: 10px;\n    margin-top: 5px;\n    position: absolute;\n    right: 0;\n    padding: 1px; }\n  .select2-container--default .select2-selection--multiple .select2-selection__choice {\n    background-color: #e4e4e4;\n    border: 1px solid #aaa;\n    border-radius: 4px;\n    box-sizing: border-box;\n    display: inline-block;\n    margin-left: 5px;\n    margin-top: 5px;\n    padding: 0;\n    padding-left: 20px;\n    position: relative;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    vertical-align: bottom;\n    white-space: nowrap; }\n  .select2-container--default .select2-selection--multiple .select2-selection__choice__display {\n    cursor: default;\n    padding-left: 2px;\n    padding-right: 5px; }\n  .select2-container--default .select2-selection--multiple .select2-selection__choice__remove {\n    background-color: transparent;\n    border: none;\n    border-right: 1px solid #aaa;\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n    color: #999;\n    cursor: pointer;\n    font-size: 1em;\n    font-weight: bold;\n    padding: 0 4px;\n    position: absolute;\n    left: 0;\n    top: 0; }\n    .select2-container--default .select2-selection--multiple .select2-selection__choice__remove:hover, .select2-container--default .select2-selection--multiple .select2-selection__choice__remove:focus {\n      background-color: #f1f1f1;\n      color: #333;\n      outline: none; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice {\n  margin-left: 5px;\n  margin-right: auto; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice__display {\n  padding-left: 5px;\n  padding-right: 2px; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice__remove {\n  border-left: 1px solid #aaa;\n  border-right: none;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px; }\n\n.select2-container--default[dir=\"rtl\"] .select2-selection--multiple .select2-selection__clear {\n  float: left;\n  margin-left: 10px;\n  margin-right: auto; }\n\n.select2-container--default.select2-container--focus .select2-selection--multiple {\n  border: solid black 1px;\n  outline: 0; }\n\n.select2-container--default.select2-container--disabled .select2-selection--multiple {\n  background-color: #eee;\n  cursor: default; }\n\n.select2-container--default.select2-container--disabled .select2-selection__choice__remove {\n  display: none; }\n\n.select2-container--default.select2-container--open.select2-container--above .select2-selection--single, .select2-container--default.select2-container--open.select2-container--above .select2-selection--multiple {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0; }\n\n.select2-container--default.select2-container--open.select2-container--below .select2-selection--single, .select2-container--default.select2-container--open.select2-container--below .select2-selection--multiple {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0; }\n\n.select2-container--default .select2-search--dropdown .select2-search__field {\n  border: 1px solid #aaa; }\n\n.select2-container--default .select2-search--inline .select2-search__field {\n  background: transparent;\n  border: none;\n  outline: 0;\n  box-shadow: none;\n  -webkit-appearance: textfield; }\n\n.select2-container--default .select2-results > .select2-results__options {\n  max-height: 200px;\n  overflow-y: auto; }\n\n.select2-container--default .select2-results__option .select2-results__option {\n  padding-left: 1em; }\n  .select2-container--default .select2-results__option .select2-results__option .select2-results__group {\n    padding-left: 0; }\n  .select2-container--default .select2-results__option .select2-results__option .select2-results__option {\n    margin-left: -1em;\n    padding-left: 2em; }\n    .select2-container--default .select2-results__option .select2-results__option .select2-results__option .select2-results__option {\n      margin-left: -2em;\n      padding-left: 3em; }\n      .select2-container--default .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option {\n        margin-left: -3em;\n        padding-left: 4em; }\n        .select2-container--default .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option {\n          margin-left: -4em;\n          padding-left: 5em; }\n          .select2-container--default .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option .select2-results__option {\n            margin-left: -5em;\n            padding-left: 6em; }\n\n.select2-container--default .select2-results__option--group {\n  padding: 0; }\n\n.select2-container--default .select2-results__option--disabled {\n  color: #999; }\n\n.select2-container--default .select2-results__option--selected {\n  background-color: #ddd; }\n\n.select2-container--default .select2-results__option--highlighted.select2-results__option--selectable {\n  background-color: #5897fb;\n  color: white; }\n\n.select2-container--default .select2-results__group {\n  cursor: default;\n  display: block;\n  padding: 6px; }\n\n.select2-container--classic .select2-selection--single {\n  background-color: #f7f7f7;\n  border: 1px solid #aaa;\n  border-radius: 4px;\n  outline: 0;\n  background-image: linear-gradient(to bottom, white 50%, #eeeeee 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFFFF', endColorstr='#FFEEEEEE', GradientType=0); }\n  .select2-container--classic .select2-selection--single:focus {\n    border: 1px solid #5897fb; }\n  .select2-container--classic .select2-selection--single .select2-selection__rendered {\n    color: #444;\n    line-height: 28px; }\n  .select2-container--classic .select2-selection--single .select2-selection__clear {\n    cursor: pointer;\n    float: right;\n    font-weight: bold;\n    height: 26px;\n    margin-right: 20px; }\n  .select2-container--classic .select2-selection--single .select2-selection__placeholder {\n    color: #999; }\n  .select2-container--classic .select2-selection--single .select2-selection__arrow {\n    background-color: #ddd;\n    border: none;\n    border-left: 1px solid #aaa;\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n    height: 26px;\n    position: absolute;\n    top: 1px;\n    right: 1px;\n    width: 20px;\n    background-image: linear-gradient(to bottom, #eeeeee 50%, #cccccc 100%);\n    background-repeat: repeat-x;\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFEEEEEE', endColorstr='#FFCCCCCC', GradientType=0); }\n    .select2-container--classic .select2-selection--single .select2-selection__arrow b {\n      border-color: #888 transparent transparent transparent;\n      border-style: solid;\n      border-width: 5px 4px 0 4px;\n      height: 0;\n      left: 50%;\n      margin-left: -4px;\n      margin-top: -2px;\n      position: absolute;\n      top: 50%;\n      width: 0; }\n\n.select2-container--classic[dir=\"rtl\"] .select2-selection--single .select2-selection__clear {\n  float: left; }\n\n.select2-container--classic[dir=\"rtl\"] .select2-selection--single .select2-selection__arrow {\n  border: none;\n  border-right: 1px solid #aaa;\n  border-radius: 0;\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n  left: 1px;\n  right: auto; }\n\n.select2-container--classic.select2-container--open .select2-selection--single {\n  border: 1px solid #5897fb; }\n  .select2-container--classic.select2-container--open .select2-selection--single .select2-selection__arrow {\n    background: transparent;\n    border: none; }\n    .select2-container--classic.select2-container--open .select2-selection--single .select2-selection__arrow b {\n      border-color: transparent transparent #888 transparent;\n      border-width: 0 4px 5px 4px; }\n\n.select2-container--classic.select2-container--open.select2-container--above .select2-selection--single {\n  border-top: none;\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n  background-image: linear-gradient(to bottom, white 0%, #eeeeee 50%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFFFF', endColorstr='#FFEEEEEE', GradientType=0); }\n\n.select2-container--classic.select2-container--open.select2-container--below .select2-selection--single {\n  border-bottom: none;\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n  background-image: linear-gradient(to bottom, #eeeeee 50%, white 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFEEEEEE', endColorstr='#FFFFFFFF', GradientType=0); }\n\n.select2-container--classic .select2-selection--multiple {\n  background-color: white;\n  border: 1px solid #aaa;\n  border-radius: 4px;\n  cursor: text;\n  outline: 0;\n  padding-bottom: 5px;\n  padding-right: 5px; }\n  .select2-container--classic .select2-selection--multiple:focus {\n    border: 1px solid #5897fb; }\n  .select2-container--classic .select2-selection--multiple .select2-selection__clear {\n    display: none; }\n  .select2-container--classic .select2-selection--multiple .select2-selection__choice {\n    background-color: #e4e4e4;\n    border: 1px solid #aaa;\n    border-radius: 4px;\n    display: inline-block;\n    margin-left: 5px;\n    margin-top: 5px;\n    padding: 0; }\n  .select2-container--classic .select2-selection--multiple .select2-selection__choice__display {\n    cursor: default;\n    padding-left: 2px;\n    padding-right: 5px; }\n  .select2-container--classic .select2-selection--multiple .select2-selection__choice__remove {\n    background-color: transparent;\n    border: none;\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n    color: #888;\n    cursor: pointer;\n    font-size: 1em;\n    font-weight: bold;\n    padding: 0 4px; }\n    .select2-container--classic .select2-selection--multiple .select2-selection__choice__remove:hover {\n      color: #555;\n      outline: none; }\n\n.select2-container--classic[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice {\n  margin-left: 5px;\n  margin-right: auto; }\n\n.select2-container--classic[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice__display {\n  padding-left: 5px;\n  padding-right: 2px; }\n\n.select2-container--classic[dir=\"rtl\"] .select2-selection--multiple .select2-selection__choice__remove {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px; }\n\n.select2-container--classic.select2-container--open .select2-selection--multiple {\n  border: 1px solid #5897fb; }\n\n.select2-container--classic.select2-container--open.select2-container--above .select2-selection--multiple {\n  border-top: none;\n  border-top-left-radius: 0;\n  border-top-right-radius: 0; }\n\n.select2-container--classic.select2-container--open.select2-container--below .select2-selection--multiple {\n  border-bottom: none;\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0; }\n\n.select2-container--classic .select2-search--dropdown .select2-search__field {\n  border: 1px solid #aaa;\n  outline: 0; }\n\n.select2-container--classic .select2-search--inline .select2-search__field {\n  outline: 0;\n  box-shadow: none; }\n\n.select2-container--classic .select2-dropdown {\n  background-color: white;\n  border: 1px solid transparent; }\n\n.select2-container--classic .select2-dropdown--above {\n  border-bottom: none; }\n\n.select2-container--classic .select2-dropdown--below {\n  border-top: none; }\n\n.select2-container--classic .select2-results > .select2-results__options {\n  max-height: 200px;\n  overflow-y: auto; }\n\n.select2-container--classic .select2-results__option--group {\n  padding: 0; }\n\n.select2-container--classic .select2-results__option--disabled {\n  color: grey; }\n\n.select2-container--classic .select2-results__option--highlighted.select2-results__option--selectable {\n  background-color: #3875d7;\n  color: white; }\n\n.select2-container--classic .select2-results__group {\n  cursor: default;\n  display: block;\n  padding: 6px; }\n\n.select2-container--classic.select2-container--open .select2-dropdown {\n  border-color: #5897fb; }\n", ""]);
  // Exports
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
  
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/runtime/api.js":
  /*!*****************************************************!*\
    !*** ./node_modules/css-loader/dist/runtime/api.js ***!
    \*****************************************************/
  /***/ ((module) => {
  
  "use strict";
  
  
  /*
    MIT License http://www.opensource.org/licenses/mit-license.php
    Author Tobias Koppers @sokra
  */
  // css base code, injected by the css-loader
  // eslint-disable-next-line func-names
  module.exports = function (cssWithMappingToString) {
    var list = []; // return the list of modules as css string
  
    list.toString = function toString() {
      return this.map(function (item) {
        var content = cssWithMappingToString(item);
  
        if (item[2]) {
          return "@media ".concat(item[2], " {").concat(content, "}");
        }
  
        return content;
      }).join("");
    }; // import a list of modules into the list
    // eslint-disable-next-line func-names
  
  
    list.i = function (modules, mediaQuery, dedupe) {
      if (typeof modules === "string") {
        // eslint-disable-next-line no-param-reassign
        modules = [[null, modules, ""]];
      }
  
      var alreadyImportedModules = {};
  
      if (dedupe) {
        for (var i = 0; i < this.length; i++) {
          // eslint-disable-next-line prefer-destructuring
          var id = this[i][0];
  
          if (id != null) {
            alreadyImportedModules[id] = true;
          }
        }
      }
  
      for (var _i = 0; _i < modules.length; _i++) {
        var item = [].concat(modules[_i]);
  
        if (dedupe && alreadyImportedModules[item[0]]) {
          // eslint-disable-next-line no-continue
          continue;
        }
  
        if (mediaQuery) {
          if (!item[2]) {
            item[2] = mediaQuery;
          } else {
            item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
          }
        }
  
        list.push(item);
      }
    };
  
    return list;
  };
  
  /***/ }),
  
  /***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
  /*!********************************************************!*\
    !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
    \********************************************************/
  /***/ ((module) => {
  
  "use strict";
  
  
  module.exports = function (url, options) {
    if (!options) {
      // eslint-disable-next-line no-param-reassign
      options = {};
    } // eslint-disable-next-line no-underscore-dangle, no-param-reassign
  
  
    url = url && url.__esModule ? url.default : url;
  
    if (typeof url !== "string") {
      return url;
    } // If url is already wrapped in quotes, remove them
  
  
    if (/^['"].*['"]$/.test(url)) {
      // eslint-disable-next-line no-param-reassign
      url = url.slice(1, -1);
    }
  
    if (options.hash) {
      // eslint-disable-next-line no-param-reassign
      url += options.hash;
    } // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
  
  
    if (/["'() \t\n]/.test(url) || options.needQuotes) {
      return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
    }
  
    return url;
  };
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_444444_256x240.png?d1b818587c3bc65058fe43800e4a191c");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_555555_256x240.png?35d57320d9df28ec0d0d8bd1b5c75983");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_777620_256x240.png?f423048bf942a7a33b33b1b982ecdb51");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_777777_256x240.png?f5d5fce2f36b5776eab8b314efc2dfd8");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_cc0000_256x240.png?5cbbd560bcf30acb95dd3b0b0d61645a");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png":
  /*!*******************************************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png ***!
    \*******************************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("/images/vendor/jquery-ui/themes/base/ui-icons_ffffff_256x240.png?92bef7e45fed3caba8dc9348edef4df2");
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/core.js":
  /*!*******************************************!*\
    !*** ./node_modules/jquery-ui/ui/core.js ***!
    \*******************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// This file is deprecated in 1.12.0 to be removed in 1.14
  ( function() {
  "use strict";
  
  !(__WEBPACK_AMD_DEFINE_FACTORY__ = ([
    "jquery",
    "./data",
    "./disable-selection",
    "./focusable",
    "./form",
    "./ie",
    "./keycode",
    "./labels",
    "./jquery-patch.js",
    "./plugin",
    "./safe-active-element",
    "./safe-blur",
    "./scroll-parent",
    "./tabbable",
    "./unique-id",
    "./version"
  ]),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
      __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } )();
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/data.js":
  /*!*******************************************!*\
    !*** ./node_modules/jquery-ui/ui/data.js ***!
    \*******************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI :data 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: :data Selector
  //>>group: Core
  //>>description: Selects elements which have data stored under the specified key.
  //>>docs: http://api.jqueryui.com/data-selector/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  return $.extend( $.expr.pseudos, {
    data: $.expr.createPseudo ?
      $.expr.createPseudo( function( dataName ) {
        return function( elem ) {
          return !!$.data( elem, dataName );
        };
      } ) :
  
      // Support: jQuery <1.8
      function( elem, i, match ) {
        return !!$.data( elem, match[ 3 ] );
      }
  } );
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/ie.js":
  /*!*****************************************!*\
    !*** ./node_modules/jquery-ui/ui/ie.js ***!
    \*****************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  // This file is deprecated
  return $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/keycode.js":
  /*!**********************************************!*\
    !*** ./node_modules/jquery-ui/ui/keycode.js ***!
    \**********************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Keycode 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: Keycode
  //>>group: Core
  //>>description: Provide keycodes as keynames
  //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  return $.ui.keyCode = {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  };
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/position.js":
  /*!***********************************************!*\
    !*** ./node_modules/jquery-ui/ui/position.js ***!
    \***********************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Position 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/position/
   */
  
  //>>label: Position
  //>>group: Core
  //>>description: Positions elements relative to other elements.
  //>>docs: http://api.jqueryui.com/position/
  //>>demos: http://jqueryui.com/position/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  ( function() {
  var cachedScrollbarWidth,
    max = Math.max,
    abs = Math.abs,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;
  
  function getOffsets( offsets, width, height ) {
    return [
      parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
      parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
    ];
  }
  
  function parseCss( element, property ) {
    return parseInt( $.css( element, property ), 10 ) || 0;
  }
  
  function isWindow( obj ) {
    return obj != null && obj === obj.window;
  }
  
  function getDimensions( elem ) {
    var raw = elem[ 0 ];
    if ( raw.nodeType === 9 ) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: 0, left: 0 }
      };
    }
    if ( isWindow( raw ) ) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
      };
    }
    if ( raw.preventDefault ) {
      return {
        width: 0,
        height: 0,
        offset: { top: raw.pageY, left: raw.pageX }
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
    };
  }
  
  $.position = {
    scrollbarWidth: function() {
      if ( cachedScrollbarWidth !== undefined ) {
        return cachedScrollbarWidth;
      }
      var w1, w2,
        div = $( "<div style=" +
          "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
          "<div style='height:300px;width:auto;'></div></div>" ),
        innerDiv = div.children()[ 0 ];
  
      $( "body" ).append( div );
      w1 = innerDiv.offsetWidth;
      div.css( "overflow", "scroll" );
  
      w2 = innerDiv.offsetWidth;
  
      if ( w1 === w2 ) {
        w2 = div[ 0 ].clientWidth;
      }
  
      div.remove();
  
      return ( cachedScrollbarWidth = w1 - w2 );
    },
    getScrollInfo: function( within ) {
      var overflowX = within.isWindow || within.isDocument ? "" :
          within.element.css( "overflow-x" ),
        overflowY = within.isWindow || within.isDocument ? "" :
          within.element.css( "overflow-y" ),
        hasOverflowX = overflowX === "scroll" ||
          ( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
        hasOverflowY = overflowY === "scroll" ||
          ( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function( element ) {
      var withinElement = $( element || window ),
        isElemWindow = isWindow( withinElement[ 0 ] ),
        isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
        hasOffset = !isElemWindow && !isDocument;
      return {
        element: withinElement,
        isWindow: isElemWindow,
        isDocument: isDocument,
        offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: withinElement.outerWidth(),
        height: withinElement.outerHeight()
      };
    }
  };
  
  $.fn.position = function( options ) {
    if ( !options || !options.of ) {
      return _position.apply( this, arguments );
    }
  
    // Make a copy, we don't want to modify arguments
    options = $.extend( {}, options );
  
    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
  
      // Make sure string options are treated as CSS selectors
      target = typeof options.of === "string" ?
        $( document ).find( options.of ) :
        $( options.of ),
  
      within = $.position.getWithinInfo( options.within ),
      scrollInfo = $.position.getScrollInfo( within ),
      collision = ( options.collision || "flip" ).split( " " ),
      offsets = {};
  
    dimensions = getDimensions( target );
    if ( target[ 0 ].preventDefault ) {
  
      // Force left top to allow flipping
      options.at = "left top";
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
  
    // Clone to reuse original targetOffset later
    basePosition = $.extend( {}, targetOffset );
  
    // Force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each( [ "my", "at" ], function() {
      var pos = ( options[ this ] || "" ).split( " " ),
        horizontalOffset,
        verticalOffset;
  
      if ( pos.length === 1 ) {
        pos = rhorizontal.test( pos[ 0 ] ) ?
          pos.concat( [ "center" ] ) :
          rvertical.test( pos[ 0 ] ) ?
            [ "center" ].concat( pos ) :
            [ "center", "center" ];
      }
      pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
      pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
  
      // Calculate offsets
      horizontalOffset = roffset.exec( pos[ 0 ] );
      verticalOffset = roffset.exec( pos[ 1 ] );
      offsets[ this ] = [
        horizontalOffset ? horizontalOffset[ 0 ] : 0,
        verticalOffset ? verticalOffset[ 0 ] : 0
      ];
  
      // Reduce to just the positions without the offsets
      options[ this ] = [
        rposition.exec( pos[ 0 ] )[ 0 ],
        rposition.exec( pos[ 1 ] )[ 0 ]
      ];
    } );
  
    // Normalize collision option
    if ( collision.length === 1 ) {
      collision[ 1 ] = collision[ 0 ];
    }
  
    if ( options.at[ 0 ] === "right" ) {
      basePosition.left += targetWidth;
    } else if ( options.at[ 0 ] === "center" ) {
      basePosition.left += targetWidth / 2;
    }
  
    if ( options.at[ 1 ] === "bottom" ) {
      basePosition.top += targetHeight;
    } else if ( options.at[ 1 ] === "center" ) {
      basePosition.top += targetHeight / 2;
    }
  
    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
    basePosition.left += atOffset[ 0 ];
    basePosition.top += atOffset[ 1 ];
  
    return this.each( function() {
      var collisionPosition, using,
        elem = $( this ),
        elemWidth = elem.outerWidth(),
        elemHeight = elem.outerHeight(),
        marginLeft = parseCss( this, "marginLeft" ),
        marginTop = parseCss( this, "marginTop" ),
        collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
          scrollInfo.width,
        collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
          scrollInfo.height,
        position = $.extend( {}, basePosition ),
        myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
  
      if ( options.my[ 0 ] === "right" ) {
        position.left -= elemWidth;
      } else if ( options.my[ 0 ] === "center" ) {
        position.left -= elemWidth / 2;
      }
  
      if ( options.my[ 1 ] === "bottom" ) {
        position.top -= elemHeight;
      } else if ( options.my[ 1 ] === "center" ) {
        position.top -= elemHeight / 2;
      }
  
      position.left += myOffset[ 0 ];
      position.top += myOffset[ 1 ];
  
      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };
  
      $.each( [ "left", "top" ], function( i, dir ) {
        if ( $.ui.position[ collision[ i ] ] ) {
          $.ui.position[ collision[ i ] ][ dir ]( position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          } );
        }
      } );
  
      if ( options.using ) {
  
        // Adds feedback as second argument to using callback, if present
        using = function( props ) {
          var left = targetOffset.left - position.left,
            right = left + targetWidth - elemWidth,
            top = targetOffset.top - position.top,
            bottom = top + targetHeight - elemHeight,
            feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
              vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
            };
          if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
            feedback.horizontal = "center";
          }
          if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
            feedback.vertical = "middle";
          }
          if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
            feedback.important = "horizontal";
          } else {
            feedback.important = "vertical";
          }
          options.using.call( this, props, feedback );
        };
      }
  
      elem.offset( $.extend( position, { using: using } ) );
    } );
  };
  
  $.ui.position = {
    fit: {
      left: function( position, data ) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
          outerWidth = within.width,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = withinOffset - collisionPosLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
          newOverRight;
  
        // Element is wider than within
        if ( data.collisionWidth > outerWidth ) {
  
          // Element is initially over the left side of within
          if ( overLeft > 0 && overRight <= 0 ) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
              withinOffset;
            position.left += overLeft - newOverRight;
  
          // Element is initially over right side of within
          } else if ( overRight > 0 && overLeft <= 0 ) {
            position.left = withinOffset;
  
          // Element is initially over both left and right sides of within
          } else {
            if ( overLeft > overRight ) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
  
        // Too far left -> align with left edge
        } else if ( overLeft > 0 ) {
          position.left += overLeft;
  
        // Too far right -> align with right edge
        } else if ( overRight > 0 ) {
          position.left -= overRight;
  
        // Adjust based on position and margin
        } else {
          position.left = max( position.left - collisionPosLeft, position.left );
        }
      },
      top: function( position, data ) {
        var within = data.within,
          withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
          outerHeight = data.within.height,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = withinOffset - collisionPosTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
          newOverBottom;
  
        // Element is taller than within
        if ( data.collisionHeight > outerHeight ) {
  
          // Element is initially over the top of within
          if ( overTop > 0 && overBottom <= 0 ) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
              withinOffset;
            position.top += overTop - newOverBottom;
  
          // Element is initially over bottom of within
          } else if ( overBottom > 0 && overTop <= 0 ) {
            position.top = withinOffset;
  
          // Element is initially over both top and bottom of within
          } else {
            if ( overTop > overBottom ) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
  
        // Too far up -> align with top
        } else if ( overTop > 0 ) {
          position.top += overTop;
  
        // Too far down -> align with bottom edge
        } else if ( overBottom > 0 ) {
          position.top -= overBottom;
  
        // Adjust based on position and margin
        } else {
          position.top = max( position.top - collisionPosTop, position.top );
        }
      }
    },
    flip: {
      left: function( position, data ) {
        var within = data.within,
          withinOffset = within.offset.left + within.scrollLeft,
          outerWidth = within.width,
          offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
          collisionPosLeft = position.left - data.collisionPosition.marginLeft,
          overLeft = collisionPosLeft - offsetLeft,
          overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
          myOffset = data.my[ 0 ] === "left" ?
            -data.elemWidth :
            data.my[ 0 ] === "right" ?
              data.elemWidth :
              0,
          atOffset = data.at[ 0 ] === "left" ?
            data.targetWidth :
            data.at[ 0 ] === "right" ?
              -data.targetWidth :
              0,
          offset = -2 * data.offset[ 0 ],
          newOverRight,
          newOverLeft;
  
        if ( overLeft < 0 ) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
            outerWidth - withinOffset;
          if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
            position.left += myOffset + atOffset + offset;
          }
        } else if ( overRight > 0 ) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
            atOffset + offset - offsetLeft;
          if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function( position, data ) {
        var within = data.within,
          withinOffset = within.offset.top + within.scrollTop,
          outerHeight = within.height,
          offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
          collisionPosTop = position.top - data.collisionPosition.marginTop,
          overTop = collisionPosTop - offsetTop,
          overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
          top = data.my[ 1 ] === "top",
          myOffset = top ?
            -data.elemHeight :
            data.my[ 1 ] === "bottom" ?
              data.elemHeight :
              0,
          atOffset = data.at[ 1 ] === "top" ?
            data.targetHeight :
            data.at[ 1 ] === "bottom" ?
              -data.targetHeight :
              0,
          offset = -2 * data.offset[ 1 ],
          newOverTop,
          newOverBottom;
        if ( overTop < 0 ) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
            outerHeight - withinOffset;
          if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
            position.top += myOffset + atOffset + offset;
          }
        } else if ( overBottom > 0 ) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
            offset - offsetTop;
          if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function() {
        $.ui.position.flip.left.apply( this, arguments );
        $.ui.position.fit.left.apply( this, arguments );
      },
      top: function() {
        $.ui.position.flip.top.apply( this, arguments );
        $.ui.position.fit.top.apply( this, arguments );
      }
    }
  };
  
  } )();
  
  return $.ui.position;
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/scroll-parent.js":
  /*!****************************************************!*\
    !*** ./node_modules/jquery-ui/ui/scroll-parent.js ***!
    \****************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Scroll Parent 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: scrollParent
  //>>group: Core
  //>>description: Get the closest ancestor element that is scrollable.
  //>>docs: http://api.jqueryui.com/scrollParent/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  return $.fn.scrollParent = function( includeHidden ) {
    var position = this.css( "position" ),
      excludeStaticParent = position === "absolute",
      overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
      scrollParent = this.parents().filter( function() {
        var parent = $( this );
        if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
          return false;
        }
        return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
          parent.css( "overflow-x" ) );
      } ).eq( 0 );
  
    return position === "fixed" || !scrollParent.length ?
      $( this[ 0 ].ownerDocument || document ) :
      scrollParent;
  };
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/unique-id.js":
  /*!************************************************!*\
    !*** ./node_modules/jquery-ui/ui/unique-id.js ***!
    \************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Unique ID 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: uniqueId
  //>>group: Core
  //>>description: Functions to generate and remove uniqueId's
  //>>docs: http://api.jqueryui.com/uniqueId/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  return $.fn.extend( {
    uniqueId: ( function() {
      var uuid = 0;
  
      return function() {
        return this.each( function() {
          if ( !this.id ) {
            this.id = "ui-id-" + ( ++uuid );
          }
        } );
      };
    } )(),
  
    removeUniqueId: function() {
      return this.each( function() {
        if ( /^ui-id-\d+$/.test( this.id ) ) {
          $( this ).removeAttr( "id" );
        }
      } );
    }
  } );
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/version.js":
  /*!**********************************************!*\
    !*** ./node_modules/jquery-ui/ui/version.js ***!
    \**********************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  $.ui = $.ui || {};
  
  return $.ui.version = "1.13.2";
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/widget.js":
  /*!*********************************************!*\
    !*** ./node_modules/jquery-ui/ui/widget.js ***!
    \*********************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Widget 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: Widget
  //>>group: Core
  //>>description: Provides a factory for creating stateful widgets with a common API.
  //>>docs: http://api.jqueryui.com/jQuery.widget/
  //>>demos: http://jqueryui.com/widget/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  var widgetUuid = 0;
  var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
  var widgetSlice = Array.prototype.slice;
  
  $.cleanData = ( function( orig ) {
    return function( elems ) {
      var events, elem, i;
      for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
  
        // Only trigger remove when necessary to save time
        events = $._data( elem, "events" );
        if ( events && events.remove ) {
          $( elem ).triggerHandler( "remove" );
        }
      }
      orig( elems );
    };
  } )( $.cleanData );
  
  $.widget = function( name, base, prototype ) {
    var existingConstructor, constructor, basePrototype;
  
    // ProxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    var proxiedPrototype = {};
  
    var namespace = name.split( "." )[ 0 ];
    name = name.split( "." )[ 1 ];
    var fullName = namespace + "-" + name;
  
    if ( !prototype ) {
      prototype = base;
      base = $.Widget;
    }
  
    if ( Array.isArray( prototype ) ) {
      prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
    }
  
    // Create selector for plugin
    $.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
      return !!$.data( elem, fullName );
    };
  
    $[ namespace ] = $[ namespace ] || {};
    existingConstructor = $[ namespace ][ name ];
    constructor = $[ namespace ][ name ] = function( options, element ) {
  
      // Allow instantiation without "new" keyword
      if ( !this || !this._createWidget ) {
        return new constructor( options, element );
      }
  
      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if ( arguments.length ) {
        this._createWidget( options, element );
      }
    };
  
    // Extend with the existing constructor to carry over any static properties
    $.extend( constructor, existingConstructor, {
      version: prototype.version,
  
      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend( {}, prototype ),
  
      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    } );
  
    basePrototype = new base();
  
    // We need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend( {}, basePrototype.options );
    $.each( prototype, function( prop, value ) {
      if ( typeof value !== "function" ) {
        proxiedPrototype[ prop ] = value;
        return;
      }
      proxiedPrototype[ prop ] = ( function() {
        function _super() {
          return base.prototype[ prop ].apply( this, arguments );
        }
  
        function _superApply( args ) {
          return base.prototype[ prop ].apply( this, args );
        }
  
        return function() {
          var __super = this._super;
          var __superApply = this._superApply;
          var returnValue;
  
          this._super = _super;
          this._superApply = _superApply;
  
          returnValue = value.apply( this, arguments );
  
          this._super = __super;
          this._superApply = __superApply;
  
          return returnValue;
        };
      } )();
    } );
    constructor.prototype = $.widget.extend( basePrototype, {
  
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    } );
  
    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if ( existingConstructor ) {
      $.each( existingConstructor._childConstructors, function( i, child ) {
        var childPrototype = child.prototype;
  
        // Redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
          child._proto );
      } );
  
      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push( constructor );
    }
  
    $.widget.bridge( name, constructor );
  
    return constructor;
  };
  
  $.widget.extend = function( target ) {
    var input = widgetSlice.call( arguments, 1 );
    var inputIndex = 0;
    var inputLength = input.length;
    var key;
    var value;
  
    for ( ; inputIndex < inputLength; inputIndex++ ) {
      for ( key in input[ inputIndex ] ) {
        value = input[ inputIndex ][ key ];
        if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {
  
          // Clone objects
          if ( $.isPlainObject( value ) ) {
            target[ key ] = $.isPlainObject( target[ key ] ) ?
              $.widget.extend( {}, target[ key ], value ) :
  
              // Don't extend strings, arrays, etc. with objects
              $.widget.extend( {}, value );
  
          // Copy everything else by reference
          } else {
            target[ key ] = value;
          }
        }
      }
    }
    return target;
  };
  
  $.widget.bridge = function( name, object ) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[ name ] = function( options ) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call( arguments, 1 );
      var returnValue = this;
  
      if ( isMethodCall ) {
  
        // If this is an empty collection, we need to have the instance method
        // return undefined instead of the jQuery instance
        if ( !this.length && options === "instance" ) {
          returnValue = undefined;
        } else {
          this.each( function() {
            var methodValue;
            var instance = $.data( this, fullName );
  
            if ( options === "instance" ) {
              returnValue = instance;
              return false;
            }
  
            if ( !instance ) {
              return $.error( "cannot call methods on " + name +
                " prior to initialization; " +
                "attempted to call method '" + options + "'" );
            }
  
            if ( typeof instance[ options ] !== "function" ||
              options.charAt( 0 ) === "_" ) {
              return $.error( "no such method '" + options + "' for " + name +
                " widget instance" );
            }
  
            methodValue = instance[ options ].apply( instance, args );
  
            if ( methodValue !== instance && methodValue !== undefined ) {
              returnValue = methodValue && methodValue.jquery ?
                returnValue.pushStack( methodValue.get() ) :
                methodValue;
              return false;
            }
          } );
        }
      } else {
  
        // Allow multiple hashes to be passed on init
        if ( args.length ) {
          options = $.widget.extend.apply( null, [ options ].concat( args ) );
        }
  
        this.each( function() {
          var instance = $.data( this, fullName );
          if ( instance ) {
            instance.option( options || {} );
            if ( instance._init ) {
              instance._init();
            }
          } else {
            $.data( this, fullName, new object( options, this ) );
          }
        } );
      }
  
      return returnValue;
    };
  };
  
  $.Widget = function( /* options, element */ ) {};
  $.Widget._childConstructors = [];
  
  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
  
    options: {
      classes: {},
      disabled: false,
  
      // Callbacks
      create: null
    },
  
    _createWidget: function( options, element ) {
      element = $( element || this.defaultElement || this )[ 0 ];
      this.element = $( element );
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
  
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};
  
      if ( element !== this ) {
        $.data( element, this.widgetFullName, this );
        this._on( true, this.element, {
          remove: function( event ) {
            if ( event.target === element ) {
              this.destroy();
            }
          }
        } );
        this.document = $( element.style ?
  
          // Element within the document
          element.ownerDocument :
  
          // Element is window or document
          element.document || element );
        this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
      }
  
      this.options = $.widget.extend( {},
        this.options,
        this._getCreateOptions(),
        options );
  
      this._create();
  
      if ( this.options.disabled ) {
        this._setOptionDisabled( this.options.disabled );
      }
  
      this._trigger( "create", null, this._getCreateEventData() );
      this._init();
    },
  
    _getCreateOptions: function() {
      return {};
    },
  
    _getCreateEventData: $.noop,
  
    _create: $.noop,
  
    _init: $.noop,
  
    destroy: function() {
      var that = this;
  
      this._destroy();
      $.each( this.classesElementLookup, function( key, value ) {
        that._removeClass( value, key );
      } );
  
      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .off( this.eventNamespace )
        .removeData( this.widgetFullName );
      this.widget()
        .off( this.eventNamespace )
        .removeAttr( "aria-disabled" );
  
      // Clean up events and states
      this.bindings.off( this.eventNamespace );
    },
  
    _destroy: $.noop,
  
    widget: function() {
      return this.element;
    },
  
    option: function( key, value ) {
      var options = key;
      var parts;
      var curOption;
      var i;
  
      if ( arguments.length === 0 ) {
  
        // Don't return a reference to the internal hash
        return $.widget.extend( {}, this.options );
      }
  
      if ( typeof key === "string" ) {
  
        // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split( "." );
        key = parts.shift();
        if ( parts.length ) {
          curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
          for ( i = 0; i < parts.length - 1; i++ ) {
            curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
            curOption = curOption[ parts[ i ] ];
          }
          key = parts.pop();
          if ( arguments.length === 1 ) {
            return curOption[ key ] === undefined ? null : curOption[ key ];
          }
          curOption[ key ] = value;
        } else {
          if ( arguments.length === 1 ) {
            return this.options[ key ] === undefined ? null : this.options[ key ];
          }
          options[ key ] = value;
        }
      }
  
      this._setOptions( options );
  
      return this;
    },
  
    _setOptions: function( options ) {
      var key;
  
      for ( key in options ) {
        this._setOption( key, options[ key ] );
      }
  
      return this;
    },
  
    _setOption: function( key, value ) {
      if ( key === "classes" ) {
        this._setOptionClasses( value );
      }
  
      this.options[ key ] = value;
  
      if ( key === "disabled" ) {
        this._setOptionDisabled( value );
      }
  
      return this;
    },
  
    _setOptionClasses: function( value ) {
      var classKey, elements, currentElements;
  
      for ( classKey in value ) {
        currentElements = this.classesElementLookup[ classKey ];
        if ( value[ classKey ] === this.options.classes[ classKey ] ||
            !currentElements ||
            !currentElements.length ) {
          continue;
        }
  
        // We are doing this to create a new jQuery object because the _removeClass() call
        // on the next line is going to destroy the reference to the current elements being
        // tracked. We need to save a copy of this collection so that we can add the new classes
        // below.
        elements = $( currentElements.get() );
        this._removeClass( currentElements, classKey );
  
        // We don't use _addClass() here, because that uses this.options.classes
        // for generating the string of classes. We want to use the value passed in from
        // _setOption(), this is the new value of the classes option which was passed to
        // _setOption(). We pass this value directly to _classes().
        elements.addClass( this._classes( {
          element: elements,
          keys: classKey,
          classes: value,
          add: true
        } ) );
      }
    },
  
    _setOptionDisabled: function( value ) {
      this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );
  
      // If the widget is becoming disabled, then nothing is interactive
      if ( value ) {
        this._removeClass( this.hoverable, null, "ui-state-hover" );
        this._removeClass( this.focusable, null, "ui-state-focus" );
      }
    },
  
    enable: function() {
      return this._setOptions( { disabled: false } );
    },
  
    disable: function() {
      return this._setOptions( { disabled: true } );
    },
  
    _classes: function( options ) {
      var full = [];
      var that = this;
  
      options = $.extend( {
        element: this.element,
        classes: this.options.classes || {}
      }, options );
  
      function bindRemoveEvent() {
        var nodesToBind = [];
  
        options.element.each( function( _, element ) {
          var isTracked = $.map( that.classesElementLookup, function( elements ) {
            return elements;
          } )
            .some( function( elements ) {
              return elements.is( element );
            } );
  
          if ( !isTracked ) {
            nodesToBind.push( element );
          }
        } );
  
        that._on( $( nodesToBind ), {
          remove: "_untrackClassesElement"
        } );
      }
  
      function processClassString( classes, checkOption ) {
        var current, i;
        for ( i = 0; i < classes.length; i++ ) {
          current = that.classesElementLookup[ classes[ i ] ] || $();
          if ( options.add ) {
            bindRemoveEvent();
            current = $( $.uniqueSort( current.get().concat( options.element.get() ) ) );
          } else {
            current = $( current.not( options.element ).get() );
          }
          that.classesElementLookup[ classes[ i ] ] = current;
          full.push( classes[ i ] );
          if ( checkOption && options.classes[ classes[ i ] ] ) {
            full.push( options.classes[ classes[ i ] ] );
          }
        }
      }
  
      if ( options.keys ) {
        processClassString( options.keys.match( /\S+/g ) || [], true );
      }
      if ( options.extra ) {
        processClassString( options.extra.match( /\S+/g ) || [] );
      }
  
      return full.join( " " );
    },
  
    _untrackClassesElement: function( event ) {
      var that = this;
      $.each( that.classesElementLookup, function( key, value ) {
        if ( $.inArray( event.target, value ) !== -1 ) {
          that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
        }
      } );
  
      this._off( $( event.target ) );
    },
  
    _removeClass: function( element, keys, extra ) {
      return this._toggleClass( element, keys, extra, false );
    },
  
    _addClass: function( element, keys, extra ) {
      return this._toggleClass( element, keys, extra, true );
    },
  
    _toggleClass: function( element, keys, extra, add ) {
      add = ( typeof add === "boolean" ) ? add : extra;
      var shift = ( typeof element === "string" || element === null ),
        options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add
        };
      options.element.toggleClass( this._classes( options ), add );
      return this;
    },
  
    _on: function( suppressDisabledCheck, element, handlers ) {
      var delegateElement;
      var instance = this;
  
      // No suppressDisabledCheck flag, shuffle arguments
      if ( typeof suppressDisabledCheck !== "boolean" ) {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
  
      // No element argument, shuffle and use this.element
      if ( !handlers ) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $( element );
        this.bindings = this.bindings.add( element );
      }
  
      $.each( handlers, function( event, handler ) {
        function handlerProxy() {
  
          // Allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if ( !suppressDisabledCheck &&
              ( instance.options.disabled === true ||
              $( this ).hasClass( "ui-state-disabled" ) ) ) {
            return;
          }
          return ( typeof handler === "string" ? instance[ handler ] : handler )
            .apply( instance, arguments );
        }
  
        // Copy the guid so direct unbinding works
        if ( typeof handler !== "string" ) {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }
  
        var match = event.match( /^([\w:-]*)\s*(.*)$/ );
        var eventName = match[ 1 ] + instance.eventNamespace;
        var selector = match[ 2 ];
  
        if ( selector ) {
          delegateElement.on( eventName, selector, handlerProxy );
        } else {
          element.on( eventName, handlerProxy );
        }
      } );
    },
  
    _off: function( element, eventName ) {
      eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
        this.eventNamespace;
      element.off( eventName );
  
      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $( this.bindings.not( element ).get() );
      this.focusable = $( this.focusable.not( element ).get() );
      this.hoverable = $( this.hoverable.not( element ).get() );
    },
  
    _delay: function( handler, delay ) {
      function handlerProxy() {
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply( instance, arguments );
      }
      var instance = this;
      return setTimeout( handlerProxy, delay || 0 );
    },
  
    _hoverable: function( element ) {
      this.hoverable = this.hoverable.add( element );
      this._on( element, {
        mouseenter: function( event ) {
          this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
        },
        mouseleave: function( event ) {
          this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
        }
      } );
    },
  
    _focusable: function( element ) {
      this.focusable = this.focusable.add( element );
      this._on( element, {
        focusin: function( event ) {
          this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
        },
        focusout: function( event ) {
          this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
        }
      } );
    },
  
    _trigger: function( type, event, data ) {
      var prop, orig;
      var callback = this.options[ type ];
  
      data = data || {};
      event = $.Event( event );
      event.type = ( type === this.widgetEventPrefix ?
        type :
        this.widgetEventPrefix + type ).toLowerCase();
  
      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[ 0 ];
  
      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if ( orig ) {
        for ( prop in orig ) {
          if ( !( prop in event ) ) {
            event[ prop ] = orig[ prop ];
          }
        }
      }
  
      this.element.trigger( event, data );
      return !( typeof callback === "function" &&
        callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
        event.isDefaultPrevented() );
    }
  };
  
  $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
    $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
      if ( typeof options === "string" ) {
        options = { effect: options };
      }
  
      var hasOptions;
      var effectName = !options ?
        method :
        options === true || typeof options === "number" ?
          defaultEffect :
          options.effect || defaultEffect;
  
      options = options || {};
      if ( typeof options === "number" ) {
        options = { duration: options };
      } else if ( options === true ) {
        options = {};
      }
  
      hasOptions = !$.isEmptyObject( options );
      options.complete = callback;
  
      if ( options.delay ) {
        element.delay( options.delay );
      }
  
      if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
        element[ method ]( options );
      } else if ( effectName !== method && element[ effectName ] ) {
        element[ effectName ]( options.duration, options.easing, callback );
      } else {
        element.queue( function( next ) {
          $( this )[ method ]();
          if ( callback ) {
            callback.call( element[ 0 ] );
          }
          next();
        } );
      }
    };
  } );
  
  return $.widget;
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/widgets/mouse.js":
  /*!****************************************************!*\
    !*** ./node_modules/jquery-ui/ui/widgets/mouse.js ***!
    \****************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Mouse 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: Mouse
  //>>group: Widgets
  //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
  //>>docs: http://api.jqueryui.com/mouse/
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
        __webpack_require__(/*! ../ie */ "./node_modules/jquery-ui/ui/ie.js"),
        __webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
        __webpack_require__(/*! ../widget */ "./node_modules/jquery-ui/ui/widget.js")
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  var mouseHandled = false;
  $( document ).on( "mouseup", function() {
    mouseHandled = false;
  } );
  
  return $.widget( "ui.mouse", {
    version: "1.13.2",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function() {
      var that = this;
  
      this.element
        .on( "mousedown." + this.widgetName, function( event ) {
          return that._mouseDown( event );
        } )
        .on( "click." + this.widgetName, function( event ) {
          if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
            $.removeData( event.target, that.widgetName + ".preventClickEvent" );
            event.stopImmediatePropagation();
            return false;
          }
        } );
  
      this.started = false;
    },
  
    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
      this.element.off( "." + this.widgetName );
      if ( this._mouseMoveDelegate ) {
        this.document
          .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
          .off( "mouseup." + this.widgetName, this._mouseUpDelegate );
      }
    },
  
    _mouseDown: function( event ) {
  
      // don't let more than one widget handle mouseStart
      if ( mouseHandled ) {
        return;
      }
  
      this._mouseMoved = false;
  
      // We may have missed mouseup (out of window)
      if ( this._mouseStarted ) {
        this._mouseUp( event );
      }
  
      this._mouseDownEvent = event;
  
      var that = this,
        btnIsLeft = ( event.which === 1 ),
  
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
          $( event.target ).closest( this.options.cancel ).length : false );
      if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
        return true;
      }
  
      this.mouseDelayMet = !this.options.delay;
      if ( !this.mouseDelayMet ) {
        this._mouseDelayTimer = setTimeout( function() {
          that.mouseDelayMet = true;
        }, this.options.delay );
      }
  
      if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
        this._mouseStarted = ( this._mouseStart( event ) !== false );
        if ( !this._mouseStarted ) {
          event.preventDefault();
          return true;
        }
      }
  
      // Click event may never have fired (Gecko & Opera)
      if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
        $.removeData( event.target, this.widgetName + ".preventClickEvent" );
      }
  
      // These delegates are required to keep context
      this._mouseMoveDelegate = function( event ) {
        return that._mouseMove( event );
      };
      this._mouseUpDelegate = function( event ) {
        return that._mouseUp( event );
      };
  
      this.document
        .on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
        .on( "mouseup." + this.widgetName, this._mouseUpDelegate );
  
      event.preventDefault();
  
      mouseHandled = true;
      return true;
    },
  
    _mouseMove: function( event ) {
  
      // Only check for mouseups outside the document if you've moved inside the document
      // at least once. This prevents the firing of mouseup in the case of IE<9, which will
      // fire a mousemove event if content is placed under the cursor. See #7778
      // Support: IE <9
      if ( this._mouseMoved ) {
  
        // IE mouseup check - mouseup happened when mouse was out of window
        if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
            !event.button ) {
          return this._mouseUp( event );
  
        // Iframe mouseup check - mouseup occurred in another document
        } else if ( !event.which ) {
  
          // Support: Safari <=8 - 9
          // Safari sets which to 0 if you press any of the following keys
          // during a drag (#14461)
          if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
              event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
            this.ignoreMissingWhich = true;
          } else if ( !this.ignoreMissingWhich ) {
            return this._mouseUp( event );
          }
        }
      }
  
      if ( event.which || event.button ) {
        this._mouseMoved = true;
      }
  
      if ( this._mouseStarted ) {
        this._mouseDrag( event );
        return event.preventDefault();
      }
  
      if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
        this._mouseStarted =
          ( this._mouseStart( this._mouseDownEvent, event ) !== false );
        if ( this._mouseStarted ) {
          this._mouseDrag( event );
        } else {
          this._mouseUp( event );
        }
      }
  
      return !this._mouseStarted;
    },
  
    _mouseUp: function( event ) {
      this.document
        .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
        .off( "mouseup." + this.widgetName, this._mouseUpDelegate );
  
      if ( this._mouseStarted ) {
        this._mouseStarted = false;
  
        if ( event.target === this._mouseDownEvent.target ) {
          $.data( event.target, this.widgetName + ".preventClickEvent", true );
        }
  
        this._mouseStop( event );
      }
  
      if ( this._mouseDelayTimer ) {
        clearTimeout( this._mouseDelayTimer );
        delete this._mouseDelayTimer;
      }
  
      this.ignoreMissingWhich = false;
      mouseHandled = false;
      event.preventDefault();
    },
  
    _mouseDistanceMet: function( event ) {
      return ( Math.max(
          Math.abs( this._mouseDownEvent.pageX - event.pageX ),
          Math.abs( this._mouseDownEvent.pageY - event.pageY )
        ) >= this.options.distance
      );
    },
  
    _mouseDelayMet: function( /* event */ ) {
      return this.mouseDelayMet;
    },
  
    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function( /* event */ ) {},
    _mouseDrag: function( /* event */ ) {},
    _mouseStop: function( /* event */ ) {},
    _mouseCapture: function( /* event */ ) {
      return true;
    }
  } );
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/widgets/sortable.js":
  /*!*******************************************************!*\
    !*** ./node_modules/jquery-ui/ui/widgets/sortable.js ***!
    \*******************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Sortable 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: Sortable
  //>>group: Interactions
  //>>description: Enables items in a list to be sorted using the mouse.
  //>>docs: http://api.jqueryui.com/sortable/
  //>>demos: http://jqueryui.com/sortable/
  //>>css.structure: ../../themes/base/sortable.css
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
        __webpack_require__(/*! ./mouse */ "./node_modules/jquery-ui/ui/widgets/mouse.js"),
        __webpack_require__(/*! ../data */ "./node_modules/jquery-ui/ui/data.js"),
        __webpack_require__(/*! ../ie */ "./node_modules/jquery-ui/ui/ie.js"),
        __webpack_require__(/*! ../scroll-parent */ "./node_modules/jquery-ui/ui/scroll-parent.js"),
        __webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
        __webpack_require__(/*! ../widget */ "./node_modules/jquery-ui/ui/widget.js")
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  return $.widget( "ui.sortable", $.ui.mouse, {
    version: "1.13.2",
    widgetEventPrefix: "sort",
    ready: false,
    options: {
      appendTo: "parent",
      axis: false,
      connectWith: false,
      containment: false,
      cursor: "auto",
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: "original",
      items: "> *",
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: "default",
      tolerance: "intersect",
      zIndex: 1000,
  
      // Callbacks
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null
    },
  
    _isOverAxis: function( x, reference, size ) {
      return ( x >= reference ) && ( x < ( reference + size ) );
    },
  
    _isFloating: function( item ) {
      return ( /left|right/ ).test( item.css( "float" ) ) ||
        ( /inline|table-cell/ ).test( item.css( "display" ) );
    },
  
    _create: function() {
      this.containerCache = {};
      this._addClass( "ui-sortable" );
  
      //Get the items
      this.refresh();
  
      //Let's determine the parent's offset
      this.offset = this.element.offset();
  
      //Initialize mouse events for interaction
      this._mouseInit();
  
      this._setHandleClassName();
  
      //We're ready to go
      this.ready = true;
  
    },
  
    _setOption: function( key, value ) {
      this._super( key, value );
  
      if ( key === "handle" ) {
        this._setHandleClassName();
      }
    },
  
    _setHandleClassName: function() {
      var that = this;
      this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
      $.each( this.items, function() {
        that._addClass(
          this.instance.options.handle ?
            this.item.find( this.instance.options.handle ) :
            this.item,
          "ui-sortable-handle"
        );
      } );
    },
  
    _destroy: function() {
      this._mouseDestroy();
  
      for ( var i = this.items.length - 1; i >= 0; i-- ) {
        this.items[ i ].item.removeData( this.widgetName + "-item" );
      }
  
      return this;
    },
  
    _mouseCapture: function( event, overrideHandle ) {
      var currentItem = null,
        validHandle = false,
        that = this;
  
      if ( this.reverting ) {
        return false;
      }
  
      if ( this.options.disabled || this.options.type === "static" ) {
        return false;
      }
  
      //We have to refresh the items data once first
      this._refreshItems( event );
  
      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      $( event.target ).parents().each( function() {
        if ( $.data( this, that.widgetName + "-item" ) === that ) {
          currentItem = $( this );
          return false;
        }
      } );
      if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
        currentItem = $( event.target );
      }
  
      if ( !currentItem ) {
        return false;
      }
      if ( this.options.handle && !overrideHandle ) {
        $( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
          if ( this === event.target ) {
            validHandle = true;
          }
        } );
        if ( !validHandle ) {
          return false;
        }
      }
  
      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
  
    },
  
    _mouseStart: function( event, overrideHandle, noActivation ) {
  
      var i, body,
        o = this.options;
  
      this.currentContainer = this;
  
      //We only need to call refreshPositions, because the refreshItems call has been moved to
      // mouseCapture
      this.refreshPositions();
  
      //Prepare the dragged items parent
      this.appendTo = $( o.appendTo !== "parent" ?
          o.appendTo :
          this.currentItem.parent() );
  
      //Create and append the visible helper
      this.helper = this._createHelper( event );
  
      //Cache the helper size
      this._cacheHelperProportions();
  
      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */
  
      //Cache the margins of the original element
      this._cacheMargins();
  
      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
  
      $.extend( this.offset, {
        click: { //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
  
        // This is a relative to absolute position minus the actual position calculation -
        // only used for relative positioned helper
        relative: this._getRelativeOffset()
      } );
  
      // After we get the helper offset, but before we get the parent offset we can
      // change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css( "position", "absolute" );
      this.cssPosition = this.helper.css( "position" );
  
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      if ( o.cursorAt ) {
        this._adjustOffsetFromHelper( o.cursorAt );
      }
  
      //Cache the former DOM position
      this.domPosition = {
        prev: this.currentItem.prev()[ 0 ],
        parent: this.currentItem.parent()[ 0 ]
      };
  
      // If the helper is not the original, hide the original so it's not playing any role during
      // the drag, won't cause anything bad this way
      if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
        this.currentItem.hide();
      }
  
      //Create the placeholder
      this._createPlaceholder();
  
      //Get the next scrolling parent
      this.scrollParent = this.placeholder.scrollParent();
  
      $.extend( this.offset, {
        parent: this._getParentOffset()
      } );
  
      //Set a containment if given in the options
      if ( o.containment ) {
        this._setContainment();
      }
  
      if ( o.cursor && o.cursor !== "auto" ) { // cursor option
        body = this.document.find( "body" );
  
        // Support: IE
        this.storedCursor = body.css( "cursor" );
        body.css( "cursor", o.cursor );
  
        this.storedStylesheet =
          $( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
      }
  
      // We need to make sure to grab the zIndex before setting the
      // opacity, because setting the opacity to anything lower than 1
      // causes the zIndex to change from "auto" to 0.
      if ( o.zIndex ) { // zIndex option
        if ( this.helper.css( "zIndex" ) ) {
          this._storedZIndex = this.helper.css( "zIndex" );
        }
        this.helper.css( "zIndex", o.zIndex );
      }
  
      if ( o.opacity ) { // opacity option
        if ( this.helper.css( "opacity" ) ) {
          this._storedOpacity = this.helper.css( "opacity" );
        }
        this.helper.css( "opacity", o.opacity );
      }
  
      //Prepare scrolling
      if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          this.scrollParent[ 0 ].tagName !== "HTML" ) {
        this.overflowOffset = this.scrollParent.offset();
      }
  
      //Call callbacks
      this._trigger( "start", event, this._uiHash() );
  
      //Recache the helper size
      if ( !this._preserveHelperProportions ) {
        this._cacheHelperProportions();
      }
  
      //Post "activate" events to possible containers
      if ( !noActivation ) {
        for ( i = this.containers.length - 1; i >= 0; i-- ) {
          this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
        }
      }
  
      //Prepare possible droppables
      if ( $.ui.ddmanager ) {
        $.ui.ddmanager.current = this;
      }
  
      if ( $.ui.ddmanager && !o.dropBehaviour ) {
        $.ui.ddmanager.prepareOffsets( this, event );
      }
  
      this.dragging = true;
  
      this._addClass( this.helper, "ui-sortable-helper" );
  
      //Move the helper, if needed
      if ( !this.helper.parent().is( this.appendTo ) ) {
        this.helper.detach().appendTo( this.appendTo );
  
        //Update position
        this.offset.parent = this._getParentOffset();
      }
  
      //Generate the original position
      this.position = this.originalPosition = this._generatePosition( event );
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      this.lastPositionAbs = this.positionAbs = this._convertPositionTo( "absolute" );
  
      this._mouseDrag( event );
  
      return true;
  
    },
  
    _scroll: function( event ) {
      var o = this.options,
        scrolled = false;
  
      if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          this.scrollParent[ 0 ].tagName !== "HTML" ) {
  
        if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
            event.pageY < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollTop =
            scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
        } else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollTop =
            scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
        }
  
        if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
            event.pageX < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollLeft = scrolled =
            this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
        } else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollLeft = scrolled =
            this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
        }
  
      } else {
  
        if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
          scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
        } else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
            o.scrollSensitivity ) {
          scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
        }
  
        if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() - o.scrollSpeed
          );
        } else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
            o.scrollSensitivity ) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() + o.scrollSpeed
          );
        }
  
      }
  
      return scrolled;
    },
  
    _mouseDrag: function( event ) {
      var i, item, itemElement, intersection,
        o = this.options;
  
      //Compute the helpers position
      this.position = this._generatePosition( event );
      this.positionAbs = this._convertPositionTo( "absolute" );
  
      //Set the helper position
      if ( !this.options.axis || this.options.axis !== "y" ) {
        this.helper[ 0 ].style.left = this.position.left + "px";
      }
      if ( !this.options.axis || this.options.axis !== "x" ) {
        this.helper[ 0 ].style.top = this.position.top + "px";
      }
  
      //Do scrolling
      if ( o.scroll ) {
        if ( this._scroll( event ) !== false ) {
  
          //Update item positions used in position checks
          this._refreshItemPositions( true );
  
          if ( $.ui.ddmanager && !o.dropBehaviour ) {
            $.ui.ddmanager.prepareOffsets( this, event );
          }
        }
      }
  
      this.dragDirection = {
        vertical: this._getDragVerticalDirection(),
        horizontal: this._getDragHorizontalDirection()
      };
  
      //Rearrange
      for ( i = this.items.length - 1; i >= 0; i-- ) {
  
        //Cache variables and intersection, continue if no intersection
        item = this.items[ i ];
        itemElement = item.item[ 0 ];
        intersection = this._intersectsWithPointer( item );
        if ( !intersection ) {
          continue;
        }
  
        // Only put the placeholder inside the current Container, skip all
        // items from other containers. This works because when moving
        // an item from one container to another the
        // currentContainer is switched before the placeholder is moved.
        //
        // Without this, moving items in "sub-sortables" can cause
        // the placeholder to jitter between the outer and inner container.
        if ( item.instance !== this.currentContainer ) {
          continue;
        }
  
        // Cannot intersect with itself
        // no useless actions that have been done before
        // no action if the item moved is the parent of the item checked
        if ( itemElement !== this.currentItem[ 0 ] &&
          this.placeholder[ intersection === 1 ?
          "next" : "prev" ]()[ 0 ] !== itemElement &&
          !$.contains( this.placeholder[ 0 ], itemElement ) &&
          ( this.options.type === "semi-dynamic" ?
            !$.contains( this.element[ 0 ], itemElement ) :
            true
          )
        ) {
  
          this.direction = intersection === 1 ? "down" : "up";
  
          if ( this.options.tolerance === "pointer" ||
              this._intersectsWithSides( item ) ) {
            this._rearrange( event, item );
          } else {
            break;
          }
  
          this._trigger( "change", event, this._uiHash() );
          break;
        }
      }
  
      //Post events to containers
      this._contactContainers( event );
  
      //Interconnect with droppables
      if ( $.ui.ddmanager ) {
        $.ui.ddmanager.drag( this, event );
      }
  
      //Call callbacks
      this._trigger( "sort", event, this._uiHash() );
  
      this.lastPositionAbs = this.positionAbs;
      return false;
  
    },
  
    _mouseStop: function( event, noPropagation ) {
  
      if ( !event ) {
        return;
      }
  
      //If we are using droppables, inform the manager about the drop
      if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
        $.ui.ddmanager.drop( this, event );
      }
  
      if ( this.options.revert ) {
        var that = this,
          cur = this.placeholder.offset(),
          axis = this.options.axis,
          animation = {};
  
        if ( !axis || axis === "x" ) {
          animation.left = cur.left - this.offset.parent.left - this.margins.left +
            ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
              0 :
              this.offsetParent[ 0 ].scrollLeft
            );
        }
        if ( !axis || axis === "y" ) {
          animation.top = cur.top - this.offset.parent.top - this.margins.top +
            ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
              0 :
              this.offsetParent[ 0 ].scrollTop
            );
        }
        this.reverting = true;
        $( this.helper ).animate(
          animation,
          parseInt( this.options.revert, 10 ) || 500,
          function() {
            that._clear( event );
          }
        );
      } else {
        this._clear( event, noPropagation );
      }
  
      return false;
  
    },
  
    cancel: function() {
  
      if ( this.dragging ) {
  
        this._mouseUp( new $.Event( "mouseup", { target: null } ) );
  
        if ( this.options.helper === "original" ) {
          this.currentItem.css( this._storedCSS );
          this._removeClass( this.currentItem, "ui-sortable-helper" );
        } else {
          this.currentItem.show();
        }
  
        //Post deactivating events to containers
        for ( var i = this.containers.length - 1; i >= 0; i-- ) {
          this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
          if ( this.containers[ i ].containerCache.over ) {
            this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
            this.containers[ i ].containerCache.over = 0;
          }
        }
  
      }
  
      if ( this.placeholder ) {
  
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
        // it unbinds ALL events from the original node!
        if ( this.placeholder[ 0 ].parentNode ) {
          this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
        }
        if ( this.options.helper !== "original" && this.helper &&
            this.helper[ 0 ].parentNode ) {
          this.helper.remove();
        }
  
        $.extend( this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null
        } );
  
        if ( this.domPosition.prev ) {
          $( this.domPosition.prev ).after( this.currentItem );
        } else {
          $( this.domPosition.parent ).prepend( this.currentItem );
        }
      }
  
      return this;
  
    },
  
    serialize: function( o ) {
  
      var items = this._getItemsAsjQuery( o && o.connected ),
        str = [];
      o = o || {};
  
      $( items ).each( function() {
        var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
          .match( o.expression || ( /(.+)[\-=_](.+)/ ) );
        if ( res ) {
          str.push(
            ( o.key || res[ 1 ] + "[]" ) +
            "=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
        }
      } );
  
      if ( !str.length && o.key ) {
        str.push( o.key + "=" );
      }
  
      return str.join( "&" );
  
    },
  
    toArray: function( o ) {
  
      var items = this._getItemsAsjQuery( o && o.connected ),
        ret = [];
  
      o = o || {};
  
      items.each( function() {
        ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
      } );
      return ret;
  
    },
  
    /* Be careful with the following core functions */
    _intersectsWith: function( item ) {
  
      var x1 = this.positionAbs.left,
        x2 = x1 + this.helperProportions.width,
        y1 = this.positionAbs.top,
        y2 = y1 + this.helperProportions.height,
        l = item.left,
        r = l + item.width,
        t = item.top,
        b = t + item.height,
        dyClick = this.offset.click.top,
        dxClick = this.offset.click.left,
        isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
          ( y1 + dyClick ) < b ),
        isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
          ( x1 + dxClick ) < r ),
        isOverElement = isOverElementHeight && isOverElementWidth;
  
      if ( this.options.tolerance === "pointer" ||
        this.options.forcePointerForContainers ||
        ( this.options.tolerance !== "pointer" &&
          this.helperProportions[ this.floating ? "width" : "height" ] >
          item[ this.floating ? "width" : "height" ] )
      ) {
        return isOverElement;
      } else {
  
        return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
          x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
          t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
          y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half
  
      }
    },
  
    _intersectsWithPointer: function( item ) {
      var verticalDirection, horizontalDirection,
        isOverElementHeight = ( this.options.axis === "x" ) ||
          this._isOverAxis(
            this.positionAbs.top + this.offset.click.top, item.top, item.height ),
        isOverElementWidth = ( this.options.axis === "y" ) ||
          this._isOverAxis(
            this.positionAbs.left + this.offset.click.left, item.left, item.width ),
        isOverElement = isOverElementHeight && isOverElementWidth;
  
      if ( !isOverElement ) {
        return false;
      }
  
      verticalDirection = this.dragDirection.vertical;
      horizontalDirection = this.dragDirection.horizontal;
  
      return this.floating ?
        ( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 ) :
        ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );
  
    },
  
    _intersectsWithSides: function( item ) {
  
      var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
          this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
        isOverRightHalf = this._isOverAxis( this.positionAbs.left +
          this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
        verticalDirection = this.dragDirection.vertical,
        horizontalDirection = this.dragDirection.horizontal;
  
      if ( this.floating && horizontalDirection ) {
        return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
          ( horizontalDirection === "left" && !isOverRightHalf ) );
      } else {
        return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
          ( verticalDirection === "up" && !isOverBottomHalf ) );
      }
  
    },
  
    _getDragVerticalDirection: function() {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && ( delta > 0 ? "down" : "up" );
    },
  
    _getDragHorizontalDirection: function() {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && ( delta > 0 ? "right" : "left" );
    },
  
    refresh: function( event ) {
      this._refreshItems( event );
      this._setHandleClassName();
      this.refreshPositions();
      return this;
    },
  
    _connectWith: function() {
      var options = this.options;
      return options.connectWith.constructor === String ?
        [ options.connectWith ] :
        options.connectWith;
    },
  
    _getItemsAsjQuery: function( connected ) {
  
      var i, j, cur, inst,
        items = [],
        queries = [],
        connectWith = this._connectWith();
  
      if ( connectWith && connected ) {
        for ( i = connectWith.length - 1; i >= 0; i-- ) {
          cur = $( connectWith[ i ], this.document[ 0 ] );
          for ( j = cur.length - 1; j >= 0; j-- ) {
            inst = $.data( cur[ j ], this.widgetFullName );
            if ( inst && inst !== this && !inst.options.disabled ) {
              queries.push( [ typeof inst.options.items === "function" ?
                inst.options.items.call( inst.element ) :
                $( inst.options.items, inst.element )
                  .not( ".ui-sortable-helper" )
                  .not( ".ui-sortable-placeholder" ), inst ] );
            }
          }
        }
      }
  
      queries.push( [ typeof this.options.items === "function" ?
        this.options.items
          .call( this.element, null, { options: this.options, item: this.currentItem } ) :
        $( this.options.items, this.element )
          .not( ".ui-sortable-helper" )
          .not( ".ui-sortable-placeholder" ), this ] );
  
      function addItems() {
        items.push( this );
      }
      for ( i = queries.length - 1; i >= 0; i-- ) {
        queries[ i ][ 0 ].each( addItems );
      }
  
      return $( items );
  
    },
  
    _removeCurrentsFromItems: function() {
  
      var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );
  
      this.items = $.grep( this.items, function( item ) {
        for ( var j = 0; j < list.length; j++ ) {
          if ( list[ j ] === item.item[ 0 ] ) {
            return false;
          }
        }
        return true;
      } );
  
    },
  
    _refreshItems: function( event ) {
  
      this.items = [];
      this.containers = [ this ];
  
      var i, j, cur, inst, targetData, _queries, item, queriesLength,
        items = this.items,
        queries = [ [ typeof this.options.items === "function" ?
          this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
          $( this.options.items, this.element ), this ] ],
        connectWith = this._connectWith();
  
      //Shouldn't be run the first time through due to massive slow-down
      if ( connectWith && this.ready ) {
        for ( i = connectWith.length - 1; i >= 0; i-- ) {
          cur = $( connectWith[ i ], this.document[ 0 ] );
          for ( j = cur.length - 1; j >= 0; j-- ) {
            inst = $.data( cur[ j ], this.widgetFullName );
            if ( inst && inst !== this && !inst.options.disabled ) {
              queries.push( [ typeof inst.options.items === "function" ?
                inst.options.items
                  .call( inst.element[ 0 ], event, { item: this.currentItem } ) :
                $( inst.options.items, inst.element ), inst ] );
              this.containers.push( inst );
            }
          }
        }
      }
  
      for ( i = queries.length - 1; i >= 0; i-- ) {
        targetData = queries[ i ][ 1 ];
        _queries = queries[ i ][ 0 ];
  
        for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
          item = $( _queries[ j ] );
  
          // Data for target checking (mouse manager)
          item.data( this.widgetName + "-item", targetData );
  
          items.push( {
            item: item,
            instance: targetData,
            width: 0, height: 0,
            left: 0, top: 0
          } );
        }
      }
  
    },
  
    _refreshItemPositions: function( fast ) {
      var i, item, t, p;
  
      for ( i = this.items.length - 1; i >= 0; i-- ) {
        item = this.items[ i ];
  
        //We ignore calculating positions of all connected containers when we're not over them
        if ( this.currentContainer && item.instance !== this.currentContainer &&
            item.item[ 0 ] !== this.currentItem[ 0 ] ) {
          continue;
        }
  
        t = this.options.toleranceElement ?
          $( this.options.toleranceElement, item.item ) :
          item.item;
  
        if ( !fast ) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }
  
        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
    },
  
    refreshPositions: function( fast ) {
  
      // Determine whether items are being displayed horizontally
      this.floating = this.items.length ?
        this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
        false;
  
      // This has to be redone because due to the item being moved out/into the offsetParent,
      // the offsetParent's position will change
      if ( this.offsetParent && this.helper ) {
        this.offset.parent = this._getParentOffset();
      }
  
      this._refreshItemPositions( fast );
  
      var i, p;
  
      if ( this.options.custom && this.options.custom.refreshContainers ) {
        this.options.custom.refreshContainers.call( this );
      } else {
        for ( i = this.containers.length - 1; i >= 0; i-- ) {
          p = this.containers[ i ].element.offset();
          this.containers[ i ].containerCache.left = p.left;
          this.containers[ i ].containerCache.top = p.top;
          this.containers[ i ].containerCache.width =
            this.containers[ i ].element.outerWidth();
          this.containers[ i ].containerCache.height =
            this.containers[ i ].element.outerHeight();
        }
      }
  
      return this;
    },
  
    _createPlaceholder: function( that ) {
      that = that || this;
      var className, nodeName,
        o = that.options;
  
      if ( !o.placeholder || o.placeholder.constructor === String ) {
        className = o.placeholder;
        nodeName = that.currentItem[ 0 ].nodeName.toLowerCase();
        o.placeholder = {
          element: function() {
  
            var element = $( "<" + nodeName + ">", that.document[ 0 ] );
  
            that._addClass( element, "ui-sortable-placeholder",
                className || that.currentItem[ 0 ].className )
              ._removeClass( element, "ui-sortable-helper" );
  
            if ( nodeName === "tbody" ) {
              that._createTrPlaceholder(
                that.currentItem.find( "tr" ).eq( 0 ),
                $( "<tr>", that.document[ 0 ] ).appendTo( element )
              );
            } else if ( nodeName === "tr" ) {
              that._createTrPlaceholder( that.currentItem, element );
            } else if ( nodeName === "img" ) {
              element.attr( "src", that.currentItem.attr( "src" ) );
            }
  
            if ( !className ) {
              element.css( "visibility", "hidden" );
            }
  
            return element;
          },
          update: function( container, p ) {
  
            // 1. If a className is set as 'placeholder option, we don't force sizes -
            // the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
            // class name is specified
            if ( className && !o.forcePlaceholderSize ) {
              return;
            }
  
            // If the element doesn't have a actual height or width by itself (without
            // styles coming from a stylesheet), it receives the inline height and width
            // from the dragged item. Or, if it's a tbody or tr, it's going to have a height
            // anyway since we're populating them with <td>s above, but they're unlikely to
            // be the correct height on their own if the row heights are dynamic, so we'll
            // always assign the height of the dragged item given forcePlaceholderSize
            // is true.
            if ( !p.height() || ( o.forcePlaceholderSize &&
                ( nodeName === "tbody" || nodeName === "tr" ) ) ) {
              p.height(
                that.currentItem.innerHeight() -
                parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
                parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
            }
            if ( !p.width() ) {
              p.width(
                that.currentItem.innerWidth() -
                parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
                parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
            }
          }
        };
      }
  
      //Create the placeholder
      that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );
  
      //Append it after the actual current item
      that.currentItem.after( that.placeholder );
  
      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update( that, that.placeholder );
  
    },
  
    _createTrPlaceholder: function( sourceTr, targetTr ) {
      var that = this;
  
      sourceTr.children().each( function() {
        $( "<td>&#160;</td>", that.document[ 0 ] )
          .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
          .appendTo( targetTr );
      } );
    },
  
    _contactContainers: function( event ) {
      var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
        floating, axis,
        innermostContainer = null,
        innermostIndex = null;
  
      // Get innermost container that intersects with item
      for ( i = this.containers.length - 1; i >= 0; i-- ) {
  
        // Never consider a container that's located within the item itself
        if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
          continue;
        }
  
        if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {
  
          // If we've already found a container and it's more "inner" than this, then continue
          if ( innermostContainer &&
              $.contains(
                this.containers[ i ].element[ 0 ],
                innermostContainer.element[ 0 ] ) ) {
            continue;
          }
  
          innermostContainer = this.containers[ i ];
          innermostIndex = i;
  
        } else {
  
          // container doesn't intersect. trigger "out" event if necessary
          if ( this.containers[ i ].containerCache.over ) {
            this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
            this.containers[ i ].containerCache.over = 0;
          }
        }
  
      }
  
      // If no intersecting containers found, return
      if ( !innermostContainer ) {
        return;
      }
  
      // Move the item into the container if it's not there already
      if ( this.containers.length === 1 ) {
        if ( !this.containers[ innermostIndex ].containerCache.over ) {
          this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
          this.containers[ innermostIndex ].containerCache.over = 1;
        }
      } else {
  
        // When entering a new container, we will find the item with the least distance and
        // append our item near it
        dist = 10000;
        itemWithLeastDistance = null;
        floating = innermostContainer.floating || this._isFloating( this.currentItem );
        posProperty = floating ? "left" : "top";
        sizeProperty = floating ? "width" : "height";
        axis = floating ? "pageX" : "pageY";
  
        for ( j = this.items.length - 1; j >= 0; j-- ) {
          if ( !$.contains(
              this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
          ) {
            continue;
          }
          if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
            continue;
          }
  
          cur = this.items[ j ].item.offset()[ posProperty ];
          nearBottom = false;
          if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
            nearBottom = true;
          }
  
          if ( Math.abs( event[ axis ] - cur ) < dist ) {
            dist = Math.abs( event[ axis ] - cur );
            itemWithLeastDistance = this.items[ j ];
            this.direction = nearBottom ? "up" : "down";
          }
        }
  
        //Check if dropOnEmpty is enabled
        if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
          return;
        }
  
        if ( this.currentContainer === this.containers[ innermostIndex ] ) {
          if ( !this.currentContainer.containerCache.over ) {
            this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
            this.currentContainer.containerCache.over = 1;
          }
          return;
        }
  
        if ( itemWithLeastDistance ) {
          this._rearrange( event, itemWithLeastDistance, null, true );
        } else {
          this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
        }
        this._trigger( "change", event, this._uiHash() );
        this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
        this.currentContainer = this.containers[ innermostIndex ];
  
        //Update the placeholder
        this.options.placeholder.update( this.currentContainer, this.placeholder );
  
        //Update scrollParent
        this.scrollParent = this.placeholder.scrollParent();
  
        //Update overflowOffset
        if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
            this.scrollParent[ 0 ].tagName !== "HTML" ) {
          this.overflowOffset = this.scrollParent.offset();
        }
  
        this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
        this.containers[ innermostIndex ].containerCache.over = 1;
      }
  
    },
  
    _createHelper: function( event ) {
  
      var o = this.options,
        helper = typeof o.helper === "function" ?
          $( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
          ( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );
  
      //Add the helper to the DOM if that didn't happen already
      if ( !helper.parents( "body" ).length ) {
        this.appendTo[ 0 ].appendChild( helper[ 0 ] );
      }
  
      if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
        this._storedCSS = {
          width: this.currentItem[ 0 ].style.width,
          height: this.currentItem[ 0 ].style.height,
          position: this.currentItem.css( "position" ),
          top: this.currentItem.css( "top" ),
          left: this.currentItem.css( "left" )
        };
      }
  
      if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
        helper.width( this.currentItem.width() );
      }
      if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
        helper.height( this.currentItem.height() );
      }
  
      return helper;
  
    },
  
    _adjustOffsetFromHelper: function( obj ) {
      if ( typeof obj === "string" ) {
        obj = obj.split( " " );
      }
      if ( Array.isArray( obj ) ) {
        obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
      }
      if ( "left" in obj ) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ( "right" in obj ) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ( "top" in obj ) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ( "bottom" in obj ) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
  
    _getParentOffset: function() {
  
      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();
  
      // This is a special case where we need to modify a offset calculated on start, since the
      // following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the
      // next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
      // the document, which means that the scroll is included in the initial calculation of the
      // offset of the parent, and never recalculated upon drag
      if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
  
      // This needs to be actually done for all browsers, since pageX/pageY includes this
      // information with an ugly IE fix
      if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
          ( this.offsetParent[ 0 ].tagName &&
          this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
        po = { top: 0, left: 0 };
      }
  
      return {
        top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
        left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
      };
  
    },
  
    _getRelativeOffset: function() {
  
      if ( this.cssPosition === "relative" ) {
        var p = this.currentItem.position();
        return {
          top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
            this.scrollParent.scrollTop(),
          left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
            this.scrollParent.scrollLeft()
        };
      } else {
        return { top: 0, left: 0 };
      }
  
    },
  
    _cacheMargins: function() {
      this.margins = {
        left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
        top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
      };
    },
  
    _cacheHelperProportions: function() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
  
    _setContainment: function() {
  
      var ce, co, over,
        o = this.options;
      if ( o.containment === "parent" ) {
        o.containment = this.helper[ 0 ].parentNode;
      }
      if ( o.containment === "document" || o.containment === "window" ) {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          o.containment === "document" ?
            this.document.width() :
            this.window.width() - this.helperProportions.width - this.margins.left,
          ( o.containment === "document" ?
            ( this.document.height() || document.body.parentNode.scrollHeight ) :
            this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
          ) - this.helperProportions.height - this.margins.top
        ];
      }
  
      if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
        ce = $( o.containment )[ 0 ];
        co = $( o.containment ).offset();
        over = ( $( ce ).css( "overflow" ) !== "hidden" );
  
        this.containment = [
          co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
            ( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
          co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
            ( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
          co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
            ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
            ( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
            this.helperProportions.width - this.margins.left,
          co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
            ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
            ( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
            this.helperProportions.height - this.margins.top
        ];
      }
  
    },
  
    _convertPositionTo: function( d, pos ) {
  
      if ( !pos ) {
        pos = this.position;
      }
      var mod = d === "absolute" ? 1 : -1,
        scroll = this.cssPosition === "absolute" &&
          !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
            this.offsetParent :
            this.scrollParent,
        scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );
  
      return {
        top: (
  
          // The absolute mouse position
          pos.top	+
  
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top * mod +
  
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top * mod -
          ( ( this.cssPosition === "fixed" ?
            -this.scrollParent.scrollTop() :
            ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
        ),
        left: (
  
          // The absolute mouse position
          pos.left +
  
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left * mod +
  
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left * mod	-
          ( ( this.cssPosition === "fixed" ?
            -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
            scroll.scrollLeft() ) * mod )
        )
      };
  
    },
  
    _generatePosition: function( event ) {
  
      var top, left,
        o = this.options,
        pageX = event.pageX,
        pageY = event.pageY,
        scroll = this.cssPosition === "absolute" &&
          !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
            this.offsetParent :
            this.scrollParent,
          scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );
  
      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
        this.offset.relative = this._getRelativeOffset();
      }
  
      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */
  
      if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options
  
        if ( this.containment ) {
          if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
            pageX = this.containment[ 0 ] + this.offset.click.left;
          }
          if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
            pageY = this.containment[ 1 ] + this.offset.click.top;
          }
          if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
            pageX = this.containment[ 2 ] + this.offset.click.left;
          }
          if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
            pageY = this.containment[ 3 ] + this.offset.click.top;
          }
        }
  
        if ( o.grid ) {
          top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
            o.grid[ 1 ] ) * o.grid[ 1 ];
          pageY = this.containment ?
            ( ( top - this.offset.click.top >= this.containment[ 1 ] &&
              top - this.offset.click.top <= this.containment[ 3 ] ) ?
                top :
                ( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
                  top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
                  top;
  
          left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
            o.grid[ 0 ] ) * o.grid[ 0 ];
          pageX = this.containment ?
            ( ( left - this.offset.click.left >= this.containment[ 0 ] &&
              left - this.offset.click.left <= this.containment[ 2 ] ) ?
                left :
                ( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
                  left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
                  left;
        }
  
      }
  
      return {
        top: (
  
          // The absolute mouse position
          pageY -
  
          // Click offset (relative to the element)
          this.offset.click.top -
  
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top -
  
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top +
          ( ( this.cssPosition === "fixed" ?
            -this.scrollParent.scrollTop() :
            ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
        ),
        left: (
  
          // The absolute mouse position
          pageX -
  
          // Click offset (relative to the element)
          this.offset.click.left -
  
          // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left -
  
          // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left +
          ( ( this.cssPosition === "fixed" ?
            -this.scrollParent.scrollLeft() :
            scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
        )
      };
  
    },
  
    _rearrange: function( event, i, a, hardRefresh ) {
  
      if ( a ) {
        a[ 0 ].appendChild( this.placeholder[ 0 ] );
      } else {
        i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
          ( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );
      }
  
      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout,
      // if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;
  
      this._delay( function() {
        if ( counter === this.counter ) {
  
          //Precompute after each DOM insertion, NOT on mousemove
          this.refreshPositions( !hardRefresh );
        }
      } );
  
    },
  
    _clear: function( event, noPropagation ) {
  
      this.reverting = false;
  
      // We delay all events that have to be triggered to after the point where the placeholder
      // has been removed and everything else normalized again
      var i,
        delayedTriggers = [];
  
      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets
      // reappended (see #4088)
      if ( !this._noFinalSort && this.currentItem.parent().length ) {
        this.placeholder.before( this.currentItem );
      }
      this._noFinalSort = null;
  
      if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
        for ( i in this._storedCSS ) {
          if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
            this._storedCSS[ i ] = "";
          }
        }
        this.currentItem.css( this._storedCSS );
        this._removeClass( this.currentItem, "ui-sortable-helper" );
      } else {
        this.currentItem.show();
      }
  
      if ( this.fromOutside && !noPropagation ) {
        delayedTriggers.push( function( event ) {
          this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
        } );
      }
      if ( ( this.fromOutside ||
          this.domPosition.prev !==
          this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
          this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {
  
        // Trigger update callback if the DOM position has changed
        delayedTriggers.push( function( event ) {
          this._trigger( "update", event, this._uiHash() );
        } );
      }
  
      // Check if the items Container has Changed and trigger appropriate
      // events.
      if ( this !== this.currentContainer ) {
        if ( !noPropagation ) {
          delayedTriggers.push( function( event ) {
            this._trigger( "remove", event, this._uiHash() );
          } );
          delayedTriggers.push( ( function( c ) {
            return function( event ) {
              c._trigger( "receive", event, this._uiHash( this ) );
            };
          } ).call( this, this.currentContainer ) );
          delayedTriggers.push( ( function( c ) {
            return function( event ) {
              c._trigger( "update", event, this._uiHash( this ) );
            };
          } ).call( this, this.currentContainer ) );
        }
      }
  
      //Post events to containers
      function delayEvent( type, instance, container ) {
        return function( event ) {
          container._trigger( type, event, instance._uiHash( instance ) );
        };
      }
      for ( i = this.containers.length - 1; i >= 0; i-- ) {
        if ( !noPropagation ) {
          delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
        }
        if ( this.containers[ i ].containerCache.over ) {
          delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
          this.containers[ i ].containerCache.over = 0;
        }
      }
  
      //Do what was originally in plugins
      if ( this.storedCursor ) {
        this.document.find( "body" ).css( "cursor", this.storedCursor );
        this.storedStylesheet.remove();
      }
      if ( this._storedOpacity ) {
        this.helper.css( "opacity", this._storedOpacity );
      }
      if ( this._storedZIndex ) {
        this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
      }
  
      this.dragging = false;
  
      if ( !noPropagation ) {
        this._trigger( "beforeStop", event, this._uiHash() );
      }
  
      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
      // it unbinds ALL events from the original node!
      this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
  
      if ( !this.cancelHelperRemoval ) {
        if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
          this.helper.remove();
        }
        this.helper = null;
      }
  
      if ( !noPropagation ) {
        for ( i = 0; i < delayedTriggers.length; i++ ) {
  
          // Trigger all delayed events
          delayedTriggers[ i ].call( this, event );
        }
        this._trigger( "stop", event, this._uiHash() );
      }
  
      this.fromOutside = false;
      return !this.cancelHelperRemoval;
  
    },
  
    _trigger: function() {
      if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
        this.cancel();
      }
    },
  
    _uiHash: function( _inst ) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $( [] ),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null
      };
    }
  
  } );
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/ui/widgets/tooltip.js":
  /*!******************************************************!*\
    !*** ./node_modules/jquery-ui/ui/widgets/tooltip.js ***!
    \******************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery UI Tooltip 1.13.2
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  
  //>>label: Tooltip
  //>>group: Widgets
  //>>description: Shows additional information for any element on hover or focus.
  //>>docs: http://api.jqueryui.com/tooltip/
  //>>demos: http://jqueryui.com/tooltip/
  //>>css.structure: ../../themes/base/core.css
  //>>css.structure: ../../themes/base/tooltip.css
  //>>css.theme: ../../themes/base/theme.css
  
  ( function( factory ) {
    "use strict";
  
    if ( true ) {
  
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
        __webpack_require__(/*! ../keycode */ "./node_modules/jquery-ui/ui/keycode.js"),
        __webpack_require__(/*! ../position */ "./node_modules/jquery-ui/ui/position.js"),
        __webpack_require__(/*! ../unique-id */ "./node_modules/jquery-ui/ui/unique-id.js"),
        __webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
        __webpack_require__(/*! ../widget */ "./node_modules/jquery-ui/ui/widget.js")
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } )( function( $ ) {
  "use strict";
  
  $.widget( "ui.tooltip", {
    version: "1.13.2",
    options: {
      classes: {
        "ui-tooltip": "ui-corner-all ui-widget-shadow"
      },
      content: function() {
        var title = $( this ).attr( "title" );
  
        // Escape title, since we're going from an attribute to raw HTML
        return $( "<a>" ).text( title ).html();
      },
      hide: true,
  
      // Disabled elements have inconsistent behavior across browsers (#8661)
      items: "[title]:not([disabled])",
      position: {
        my: "left top+15",
        at: "left bottom",
        collision: "flipfit flip"
      },
      show: true,
      track: false,
  
      // Callbacks
      close: null,
      open: null
    },
  
    _addDescribedBy: function( elem, id ) {
      var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
      describedby.push( id );
      elem
        .data( "ui-tooltip-id", id )
        .attr( "aria-describedby", String.prototype.trim.call( describedby.join( " " ) ) );
    },
  
    _removeDescribedBy: function( elem ) {
      var id = elem.data( "ui-tooltip-id" ),
        describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
        index = $.inArray( id, describedby );
  
      if ( index !== -1 ) {
        describedby.splice( index, 1 );
      }
  
      elem.removeData( "ui-tooltip-id" );
      describedby = String.prototype.trim.call( describedby.join( " " ) );
      if ( describedby ) {
        elem.attr( "aria-describedby", describedby );
      } else {
        elem.removeAttr( "aria-describedby" );
      }
    },
  
    _create: function() {
      this._on( {
        mouseover: "open",
        focusin: "open"
      } );
  
      // IDs of generated tooltips, needed for destroy
      this.tooltips = {};
  
      // IDs of parent tooltips where we removed the title attribute
      this.parents = {};
  
      // Append the aria-live region so tooltips announce correctly
      this.liveRegion = $( "<div>" )
        .attr( {
          role: "log",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        } )
        .appendTo( this.document[ 0 ].body );
      this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );
  
      this.disabledTitles = $( [] );
    },
  
    _setOption: function( key, value ) {
      var that = this;
  
      this._super( key, value );
  
      if ( key === "content" ) {
        $.each( this.tooltips, function( id, tooltipData ) {
          that._updateContent( tooltipData.element );
        } );
      }
    },
  
    _setOptionDisabled: function( value ) {
      this[ value ? "_disable" : "_enable" ]();
    },
  
    _disable: function() {
      var that = this;
  
      // Close open tooltips
      $.each( this.tooltips, function( id, tooltipData ) {
        var event = $.Event( "blur" );
        event.target = event.currentTarget = tooltipData.element[ 0 ];
        that.close( event, true );
      } );
  
      // Remove title attributes to prevent native tooltips
      this.disabledTitles = this.disabledTitles.add(
        this.element.find( this.options.items ).addBack()
          .filter( function() {
            var element = $( this );
            if ( element.is( "[title]" ) ) {
              return element
                .data( "ui-tooltip-title", element.attr( "title" ) )
                .removeAttr( "title" );
            }
          } )
      );
    },
  
    _enable: function() {
  
      // restore title attributes
      this.disabledTitles.each( function() {
        var element = $( this );
        if ( element.data( "ui-tooltip-title" ) ) {
          element.attr( "title", element.data( "ui-tooltip-title" ) );
        }
      } );
      this.disabledTitles = $( [] );
    },
  
    open: function( event ) {
      var that = this,
        target = $( event ? event.target : this.element )
  
          // we need closest here due to mouseover bubbling,
          // but always pointing at the same event target
          .closest( this.options.items );
  
      // No element to show a tooltip for or the tooltip is already open
      if ( !target.length || target.data( "ui-tooltip-id" ) ) {
        return;
      }
  
      if ( target.attr( "title" ) ) {
        target.data( "ui-tooltip-title", target.attr( "title" ) );
      }
  
      target.data( "ui-tooltip-open", true );
  
      // Kill parent tooltips, custom or native, for hover
      if ( event && event.type === "mouseover" ) {
        target.parents().each( function() {
          var parent = $( this ),
            blurEvent;
          if ( parent.data( "ui-tooltip-open" ) ) {
            blurEvent = $.Event( "blur" );
            blurEvent.target = blurEvent.currentTarget = this;
            that.close( blurEvent, true );
          }
          if ( parent.attr( "title" ) ) {
            parent.uniqueId();
            that.parents[ this.id ] = {
              element: this,
              title: parent.attr( "title" )
            };
            parent.attr( "title", "" );
          }
        } );
      }
  
      this._registerCloseHandlers( event, target );
      this._updateContent( target, event );
    },
  
    _updateContent: function( target, event ) {
      var content,
        contentOption = this.options.content,
        that = this,
        eventType = event ? event.type : null;
  
      if ( typeof contentOption === "string" || contentOption.nodeType ||
          contentOption.jquery ) {
        return this._open( event, target, contentOption );
      }
  
      content = contentOption.call( target[ 0 ], function( response ) {
  
        // IE may instantly serve a cached response for ajax requests
        // delay this call to _open so the other call to _open runs first
        that._delay( function() {
  
          // Ignore async response if tooltip was closed already
          if ( !target.data( "ui-tooltip-open" ) ) {
            return;
          }
  
          // JQuery creates a special event for focusin when it doesn't
          // exist natively. To improve performance, the native event
          // object is reused and the type is changed. Therefore, we can't
          // rely on the type being correct after the event finished
          // bubbling, so we set it back to the previous value. (#8740)
          if ( event ) {
            event.type = eventType;
          }
          this._open( event, target, response );
        } );
      } );
      if ( content ) {
        this._open( event, target, content );
      }
    },
  
    _open: function( event, target, content ) {
      var tooltipData, tooltip, delayedShow, a11yContent,
        positionOption = $.extend( {}, this.options.position );
  
      if ( !content ) {
        return;
      }
  
      // Content can be updated multiple times. If the tooltip already
      // exists, then just update the content and bail.
      tooltipData = this._find( target );
      if ( tooltipData ) {
        tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
        return;
      }
  
      // If we have a title, clear it to prevent the native tooltip
      // we have to check first to avoid defining a title if none exists
      // (we don't want to cause an element to start matching [title])
      //
      // We use removeAttr only for key events, to allow IE to export the correct
      // accessible attributes. For mouse events, set to empty string to avoid
      // native tooltip showing up (happens only when removing inside mouseover).
      if ( target.is( "[title]" ) ) {
        if ( event && event.type === "mouseover" ) {
          target.attr( "title", "" );
        } else {
          target.removeAttr( "title" );
        }
      }
  
      tooltipData = this._tooltip( target );
      tooltip = tooltipData.tooltip;
      this._addDescribedBy( target, tooltip.attr( "id" ) );
      tooltip.find( ".ui-tooltip-content" ).html( content );
  
      // Support: Voiceover on OS X, JAWS on IE <= 9
      // JAWS announces deletions even when aria-relevant="additions"
      // Voiceover will sometimes re-read the entire log region's contents from the beginning
      this.liveRegion.children().hide();
      a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
      a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
      a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
      a11yContent.appendTo( this.liveRegion );
  
      function position( event ) {
        positionOption.of = event;
        if ( tooltip.is( ":hidden" ) ) {
          return;
        }
        tooltip.position( positionOption );
      }
      if ( this.options.track && event && /^mouse/.test( event.type ) ) {
        this._on( this.document, {
          mousemove: position
        } );
  
        // trigger once to override element-relative positioning
        position( event );
      } else {
        tooltip.position( $.extend( {
          of: target
        }, this.options.position ) );
      }
  
      tooltip.hide();
  
      this._show( tooltip, this.options.show );
  
      // Handle tracking tooltips that are shown with a delay (#8644). As soon
      // as the tooltip is visible, position the tooltip using the most recent
      // event.
      // Adds the check to add the timers only when both delay and track options are set (#14682)
      if ( this.options.track && this.options.show && this.options.show.delay ) {
        delayedShow = this.delayedShow = setInterval( function() {
          if ( tooltip.is( ":visible" ) ) {
            position( positionOption.of );
            clearInterval( delayedShow );
          }
        }, 13 );
      }
  
      this._trigger( "open", event, { tooltip: tooltip } );
    },
  
    _registerCloseHandlers: function( event, target ) {
      var events = {
        keyup: function( event ) {
          if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
            var fakeEvent = $.Event( event );
            fakeEvent.currentTarget = target[ 0 ];
            this.close( fakeEvent, true );
          }
        }
      };
  
      // Only bind remove handler for delegated targets. Non-delegated
      // tooltips will handle this in destroy.
      if ( target[ 0 ] !== this.element[ 0 ] ) {
        events.remove = function() {
          var targetElement = this._find( target );
          if ( targetElement ) {
            this._removeTooltip( targetElement.tooltip );
          }
        };
      }
  
      if ( !event || event.type === "mouseover" ) {
        events.mouseleave = "close";
      }
      if ( !event || event.type === "focusin" ) {
        events.focusout = "close";
      }
      this._on( true, target, events );
    },
  
    close: function( event ) {
      var tooltip,
        that = this,
        target = $( event ? event.currentTarget : this.element ),
        tooltipData = this._find( target );
  
      // The tooltip may already be closed
      if ( !tooltipData ) {
  
        // We set ui-tooltip-open immediately upon open (in open()), but only set the
        // additional data once there's actually content to show (in _open()). So even if the
        // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
        // the period between open() and _open().
        target.removeData( "ui-tooltip-open" );
        return;
      }
  
      tooltip = tooltipData.tooltip;
  
      // Disabling closes the tooltip, so we need to track when we're closing
      // to avoid an infinite loop in case the tooltip becomes disabled on close
      if ( tooltipData.closing ) {
        return;
      }
  
      // Clear the interval for delayed tracking tooltips
      clearInterval( this.delayedShow );
  
      // Only set title if we had one before (see comment in _open())
      // If the title attribute has changed since open(), don't restore
      if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
        target.attr( "title", target.data( "ui-tooltip-title" ) );
      }
  
      this._removeDescribedBy( target );
  
      tooltipData.hiding = true;
      tooltip.stop( true );
      this._hide( tooltip, this.options.hide, function() {
        that._removeTooltip( $( this ) );
      } );
  
      target.removeData( "ui-tooltip-open" );
      this._off( target, "mouseleave focusout keyup" );
  
      // Remove 'remove' binding only on delegated targets
      if ( target[ 0 ] !== this.element[ 0 ] ) {
        this._off( target, "remove" );
      }
      this._off( this.document, "mousemove" );
  
      if ( event && event.type === "mouseleave" ) {
        $.each( this.parents, function( id, parent ) {
          $( parent.element ).attr( "title", parent.title );
          delete that.parents[ id ];
        } );
      }
  
      tooltipData.closing = true;
      this._trigger( "close", event, { tooltip: tooltip } );
      if ( !tooltipData.hiding ) {
        tooltipData.closing = false;
      }
    },
  
    _tooltip: function( element ) {
      var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
        content = $( "<div>" ).appendTo( tooltip ),
        id = tooltip.uniqueId().attr( "id" );
  
      this._addClass( content, "ui-tooltip-content" );
      this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );
  
      tooltip.appendTo( this._appendTo( element ) );
  
      return this.tooltips[ id ] = {
        element: element,
        tooltip: tooltip
      };
    },
  
    _find: function( target ) {
      var id = target.data( "ui-tooltip-id" );
      return id ? this.tooltips[ id ] : null;
    },
  
    _removeTooltip: function( tooltip ) {
  
      // Clear the interval for delayed tracking tooltips
      clearInterval( this.delayedShow );
  
      tooltip.remove();
      delete this.tooltips[ tooltip.attr( "id" ) ];
    },
  
    _appendTo: function( target ) {
      var element = target.closest( ".ui-front, dialog" );
  
      if ( !element.length ) {
        element = this.document[ 0 ].body;
      }
  
      return element;
    },
  
    _destroy: function() {
      var that = this;
  
      // Close open tooltips
      $.each( this.tooltips, function( id, tooltipData ) {
  
        // Delegate to close method to handle common cleanup
        var event = $.Event( "blur" ),
          element = tooltipData.element;
        event.target = event.currentTarget = element[ 0 ];
        that.close( event, true );
  
        // Remove immediately; destroying an open tooltip doesn't use the
        // hide animation
        $( "#" + id ).remove();
  
        // Restore the title
        if ( element.data( "ui-tooltip-title" ) ) {
  
          // If the title attribute has changed since open(), don't restore
          if ( !element.attr( "title" ) ) {
            element.attr( "title", element.data( "ui-tooltip-title" ) );
          }
          element.removeData( "ui-tooltip-title" );
        }
      } );
      this.liveRegion.remove();
    }
  } );
  
  // DEPRECATED
  // TODO: Switch return back to widget declaration at top of file when this is removed
  if ( $.uiBackCompat !== false ) {
  
    // Backcompat for tooltipClass option
    $.widget( "ui.tooltip", $.ui.tooltip, {
      options: {
        tooltipClass: null
      },
      _tooltip: function() {
        var tooltipData = this._superApply( arguments );
        if ( this.options.tooltipClass ) {
          tooltipData.tooltip.addClass( this.options.tooltipClass );
        }
        return tooltipData;
      }
    } );
  }
  
  return $.ui.tooltip;
  
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery/dist/jquery.js":
  /*!********************************************!*\
    !*** ./node_modules/jquery/dist/jquery.js ***!
    \********************************************/
  /***/ (function(module, exports) {
  
  var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * jQuery JavaScript Library v3.6.3
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2022-12-20T21:28Z
   */
  ( function( global, factory ) {
  
    "use strict";
  
    if (  true && typeof module.exports === "object" ) {
  
      // For CommonJS and CommonJS-like environments where a proper `window`
      // is present, execute the factory and get jQuery.
      // For environments that do not have a `window` with a `document`
      // (such as Node.js), expose a factory as module.exports.
      // This accentuates the need for the creation of a real `window`.
      // e.g. var jQuery = require("jquery")(window);
      // See ticket trac-14549 for more info.
      module.exports = global.document ?
        factory( global, true ) :
        function( w ) {
          if ( !w.document ) {
            throw new Error( "jQuery requires a window with a document" );
          }
          return factory( w );
        };
    } else {
      factory( global );
    }
  
  // Pass this if window is not defined yet
  } )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
  
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";
  
  var arr = [];
  
  var getProto = Object.getPrototypeOf;
  
  var slice = arr.slice;
  
  var flat = arr.flat ? function( array ) {
    return arr.flat.call( array );
  } : function( array ) {
    return arr.concat.apply( [], array );
  };
  
  
  var push = arr.push;
  
  var indexOf = arr.indexOf;
  
  var class2type = {};
  
  var toString = class2type.toString;
  
  var hasOwn = class2type.hasOwnProperty;
  
  var fnToString = hasOwn.toString;
  
  var ObjectFunctionString = fnToString.call( Object );
  
  var support = {};
  
  var isFunction = function isFunction( obj ) {
  
      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
      // Plus for old WebKit, typeof returns "function" for HTML collections
      // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
      return typeof obj === "function" && typeof obj.nodeType !== "number" &&
        typeof obj.item !== "function";
    };
  
  
  var isWindow = function isWindow( obj ) {
      return obj != null && obj === obj.window;
    };
  
  
  var document = window.document;
  
  
  
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
  
    function DOMEval( code, node, doc ) {
      doc = doc || document;
  
      var i, val,
        script = doc.createElement( "script" );
  
      script.text = code;
      if ( node ) {
        for ( i in preservedScriptAttributes ) {
  
          // Support: Firefox 64+, Edge 18+
          // Some browsers don't support the "nonce" property on scripts.
          // On the other hand, just using `getAttribute` is not enough as
          // the `nonce` attribute is reset to an empty string whenever it
          // becomes browsing-context connected.
          // See https://github.com/whatwg/html/issues/2369
          // See https://html.spec.whatwg.org/#nonce-attributes
          // The `node.getAttribute` check was added for the sake of
          // `jQuery.globalEval` so that it can fake a nonce-containing node
          // via an object.
          val = node[ i ] || node.getAttribute && node.getAttribute( i );
          if ( val ) {
            script.setAttribute( i, val );
          }
        }
      }
      doc.head.appendChild( script ).parentNode.removeChild( script );
    }
  
  
  function toType( obj ) {
    if ( obj == null ) {
      return obj + "";
    }
  
    // Support: Android <=2.3 only (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
      class2type[ toString.call( obj ) ] || "object" :
      typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module
  
  
  
  var
    version = "3.6.3",
  
    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
  
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init( selector, context );
    };
  
  jQuery.fn = jQuery.prototype = {
  
    // The current version of jQuery being used
    jquery: version,
  
    constructor: jQuery,
  
    // The default length of a jQuery object is 0
    length: 0,
  
    toArray: function() {
      return slice.call( this );
    },
  
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
  
      // Return all the elements in a clean array
      if ( num == null ) {
        return slice.call( this );
      }
  
      // Return just the one element from the set
      return num < 0 ? this[ num + this.length ] : this[ num ];
    },
  
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems ) {
  
      // Build a new jQuery matched element set
      var ret = jQuery.merge( this.constructor(), elems );
  
      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;
  
      // Return the newly-formed element set
      return ret;
    },
  
    // Execute a callback for every element in the matched set.
    each: function( callback ) {
      return jQuery.each( this, callback );
    },
  
    map: function( callback ) {
      return this.pushStack( jQuery.map( this, function( elem, i ) {
        return callback.call( elem, i, elem );
      } ) );
    },
  
    slice: function() {
      return this.pushStack( slice.apply( this, arguments ) );
    },
  
    first: function() {
      return this.eq( 0 );
    },
  
    last: function() {
      return this.eq( -1 );
    },
  
    even: function() {
      return this.pushStack( jQuery.grep( this, function( _elem, i ) {
        return ( i + 1 ) % 2;
      } ) );
    },
  
    odd: function() {
      return this.pushStack( jQuery.grep( this, function( _elem, i ) {
        return i % 2;
      } ) );
    },
  
    eq: function( i ) {
      var len = this.length,
        j = +i + ( i < 0 ? len : 0 );
      return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
    },
  
    end: function() {
      return this.prevObject || this.constructor();
    },
  
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  
  jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[ 0 ] || {},
      i = 1,
      length = arguments.length,
      deep = false;
  
    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
      deep = target;
  
      // Skip the boolean and the target
      target = arguments[ i ] || {};
      i++;
    }
  
    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !isFunction( target ) ) {
      target = {};
    }
  
    // Extend jQuery itself if only one argument is passed
    if ( i === length ) {
      target = this;
      i--;
    }
  
    for ( ; i < length; i++ ) {
  
      // Only deal with non-null/undefined values
      if ( ( options = arguments[ i ] ) != null ) {
  
        // Extend the base object
        for ( name in options ) {
          copy = options[ name ];
  
          // Prevent Object.prototype pollution
          // Prevent never-ending loop
          if ( name === "__proto__" || target === copy ) {
            continue;
          }
  
          // Recurse if we're merging plain objects or arrays
          if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
            ( copyIsArray = Array.isArray( copy ) ) ) ) {
            src = target[ name ];
  
            // Ensure proper type for the source value
            if ( copyIsArray && !Array.isArray( src ) ) {
              clone = [];
            } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
              clone = {};
            } else {
              clone = src;
            }
            copyIsArray = false;
  
            // Never move original objects, clone them
            target[ name ] = jQuery.extend( deep, clone, copy );
  
          // Don't bring in undefined values
          } else if ( copy !== undefined ) {
            target[ name ] = copy;
          }
        }
      }
    }
  
    // Return the modified object
    return target;
  };
  
  jQuery.extend( {
  
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
  
    // Assume jQuery is ready without the ready module
    isReady: true,
  
    error: function( msg ) {
      throw new Error( msg );
    },
  
    noop: function() {},
  
    isPlainObject: function( obj ) {
      var proto, Ctor;
  
      // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects
      if ( !obj || toString.call( obj ) !== "[object Object]" ) {
        return false;
      }
  
      proto = getProto( obj );
  
      // Objects with no prototype (e.g., `Object.create( null )`) are plain
      if ( !proto ) {
        return true;
      }
  
      // Objects with prototype are plain iff they were constructed by a global Object function
      Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
      return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
    },
  
    isEmptyObject: function( obj ) {
      var name;
  
      for ( name in obj ) {
        return false;
      }
      return true;
    },
  
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function( code, options, doc ) {
      DOMEval( code, { nonce: options && options.nonce }, doc );
    },
  
    each: function( obj, callback ) {
      var length, i = 0;
  
      if ( isArrayLike( obj ) ) {
        length = obj.length;
        for ( ; i < length; i++ ) {
          if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
            break;
          }
        }
      } else {
        for ( i in obj ) {
          if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
            break;
          }
        }
      }
  
      return obj;
    },
  
    // results is for internal usage only
    makeArray: function( arr, results ) {
      var ret = results || [];
  
      if ( arr != null ) {
        if ( isArrayLike( Object( arr ) ) ) {
          jQuery.merge( ret,
            typeof arr === "string" ?
              [ arr ] : arr
          );
        } else {
          push.call( ret, arr );
        }
      }
  
      return ret;
    },
  
    inArray: function( elem, arr, i ) {
      return arr == null ? -1 : indexOf.call( arr, elem, i );
    },
  
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function( first, second ) {
      var len = +second.length,
        j = 0,
        i = first.length;
  
      for ( ; j < len; j++ ) {
        first[ i++ ] = second[ j ];
      }
  
      first.length = i;
  
      return first;
    },
  
    grep: function( elems, callback, invert ) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;
  
      // Go through the array, only saving the items
      // that pass the validator function
      for ( ; i < length; i++ ) {
        callbackInverse = !callback( elems[ i ], i );
        if ( callbackInverse !== callbackExpect ) {
          matches.push( elems[ i ] );
        }
      }
  
      return matches;
    },
  
    // arg is for internal usage only
    map: function( elems, callback, arg ) {
      var length, value,
        i = 0,
        ret = [];
  
      // Go through the array, translating each of the items to their new values
      if ( isArrayLike( elems ) ) {
        length = elems.length;
        for ( ; i < length; i++ ) {
          value = callback( elems[ i ], i, arg );
  
          if ( value != null ) {
            ret.push( value );
          }
        }
  
      // Go through every key on the object,
      } else {
        for ( i in elems ) {
          value = callback( elems[ i ], i, arg );
  
          if ( value != null ) {
            ret.push( value );
          }
        }
      }
  
      // Flatten any nested arrays
      return flat( ret );
    },
  
    // A global GUID counter for objects
    guid: 1,
  
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  } );
  
  if ( typeof Symbol === "function" ) {
    jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  }
  
  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
    function( _i, name ) {
      class2type[ "[object " + name + "]" ] = name.toLowerCase();
    } );
  
  function isArrayLike( obj ) {
  
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
      type = toType( obj );
  
    if ( isFunction( obj ) || isWindow( obj ) ) {
      return false;
    }
  
    return type === "array" || length === 0 ||
      typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.9
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2022-12-19
   */
  ( function( window ) {
  var i,
    support,
    Expr,
    getText,
    isXML,
    tokenize,
    compile,
    select,
    outermostContext,
    sortInput,
    hasDuplicate,
  
    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,
  
    // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    nonnativeSelectorCache = createCache(),
    sortOrder = function( a, b ) {
      if ( a === b ) {
        hasDuplicate = true;
      }
      return 0;
    },
  
    // Instance methods
    hasOwn = ( {} ).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    pushNative = arr.push,
    push = arr.push,
    slice = arr.slice,
  
    // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function( list, elem ) {
      var i = 0,
        len = list.length;
      for ( ; i < len; i++ ) {
        if ( list[ i ] === elem ) {
          return i;
        }
      }
      return -1;
    },
  
    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
      "ismap|loop|multiple|open|readonly|required|scoped",
  
    // Regular expressions
  
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
  
    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
      "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
  
    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
  
      // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace +
  
      // "Attribute values must be CSS identifiers [capture 5]
      // or strings [capture 3 or capture 4]"
      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
      whitespace + "*\\]",
  
    pseudos = ":(" + identifier + ")(?:\\((" +
  
      // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
  
      // 2. simple (capture 6)
      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
  
      // 3. anything else (capture 2)
      ".*" +
      ")\\)|)",
  
    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp( whitespace + "+", "g" ),
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
      whitespace + "+$", "g" ),
  
    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
      "*" ),
    rdescend = new RegExp( whitespace + "|>" ),
  
    rpseudo = new RegExp( pseudos ),
    ridentifier = new RegExp( "^" + identifier + "$" ),
  
    matchExpr = {
      "ID": new RegExp( "^#(" + identifier + ")" ),
      "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
      "TAG": new RegExp( "^(" + identifier + "|[*])" ),
      "ATTR": new RegExp( "^" + attributes ),
      "PSEUDO": new RegExp( "^" + pseudos ),
      "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
        whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
        whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
      "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
  
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp( "^" + whitespace +
        "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
        "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    },
  
    rhtml = /HTML$/i,
    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,
  
    rnative = /^[^{]+\{\s*\[native \w/,
  
    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
  
    rsibling = /[+~]/,
  
    // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
    funescape = function( escape, nonHex ) {
      var high = "0x" + escape.slice( 1 ) - 0x10000;
  
      return nonHex ?
  
        // Strip the backslash prefix from a non-hex escape sequence
        nonHex :
  
        // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        high < 0 ?
          String.fromCharCode( high + 0x10000 ) :
          String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    },
  
    // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
    fcssescape = function( ch, asCodePoint ) {
      if ( asCodePoint ) {
  
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if ( ch === "\0" ) {
          return "\uFFFD";
        }
  
        // Control characters and (dependent upon position) numbers get escaped as code points
        return ch.slice( 0, -1 ) + "\\" +
          ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
      }
  
      // Other potentially-special ASCII characters get backslash-escaped
      return "\\" + ch;
    },
  
    // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function() {
      setDocument();
    },
  
    inDisabledFieldset = addCombinator(
      function( elem ) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
      },
      { dir: "parentNode", next: "legend" }
    );
  
  // Optimize for push.apply( _, NodeList )
  try {
    push.apply(
      ( arr = slice.call( preferredDoc.childNodes ) ),
      preferredDoc.childNodes
    );
  
    // Support: Android<4.0
    // Detect silently failing push.apply
    // eslint-disable-next-line no-unused-expressions
    arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
    push = { apply: arr.length ?
  
      // Leverage slice if possible
      function( target, els ) {
        pushNative.apply( target, slice.call( els ) );
      } :
  
      // Support: IE<9
      // Otherwise append directly
      function( target, els ) {
        var j = target.length,
          i = 0;
  
        // Can't trust NodeList.length
        while ( ( target[ j++ ] = els[ i++ ] ) ) {}
        target.length = j - 1;
      }
    };
  }
  
  function Sizzle( selector, context, results, seed ) {
    var m, i, elem, nid, match, groups, newSelector,
      newContext = context && context.ownerDocument,
  
      // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
  
    results = results || [];
  
    // Return early from calls with invalid selector or context
    if ( typeof selector !== "string" || !selector ||
      nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
  
      return results;
    }
  
    // Try to shortcut find operations (as opposed to filters) in HTML documents
    if ( !seed ) {
      setDocument( context );
      context = context || document;
  
      if ( documentIsHTML ) {
  
        // If the selector is sufficiently simple, try using a "get*By*" DOM method
        // (excepting DocumentFragment context, where the methods don't exist)
        if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {
  
          // ID selector
          if ( ( m = match[ 1 ] ) ) {
  
            // Document context
            if ( nodeType === 9 ) {
              if ( ( elem = context.getElementById( m ) ) ) {
  
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if ( elem.id === m ) {
                  results.push( elem );
                  return results;
                }
              } else {
                return results;
              }
  
            // Element context
            } else {
  
              // Support: IE, Opera, Webkit
              // TODO: identify versions
              // getElementById can match elements by name instead of ID
              if ( newContext && ( elem = newContext.getElementById( m ) ) &&
                contains( context, elem ) &&
                elem.id === m ) {
  
                results.push( elem );
                return results;
              }
            }
  
          // Type selector
          } else if ( match[ 2 ] ) {
            push.apply( results, context.getElementsByTagName( selector ) );
            return results;
  
          // Class selector
          } else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
            context.getElementsByClassName ) {
  
            push.apply( results, context.getElementsByClassName( m ) );
            return results;
          }
        }
  
        // Take advantage of querySelectorAll
        if ( support.qsa &&
          !nonnativeSelectorCache[ selector + " " ] &&
          ( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&
  
          // Support: IE 8 only
          // Exclude object elements
          ( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {
  
          newSelector = selector;
          newContext = context;
  
          // qSA considers elements outside a scoping root when evaluating child or
          // descendant combinators, which is not what we want.
          // In such cases, we work around the behavior by prefixing every selector in the
          // list with an ID selector referencing the scope context.
          // The technique has to be used as well when a leading combinator is used
          // as such selectors are not recognized by querySelectorAll.
          // Thanks to Andrew Dupont for this technique.
          if ( nodeType === 1 &&
            ( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {
  
            // Expand context for sibling selectors
            newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
              context;
  
            // We can use :scope instead of the ID hack if the browser
            // supports it & if we're not changing the context.
            if ( newContext !== context || !support.scope ) {
  
              // Capture the context ID, setting it first if necessary
              if ( ( nid = context.getAttribute( "id" ) ) ) {
                nid = nid.replace( rcssescape, fcssescape );
              } else {
                context.setAttribute( "id", ( nid = expando ) );
              }
            }
  
            // Prefix every selector in the list
            groups = tokenize( selector );
            i = groups.length;
            while ( i-- ) {
              groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
                toSelector( groups[ i ] );
            }
            newSelector = groups.join( "," );
          }
  
          try {
  
            // `qSA` may not throw for unrecognized parts using forgiving parsing:
            // https://drafts.csswg.org/selectors/#forgiving-selector
            // like the `:has()` pseudo-class:
            // https://drafts.csswg.org/selectors/#relational
            // `CSS.supports` is still expected to return `false` then:
            // https://drafts.csswg.org/css-conditional-4/#typedef-supports-selector-fn
            // https://drafts.csswg.org/css-conditional-4/#dfn-support-selector
            if ( support.cssSupportsSelector &&
  
              // eslint-disable-next-line no-undef
              !CSS.supports( "selector(:is(" + newSelector + "))" ) ) {
  
              // Support: IE 11+
              // Throw to get to the same code path as an error directly in qSA.
              // Note: once we only support browser supporting
              // `CSS.supports('selector(...)')`, we can most likely drop
              // the `try-catch`. IE doesn't implement the API.
              throw new Error();
            }
  
            push.apply( results,
              newContext.querySelectorAll( newSelector )
            );
            return results;
          } catch ( qsaError ) {
            nonnativeSelectorCache( selector, true );
          } finally {
            if ( nid === expando ) {
              context.removeAttribute( "id" );
            }
          }
        }
      }
    }
  
    // All others
    return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }
  
  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
    var keys = [];
  
    function cache( key, value ) {
  
      // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
      if ( keys.push( key + " " ) > Expr.cacheLength ) {
  
        // Only keep the most recent entries
        delete cache[ keys.shift() ];
      }
      return ( cache[ key + " " ] = value );
    }
    return cache;
  }
  
  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
    fn[ expando ] = true;
    return fn;
  }
  
  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert( fn ) {
    var el = document.createElement( "fieldset" );
  
    try {
      return !!fn( el );
    } catch ( e ) {
      return false;
    } finally {
  
      // Remove from its parent by default
      if ( el.parentNode ) {
        el.parentNode.removeChild( el );
      }
  
      // release memory in IE
      el = null;
    }
  }
  
  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
    var arr = attrs.split( "|" ),
      i = arr.length;
  
    while ( i-- ) {
      Expr.attrHandle[ arr[ i ] ] = handler;
    }
  }
  
  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
    var cur = b && a,
      diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
        a.sourceIndex - b.sourceIndex;
  
    // Use IE sourceIndex if available on both nodes
    if ( diff ) {
      return diff;
    }
  
    // Check if b follows a
    if ( cur ) {
      while ( ( cur = cur.nextSibling ) ) {
        if ( cur === b ) {
          return -1;
        }
      }
    }
  
    return a ? 1 : -1;
  }
  
  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
    return function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  }
  
  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
    return function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return ( name === "input" || name === "button" ) && elem.type === type;
    };
  }
  
  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo( disabled ) {
  
    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
    return function( elem ) {
  
      // Only certain elements can match :enabled or :disabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
      if ( "form" in elem ) {
  
        // Check for inherited disabledness on relevant non-disabled elements:
        // * listed form-associated elements in a disabled fieldset
        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
        // * option elements in a disabled optgroup
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
        // All such elements have a "form" property.
        if ( elem.parentNode && elem.disabled === false ) {
  
          // Option elements defer to a parent optgroup if present
          if ( "label" in elem ) {
            if ( "label" in elem.parentNode ) {
              return elem.parentNode.disabled === disabled;
            } else {
              return elem.disabled === disabled;
            }
          }
  
          // Support: IE 6 - 11
          // Use the isDisabled shortcut property to check for disabled fieldset ancestors
          return elem.isDisabled === disabled ||
  
            // Where there is no isDisabled, check manually
            /* jshint -W018 */
            elem.isDisabled !== !disabled &&
            inDisabledFieldset( elem ) === disabled;
        }
  
        return elem.disabled === disabled;
  
      // Try to winnow out elements that can't be disabled before trusting the disabled property.
      // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
      // even exist on them, let alone have a boolean value.
      } else if ( "label" in elem ) {
        return elem.disabled === disabled;
      }
  
      // Remaining elements are neither :enabled nor :disabled
      return false;
    };
  }
  
  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
    return markFunction( function( argument ) {
      argument = +argument;
      return markFunction( function( seed, matches ) {
        var j,
          matchIndexes = fn( [], seed.length, argument ),
          i = matchIndexes.length;
  
        // Match elements found at the specified indexes
        while ( i-- ) {
          if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
            seed[ j ] = !( matches[ j ] = seed[ j ] );
          }
        }
      } );
    } );
  }
  
  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
    return context && typeof context.getElementsByTagName !== "undefined" && context;
  }
  
  // Expose support vars for convenience
  support = Sizzle.support = {};
  
  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
    var namespace = elem && elem.namespaceURI,
      docElem = elem && ( elem.ownerDocument || elem ).documentElement;
  
    // Support: IE <=8
    // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
    // https://bugs.jquery.com/ticket/4833
    return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
  };
  
  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
    var hasCompare, subWindow,
      doc = node ? node.ownerDocument || node : preferredDoc;
  
    // Return early if doc is invalid or already selected
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
      return document;
    }
  
    // Update global variables
    document = doc;
    docElem = document.documentElement;
    documentIsHTML = !isXML( document );
  
    // Support: IE 9 - 11+, Edge 12 - 18+
    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    if ( preferredDoc != document &&
      ( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {
  
      // Support: IE 11, Edge
      if ( subWindow.addEventListener ) {
        subWindow.addEventListener( "unload", unloadHandler, false );
  
      // Support: IE 9 - 10 only
      } else if ( subWindow.attachEvent ) {
        subWindow.attachEvent( "onunload", unloadHandler );
      }
    }
  
    // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
    // Safari 4 - 5 only, Opera <=11.6 - 12.x only
    // IE/Edge & older browsers don't support the :scope pseudo-class.
    // Support: Safari 6.0 only
    // Safari 6.0 supports :scope but it's an alias of :root there.
    support.scope = assert( function( el ) {
      docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
      return typeof el.querySelectorAll !== "undefined" &&
        !el.querySelectorAll( ":scope fieldset div" ).length;
    } );
  
    // Support: Chrome 105+, Firefox 104+, Safari 15.4+
    // Make sure forgiving mode is not used in `CSS.supports( "selector(...)" )`.
    //
    // `:is()` uses a forgiving selector list as an argument and is widely
    // implemented, so it's a good one to test against.
    support.cssSupportsSelector = assert( function() {
      /* eslint-disable no-undef */
  
      return CSS.supports( "selector(*)" ) &&
  
        // Support: Firefox 78-81 only
        // In old Firefox, `:is()` didn't use forgiving parsing. In that case,
        // fail this test as there's no selector to test against that.
        // `CSS.supports` uses unforgiving parsing
        document.querySelectorAll( ":is(:jqfake)" ) &&
  
        // `*` is needed as Safari & newer Chrome implemented something in between
        // for `:has()` - it throws in `qSA` if it only contains an unsupported
        // argument but multiple ones, one of which is supported, are fine.
        // We want to play safe in case `:is()` gets the same treatment.
        !CSS.supports( "selector(:is(*,:jqfake))" );
  
      /* eslint-enable */
    } );
  
    /* Attributes
    ---------------------------------------------------------------------- */
  
    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties
    // (excepting IE8 booleans)
    support.attributes = assert( function( el ) {
      el.className = "i";
      return !el.getAttribute( "className" );
    } );
  
    /* getElement(s)By*
    ---------------------------------------------------------------------- */
  
    // Check if getElementsByTagName("*") returns only elements
    support.getElementsByTagName = assert( function( el ) {
      el.appendChild( document.createComment( "" ) );
      return !el.getElementsByTagName( "*" ).length;
    } );
  
    // Support: IE<9
    support.getElementsByClassName = rnative.test( document.getElementsByClassName );
  
    // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programmatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert( function( el ) {
      docElem.appendChild( el ).id = expando;
      return !document.getElementsByName || !document.getElementsByName( expando ).length;
    } );
  
    // ID filter and find
    if ( support.getById ) {
      Expr.filter[ "ID" ] = function( id ) {
        var attrId = id.replace( runescape, funescape );
        return function( elem ) {
          return elem.getAttribute( "id" ) === attrId;
        };
      };
      Expr.find[ "ID" ] = function( id, context ) {
        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
          var elem = context.getElementById( id );
          return elem ? [ elem ] : [];
        }
      };
    } else {
      Expr.filter[ "ID" ] =  function( id ) {
        var attrId = id.replace( runescape, funescape );
        return function( elem ) {
          var node = typeof elem.getAttributeNode !== "undefined" &&
            elem.getAttributeNode( "id" );
          return node && node.value === attrId;
        };
      };
  
      // Support: IE 6 - 7 only
      // getElementById is not reliable as a find shortcut
      Expr.find[ "ID" ] = function( id, context ) {
        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
          var node, i, elems,
            elem = context.getElementById( id );
  
          if ( elem ) {
  
            // Verify the id attribute
            node = elem.getAttributeNode( "id" );
            if ( node && node.value === id ) {
              return [ elem ];
            }
  
            // Fall back on getElementsByName
            elems = context.getElementsByName( id );
            i = 0;
            while ( ( elem = elems[ i++ ] ) ) {
              node = elem.getAttributeNode( "id" );
              if ( node && node.value === id ) {
                return [ elem ];
              }
            }
          }
  
          return [];
        }
      };
    }
  
    // Tag
    Expr.find[ "TAG" ] = support.getElementsByTagName ?
      function( tag, context ) {
        if ( typeof context.getElementsByTagName !== "undefined" ) {
          return context.getElementsByTagName( tag );
  
        // DocumentFragment nodes don't have gEBTN
        } else if ( support.qsa ) {
          return context.querySelectorAll( tag );
        }
      } :
  
      function( tag, context ) {
        var elem,
          tmp = [],
          i = 0,
  
          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName( tag );
  
        // Filter out possible comments
        if ( tag === "*" ) {
          while ( ( elem = results[ i++ ] ) ) {
            if ( elem.nodeType === 1 ) {
              tmp.push( elem );
            }
          }
  
          return tmp;
        }
        return results;
      };
  
    // Class
    Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
      if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
        return context.getElementsByClassName( className );
      }
    };
  
    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */
  
    // QSA and matchesSelector support
  
    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];
  
    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See https://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];
  
    if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {
  
      // Build QSA regex
      // Regex strategy adopted from Diego Perini
      assert( function( el ) {
  
        var input;
  
        // Select is set to empty string on purpose
        // This is to test IE's treatment of not explicitly
        // setting a boolean content attribute,
        // since its presence should be enough
        // https://bugs.jquery.com/ticket/12359
        docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
          "<select id='" + expando + "-\r\\' msallowcapture=''>" +
          "<option selected=''></option></select>";
  
        // Support: IE8, Opera 11-12.16
        // Nothing should be selected when empty strings follow ^= or $= or *=
        // The test attribute must be unknown in Opera but "safe" for WinRT
        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
        if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
          rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
        }
  
        // Support: IE8
        // Boolean attributes and "value" are not treated correctly
        if ( !el.querySelectorAll( "[selected]" ).length ) {
          rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
        }
  
        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
        if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
          rbuggyQSA.push( "~=" );
        }
  
        // Support: IE 11+, Edge 15 - 18+
        // IE 11/Edge don't find elements on a `[name='']` query in some cases.
        // Adding a temporary attribute to the document before the selection works
        // around the issue.
        // Interestingly, IE 10 & older don't seem to have the issue.
        input = document.createElement( "input" );
        input.setAttribute( "name", "" );
        el.appendChild( input );
        if ( !el.querySelectorAll( "[name='']" ).length ) {
          rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
            whitespace + "*(?:''|\"\")" );
        }
  
        // Webkit/Opera - :checked should return selected option elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        // IE8 throws error here and will not see later tests
        if ( !el.querySelectorAll( ":checked" ).length ) {
          rbuggyQSA.push( ":checked" );
        }
  
        // Support: Safari 8+, iOS 8+
        // https://bugs.webkit.org/show_bug.cgi?id=136851
        // In-page `selector#id sibling-combinator selector` fails
        if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
          rbuggyQSA.push( ".#.+[+~]" );
        }
  
        // Support: Firefox <=3.6 - 5 only
        // Old Firefox doesn't throw on a badly-escaped identifier.
        el.querySelectorAll( "\\\f" );
        rbuggyQSA.push( "[\\r\\n\\f]" );
      } );
  
      assert( function( el ) {
        el.innerHTML = "<a href='' disabled='disabled'></a>" +
          "<select disabled='disabled'><option/></select>";
  
        // Support: Windows 8 Native Apps
        // The type and name attributes are restricted during .innerHTML assignment
        var input = document.createElement( "input" );
        input.setAttribute( "type", "hidden" );
        el.appendChild( input ).setAttribute( "name", "D" );
  
        // Support: IE8
        // Enforce case-sensitivity of name attribute
        if ( el.querySelectorAll( "[name=d]" ).length ) {
          rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
        }
  
        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
        // IE8 throws error here and will not see later tests
        if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
          rbuggyQSA.push( ":enabled", ":disabled" );
        }
  
        // Support: IE9-11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets
        docElem.appendChild( el ).disabled = true;
        if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
          rbuggyQSA.push( ":enabled", ":disabled" );
        }
  
        // Support: Opera 10 - 11 only
        // Opera 10-11 does not throw on post-comma invalid pseudos
        el.querySelectorAll( "*,:x" );
        rbuggyQSA.push( ",.*:" );
      } );
    }
  
    if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
      docElem.webkitMatchesSelector ||
      docElem.mozMatchesSelector ||
      docElem.oMatchesSelector ||
      docElem.msMatchesSelector ) ) ) ) {
  
      assert( function( el ) {
  
        // Check to see if it's possible to do matchesSelector
        // on a disconnected node (IE 9)
        support.disconnectedMatch = matches.call( el, "*" );
  
        // This should fail with an exception
        // Gecko does not error, returns false instead
        matches.call( el, "[s!='']:x" );
        rbuggyMatches.push( "!=", pseudos );
      } );
    }
  
    if ( !support.cssSupportsSelector ) {
  
      // Support: Chrome 105+, Safari 15.4+
      // `:has()` uses a forgiving selector list as an argument so our regular
      // `try-catch` mechanism fails to catch `:has()` with arguments not supported
      // natively like `:has(:contains("Foo"))`. Where supported & spec-compliant,
      // we now use `CSS.supports("selector(:is(SELECTOR_TO_BE_TESTED))")`, but
      // outside that we mark `:has` as buggy.
      rbuggyQSA.push( ":has" );
    }
  
    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );
  
    /* Contains
    ---------------------------------------------------------------------- */
    hasCompare = rnative.test( docElem.compareDocumentPosition );
  
    // Element contains another
    // Purposefully self-exclusive
    // As in, an element does not contain itself
    contains = hasCompare || rnative.test( docElem.contains ) ?
      function( a, b ) {
  
        // Support: IE <9 only
        // IE doesn't have `contains` on `document` so we need to check for
        // `documentElement` presence.
        // We need to fall back to `a` when `documentElement` is missing
        // as `ownerDocument` of elements within `<template/>` may have
        // a null one - a default behavior of all modern browsers.
        var adown = a.nodeType === 9 && a.documentElement || a,
          bup = b && b.parentNode;
        return a === bup || !!( bup && bup.nodeType === 1 && (
          adown.contains ?
            adown.contains( bup ) :
            a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
        ) );
      } :
      function( a, b ) {
        if ( b ) {
          while ( ( b = b.parentNode ) ) {
            if ( b === a ) {
              return true;
            }
          }
        }
        return false;
      };
  
    /* Sorting
    ---------------------------------------------------------------------- */
  
    // Document order sorting
    sortOrder = hasCompare ?
    function( a, b ) {
  
      // Flag for duplicate removal
      if ( a === b ) {
        hasDuplicate = true;
        return 0;
      }
  
      // Sort on method existence if only one input has compareDocumentPosition
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if ( compare ) {
        return compare;
      }
  
      // Calculate position if both inputs belong to the same document
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
        a.compareDocumentPosition( b ) :
  
        // Otherwise we know they are disconnected
        1;
  
      // Disconnected nodes
      if ( compare & 1 ||
        ( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {
  
        // Choose the first element that is related to our preferred document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( a == document || a.ownerDocument == preferredDoc &&
          contains( preferredDoc, a ) ) {
          return -1;
        }
  
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( b == document || b.ownerDocument == preferredDoc &&
          contains( preferredDoc, b ) ) {
          return 1;
        }
  
        // Maintain original order
        return sortInput ?
          ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
          0;
      }
  
      return compare & 4 ? -1 : 1;
    } :
    function( a, b ) {
  
      // Exit early if the nodes are identical
      if ( a === b ) {
        hasDuplicate = true;
        return 0;
      }
  
      var cur,
        i = 0,
        aup = a.parentNode,
        bup = b.parentNode,
        ap = [ a ],
        bp = [ b ];
  
      // Parentless nodes are either documents or disconnected
      if ( !aup || !bup ) {
  
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        return a == document ? -1 :
          b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 :
          bup ? 1 :
          sortInput ?
          ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
          0;
  
      // If the nodes are siblings, we can do a quick check
      } else if ( aup === bup ) {
        return siblingCheck( a, b );
      }
  
      // Otherwise we need full lists of their ancestors for comparison
      cur = a;
      while ( ( cur = cur.parentNode ) ) {
        ap.unshift( cur );
      }
      cur = b;
      while ( ( cur = cur.parentNode ) ) {
        bp.unshift( cur );
      }
  
      // Walk down the tree looking for a discrepancy
      while ( ap[ i ] === bp[ i ] ) {
        i++;
      }
  
      return i ?
  
        // Do a sibling check if the nodes have a common ancestor
        siblingCheck( ap[ i ], bp[ i ] ) :
  
        // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[ i ] == preferredDoc ? -1 :
        bp[ i ] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
    };
  
    return document;
  };
  
  Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
  };
  
  Sizzle.matchesSelector = function( elem, expr ) {
    setDocument( elem );
  
    if ( support.matchesSelector && documentIsHTML &&
      !nonnativeSelectorCache[ expr + " " ] &&
      ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
      ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
  
      try {
        var ret = matches.call( elem, expr );
  
        // IE 9's matchesSelector returns false on disconnected nodes
        if ( ret || support.disconnectedMatch ||
  
          // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11 ) {
          return ret;
        }
      } catch ( e ) {
        nonnativeSelectorCache( expr, true );
      }
    }
  
    return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };
  
  Sizzle.contains = function( context, elem ) {
  
    // Set document vars if needed
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    if ( ( context.ownerDocument || context ) != document ) {
      setDocument( context );
    }
    return contains( context, elem );
  };
  
  Sizzle.attr = function( elem, name ) {
  
    // Set document vars if needed
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    if ( ( elem.ownerDocument || elem ) != document ) {
      setDocument( elem );
    }
  
    var fn = Expr.attrHandle[ name.toLowerCase() ],
  
      // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
        fn( elem, name, !documentIsHTML ) :
        undefined;
  
    return val !== undefined ?
      val :
      support.attributes || !documentIsHTML ?
        elem.getAttribute( name ) :
        ( val = elem.getAttributeNode( name ) ) && val.specified ?
          val.value :
          null;
  };
  
  Sizzle.escape = function( sel ) {
    return ( sel + "" ).replace( rcssescape, fcssescape );
  };
  
  Sizzle.error = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
  };
  
  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
    var elem,
      duplicates = [],
      j = 0,
      i = 0;
  
    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice( 0 );
    results.sort( sortOrder );
  
    if ( hasDuplicate ) {
      while ( ( elem = results[ i++ ] ) ) {
        if ( elem === results[ i ] ) {
          j = duplicates.push( i );
        }
      }
      while ( j-- ) {
        results.splice( duplicates[ j ], 1 );
      }
    }
  
    // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225
    sortInput = null;
  
    return results;
  };
  
  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
    var node,
      ret = "",
      i = 0,
      nodeType = elem.nodeType;
  
    if ( !nodeType ) {
  
      // If no nodeType, this is expected to be an array
      while ( ( node = elem[ i++ ] ) ) {
  
        // Do not traverse comment nodes
        ret += getText( node );
      }
    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
  
      // Use textContent for elements
      // innerText usage removed for consistency of new lines (jQuery #11153)
      if ( typeof elem.textContent === "string" ) {
        return elem.textContent;
      } else {
  
        // Traverse its children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
          ret += getText( elem );
        }
      }
    } else if ( nodeType === 3 || nodeType === 4 ) {
      return elem.nodeValue;
    }
  
    // Do not include comment or processing instruction nodes
  
    return ret;
  };
  
  Expr = Sizzle.selectors = {
  
    // Can be adjusted by the user
    cacheLength: 50,
  
    createPseudo: markFunction,
  
    match: matchExpr,
  
    attrHandle: {},
  
    find: {},
  
    relative: {
      ">": { dir: "parentNode", first: true },
      " ": { dir: "parentNode" },
      "+": { dir: "previousSibling", first: true },
      "~": { dir: "previousSibling" }
    },
  
    preFilter: {
      "ATTR": function( match ) {
        match[ 1 ] = match[ 1 ].replace( runescape, funescape );
  
        // Move the given value to match[3] whether quoted or unquoted
        match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
          match[ 5 ] || "" ).replace( runescape, funescape );
  
        if ( match[ 2 ] === "~=" ) {
          match[ 3 ] = " " + match[ 3 ] + " ";
        }
  
        return match.slice( 0, 4 );
      },
  
      "CHILD": function( match ) {
  
        /* matches from matchExpr["CHILD"]
          1 type (only|nth|...)
          2 what (child|of-type)
          3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          4 xn-component of xn+y argument ([+-]?\d*n|)
          5 sign of xn-component
          6 x of xn-component
          7 sign of y-component
          8 y of y-component
        */
        match[ 1 ] = match[ 1 ].toLowerCase();
  
        if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {
  
          // nth-* requires argument
          if ( !match[ 3 ] ) {
            Sizzle.error( match[ 0 ] );
          }
  
          // numeric x and y parameters for Expr.filter.CHILD
          // remember that false/true cast respectively to 0/1
          match[ 4 ] = +( match[ 4 ] ?
            match[ 5 ] + ( match[ 6 ] || 1 ) :
            2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
          match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );
  
          // other types prohibit arguments
        } else if ( match[ 3 ] ) {
          Sizzle.error( match[ 0 ] );
        }
  
        return match;
      },
  
      "PSEUDO": function( match ) {
        var excess,
          unquoted = !match[ 6 ] && match[ 2 ];
  
        if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
          return null;
        }
  
        // Accept quoted arguments as-is
        if ( match[ 3 ] ) {
          match[ 2 ] = match[ 4 ] || match[ 5 ] || "";
  
        // Strip excess characters from unquoted arguments
        } else if ( unquoted && rpseudo.test( unquoted ) &&
  
          // Get excess from tokenize (recursively)
          ( excess = tokenize( unquoted, true ) ) &&
  
          // advance to the next closing parenthesis
          ( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {
  
          // excess is a negative index
          match[ 0 ] = match[ 0 ].slice( 0, excess );
          match[ 2 ] = unquoted.slice( 0, excess );
        }
  
        // Return only captures needed by the pseudo filter method (type and argument)
        return match.slice( 0, 3 );
      }
    },
  
    filter: {
  
      "TAG": function( nodeNameSelector ) {
        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
        return nodeNameSelector === "*" ?
          function() {
            return true;
          } :
          function( elem ) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
      },
  
      "CLASS": function( className ) {
        var pattern = classCache[ className + " " ];
  
        return pattern ||
          ( pattern = new RegExp( "(^|" + whitespace +
            ")" + className + "(" + whitespace + "|$)" ) ) && classCache(
              className, function( elem ) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className ||
                  typeof elem.getAttribute !== "undefined" &&
                    elem.getAttribute( "class" ) ||
                  ""
                );
          } );
      },
  
      "ATTR": function( name, operator, check ) {
        return function( elem ) {
          var result = Sizzle.attr( elem, name );
  
          if ( result == null ) {
            return operator === "!=";
          }
          if ( !operator ) {
            return true;
          }
  
          result += "";
  
          /* eslint-disable max-len */
  
          return operator === "=" ? result === check :
            operator === "!=" ? result !== check :
            operator === "^=" ? check && result.indexOf( check ) === 0 :
            operator === "*=" ? check && result.indexOf( check ) > -1 :
            operator === "$=" ? check && result.slice( -check.length ) === check :
            operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
            operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
            false;
          /* eslint-enable max-len */
  
        };
      },
  
      "CHILD": function( type, what, _argument, first, last ) {
        var simple = type.slice( 0, 3 ) !== "nth",
          forward = type.slice( -4 ) !== "last",
          ofType = what === "of-type";
  
        return first === 1 && last === 0 ?
  
          // Shortcut for :nth-*(n)
          function( elem ) {
            return !!elem.parentNode;
          } :
  
          function( elem, _context, xml ) {
            var cache, uniqueCache, outerCache, node, nodeIndex, start,
              dir = simple !== forward ? "nextSibling" : "previousSibling",
              parent = elem.parentNode,
              name = ofType && elem.nodeName.toLowerCase(),
              useCache = !xml && !ofType,
              diff = false;
  
            if ( parent ) {
  
              // :(first|last|only)-(child|of-type)
              if ( simple ) {
                while ( dir ) {
                  node = elem;
                  while ( ( node = node[ dir ] ) ) {
                    if ( ofType ?
                      node.nodeName.toLowerCase() === name :
                      node.nodeType === 1 ) {
  
                      return false;
                    }
                  }
  
                  // Reverse direction for :only-* (if we haven't yet done so)
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
  
              start = [ forward ? parent.firstChild : parent.lastChild ];
  
              // non-xml :nth-child(...) stores cache data on `parent`
              if ( forward && useCache ) {
  
                // Seek `elem` from a previously-cached index
  
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[ expando ] || ( node[ expando ] = {} );
  
                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[ node.uniqueID ] ||
                  ( outerCache[ node.uniqueID ] = {} );
  
                cache = uniqueCache[ type ] || [];
                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                diff = nodeIndex && cache[ 2 ];
                node = nodeIndex && parent.childNodes[ nodeIndex ];
  
                while ( ( node = ++nodeIndex && node && node[ dir ] ||
  
                  // Fallback to seeking `elem` from the start
                  ( diff = nodeIndex = 0 ) || start.pop() ) ) {
  
                  // When found, cache indexes on `parent` and break
                  if ( node.nodeType === 1 && ++diff && node === elem ) {
                    uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                    break;
                  }
                }
  
              } else {
  
                // Use previously-cached element index if available
                if ( useCache ) {
  
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[ expando ] || ( node[ expando ] = {} );
  
                  // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)
                  uniqueCache = outerCache[ node.uniqueID ] ||
                    ( outerCache[ node.uniqueID ] = {} );
  
                  cache = uniqueCache[ type ] || [];
                  nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                  diff = nodeIndex;
                }
  
                // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                if ( diff === false ) {
  
                  // Use the same loop as above to seek `elem` from the start
                  while ( ( node = ++nodeIndex && node && node[ dir ] ||
                    ( diff = nodeIndex = 0 ) || start.pop() ) ) {
  
                    if ( ( ofType ?
                      node.nodeName.toLowerCase() === name :
                      node.nodeType === 1 ) &&
                      ++diff ) {
  
                      // Cache the index of each encountered element
                      if ( useCache ) {
                        outerCache = node[ expando ] ||
                          ( node[ expando ] = {} );
  
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[ node.uniqueID ] ||
                          ( outerCache[ node.uniqueID ] = {} );
  
                        uniqueCache[ type ] = [ dirruns, diff ];
                      }
  
                      if ( node === elem ) {
                        break;
                      }
                    }
                  }
                }
              }
  
              // Incorporate the offset, then check against cycle size
              diff -= last;
              return diff === first || ( diff % first === 0 && diff / first >= 0 );
            }
          };
      },
  
      "PSEUDO": function( pseudo, argument ) {
  
        // pseudo-class names are case-insensitive
        // http://www.w3.org/TR/selectors/#pseudo-classes
        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
        // Remember that setFilters inherits from pseudos
        var args,
          fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
            Sizzle.error( "unsupported pseudo: " + pseudo );
  
        // The user may use createPseudo to indicate that
        // arguments are needed to create the filter function
        // just as Sizzle does
        if ( fn[ expando ] ) {
          return fn( argument );
        }
  
        // But maintain support for old signatures
        if ( fn.length > 1 ) {
          args = [ pseudo, pseudo, "", argument ];
          return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
            markFunction( function( seed, matches ) {
              var idx,
                matched = fn( seed, argument ),
                i = matched.length;
              while ( i-- ) {
                idx = indexOf( seed, matched[ i ] );
                seed[ idx ] = !( matches[ idx ] = matched[ i ] );
              }
            } ) :
            function( elem ) {
              return fn( elem, 0, args );
            };
        }
  
        return fn;
      }
    },
  
    pseudos: {
  
      // Potentially complex pseudos
      "not": markFunction( function( selector ) {
  
        // Trim the selector passed to compile
        // to avoid treating leading and trailing
        // spaces as combinators
        var input = [],
          results = [],
          matcher = compile( selector.replace( rtrim, "$1" ) );
  
        return matcher[ expando ] ?
          markFunction( function( seed, matches, _context, xml ) {
            var elem,
              unmatched = matcher( seed, null, xml, [] ),
              i = seed.length;
  
            // Match elements unmatched by `matcher`
            while ( i-- ) {
              if ( ( elem = unmatched[ i ] ) ) {
                seed[ i ] = !( matches[ i ] = elem );
              }
            }
          } ) :
          function( elem, _context, xml ) {
            input[ 0 ] = elem;
            matcher( input, null, xml, results );
  
            // Don't keep the element (issue #299)
            input[ 0 ] = null;
            return !results.pop();
          };
      } ),
  
      "has": markFunction( function( selector ) {
        return function( elem ) {
          return Sizzle( selector, elem ).length > 0;
        };
      } ),
  
      "contains": markFunction( function( text ) {
        text = text.replace( runescape, funescape );
        return function( elem ) {
          return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
        };
      } ),
  
      // "Whether an element is represented by a :lang() selector
      // is based solely on the element's language value
      // being equal to the identifier C,
      // or beginning with the identifier C immediately followed by "-".
      // The matching of C against the element's language value is performed case-insensitively.
      // The identifier C does not have to be a valid language name."
      // http://www.w3.org/TR/selectors/#lang-pseudo
      "lang": markFunction( function( lang ) {
  
        // lang value must be a valid identifier
        if ( !ridentifier.test( lang || "" ) ) {
          Sizzle.error( "unsupported lang: " + lang );
        }
        lang = lang.replace( runescape, funescape ).toLowerCase();
        return function( elem ) {
          var elemLang;
          do {
            if ( ( elemLang = documentIsHTML ?
              elem.lang :
              elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {
  
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
            }
          } while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
          return false;
        };
      } ),
  
      // Miscellaneous
      "target": function( elem ) {
        var hash = window.location && window.location.hash;
        return hash && hash.slice( 1 ) === elem.id;
      },
  
      "root": function( elem ) {
        return elem === docElem;
      },
  
      "focus": function( elem ) {
        return elem === document.activeElement &&
          ( !document.hasFocus || document.hasFocus() ) &&
          !!( elem.type || elem.href || ~elem.tabIndex );
      },
  
      // Boolean properties
      "enabled": createDisabledPseudo( false ),
      "disabled": createDisabledPseudo( true ),
  
      "checked": function( elem ) {
  
        // In CSS3, :checked should return both checked and selected elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        var nodeName = elem.nodeName.toLowerCase();
        return ( nodeName === "input" && !!elem.checked ) ||
          ( nodeName === "option" && !!elem.selected );
      },
  
      "selected": function( elem ) {
  
        // Accessing this property makes selected-by-default
        // options in Safari work properly
        if ( elem.parentNode ) {
          // eslint-disable-next-line no-unused-expressions
          elem.parentNode.selectedIndex;
        }
  
        return elem.selected === true;
      },
  
      // Contents
      "empty": function( elem ) {
  
        // http://www.w3.org/TR/selectors/#empty-pseudo
        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
        //   but not by others (comment: 8; processing instruction: 7; etc.)
        // nodeType < 6 works because attributes (2) do not appear as children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
          if ( elem.nodeType < 6 ) {
            return false;
          }
        }
        return true;
      },
  
      "parent": function( elem ) {
        return !Expr.pseudos[ "empty" ]( elem );
      },
  
      // Element/input types
      "header": function( elem ) {
        return rheader.test( elem.nodeName );
      },
  
      "input": function( elem ) {
        return rinputs.test( elem.nodeName );
      },
  
      "button": function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
  
      "text": function( elem ) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" &&
          elem.type === "text" &&
  
          // Support: IE <10 only
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          ( ( attr = elem.getAttribute( "type" ) ) == null ||
            attr.toLowerCase() === "text" );
      },
  
      // Position-in-collection
      "first": createPositionalPseudo( function() {
        return [ 0 ];
      } ),
  
      "last": createPositionalPseudo( function( _matchIndexes, length ) {
        return [ length - 1 ];
      } ),
  
      "eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
        return [ argument < 0 ? argument + length : argument ];
      } ),
  
      "even": createPositionalPseudo( function( matchIndexes, length ) {
        var i = 0;
        for ( ; i < length; i += 2 ) {
          matchIndexes.push( i );
        }
        return matchIndexes;
      } ),
  
      "odd": createPositionalPseudo( function( matchIndexes, length ) {
        var i = 1;
        for ( ; i < length; i += 2 ) {
          matchIndexes.push( i );
        }
        return matchIndexes;
      } ),
  
      "lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
        var i = argument < 0 ?
          argument + length :
          argument > length ?
            length :
            argument;
        for ( ; --i >= 0; ) {
          matchIndexes.push( i );
        }
        return matchIndexes;
      } ),
  
      "gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
        var i = argument < 0 ? argument + length : argument;
        for ( ; ++i < length; ) {
          matchIndexes.push( i );
        }
        return matchIndexes;
      } )
    }
  };
  
  Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];
  
  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
    Expr.pseudos[ i ] = createButtonPseudo( i );
  }
  
  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  
  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
    var matched, match, tokens, type,
      soFar, groups, preFilters,
      cached = tokenCache[ selector + " " ];
  
    if ( cached ) {
      return parseOnly ? 0 : cached.slice( 0 );
    }
  
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
  
    while ( soFar ) {
  
      // Comma and first run
      if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
        if ( match ) {
  
          // Don't consume trailing commas as valid
          soFar = soFar.slice( match[ 0 ].length ) || soFar;
        }
        groups.push( ( tokens = [] ) );
      }
  
      matched = false;
  
      // Combinators
      if ( ( match = rcombinators.exec( soFar ) ) ) {
        matched = match.shift();
        tokens.push( {
          value: matched,
  
          // Cast descendant combinators to space
          type: match[ 0 ].replace( rtrim, " " )
        } );
        soFar = soFar.slice( matched.length );
      }
  
      // Filters
      for ( type in Expr.filter ) {
        if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
          ( match = preFilters[ type ]( match ) ) ) ) {
          matched = match.shift();
          tokens.push( {
            value: matched,
            type: type,
            matches: match
          } );
          soFar = soFar.slice( matched.length );
        }
      }
  
      if ( !matched ) {
        break;
      }
    }
  
    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
      soFar.length :
      soFar ?
        Sizzle.error( selector ) :
  
        // Cache the tokens
        tokenCache( selector, groups ).slice( 0 );
  };
  
  function toSelector( tokens ) {
    var i = 0,
      len = tokens.length,
      selector = "";
    for ( ; i < len; i++ ) {
      selector += tokens[ i ].value;
    }
    return selector;
  }
  
  function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
      skip = combinator.next,
      key = skip || dir,
      checkNonElements = base && key === "parentNode",
      doneName = done++;
  
    return combinator.first ?
  
      // Check against closest ancestor/preceding element
      function( elem, context, xml ) {
        while ( ( elem = elem[ dir ] ) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            return matcher( elem, context, xml );
          }
        }
        return false;
      } :
  
      // Check against all ancestor/preceding elements
      function( elem, context, xml ) {
        var oldCache, uniqueCache, outerCache,
          newCache = [ dirruns, doneName ];
  
        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
        if ( xml ) {
          while ( ( elem = elem[ dir ] ) ) {
            if ( elem.nodeType === 1 || checkNonElements ) {
              if ( matcher( elem, context, xml ) ) {
                return true;
              }
            }
          }
        } else {
          while ( ( elem = elem[ dir ] ) ) {
            if ( elem.nodeType === 1 || checkNonElements ) {
              outerCache = elem[ expando ] || ( elem[ expando ] = {} );
  
              // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)
              uniqueCache = outerCache[ elem.uniqueID ] ||
                ( outerCache[ elem.uniqueID ] = {} );
  
              if ( skip && skip === elem.nodeName.toLowerCase() ) {
                elem = elem[ dir ] || elem;
              } else if ( ( oldCache = uniqueCache[ key ] ) &&
                oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
  
                // Assign to newCache so results back-propagate to previous elements
                return ( newCache[ 2 ] = oldCache[ 2 ] );
              } else {
  
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[ key ] = newCache;
  
                // A match means we're done; a fail means we have to keep checking
                if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
  }
  
  function elementMatcher( matchers ) {
    return matchers.length > 1 ?
      function( elem, context, xml ) {
        var i = matchers.length;
        while ( i-- ) {
          if ( !matchers[ i ]( elem, context, xml ) ) {
            return false;
          }
        }
        return true;
      } :
      matchers[ 0 ];
  }
  
  function multipleContexts( selector, contexts, results ) {
    var i = 0,
      len = contexts.length;
    for ( ; i < len; i++ ) {
      Sizzle( selector, contexts[ i ], results );
    }
    return results;
  }
  
  function condense( unmatched, map, filter, context, xml ) {
    var elem,
      newUnmatched = [],
      i = 0,
      len = unmatched.length,
      mapped = map != null;
  
    for ( ; i < len; i++ ) {
      if ( ( elem = unmatched[ i ] ) ) {
        if ( !filter || filter( elem, context, xml ) ) {
          newUnmatched.push( elem );
          if ( mapped ) {
            map.push( i );
          }
        }
      }
    }
  
    return newUnmatched;
  }
  
  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
      postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
      postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction( function( seed, results, context, xml ) {
      var temp, i, elem,
        preMap = [],
        postMap = [],
        preexisting = results.length,
  
        // Get initial elements from seed or context
        elems = seed || multipleContexts(
          selector || "*",
          context.nodeType ? [ context ] : context,
          []
        ),
  
        // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && ( seed || !selector ) ?
          condense( elems, preMap, preFilter, context, xml ) :
          elems,
  
        matcherOut = matcher ?
  
          // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
  
            // ...intermediate processing is necessary
            [] :
  
            // ...otherwise use results directly
            results :
          matcherIn;
  
      // Find primary matches
      if ( matcher ) {
        matcher( matcherIn, matcherOut, context, xml );
      }
  
      // Apply postFilter
      if ( postFilter ) {
        temp = condense( matcherOut, postMap );
        postFilter( temp, [], context, xml );
  
        // Un-match failing elements by moving them back to matcherIn
        i = temp.length;
        while ( i-- ) {
          if ( ( elem = temp[ i ] ) ) {
            matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
          }
        }
      }
  
      if ( seed ) {
        if ( postFinder || preFilter ) {
          if ( postFinder ) {
  
            // Get the final matcherOut by condensing this intermediate into postFinder contexts
            temp = [];
            i = matcherOut.length;
            while ( i-- ) {
              if ( ( elem = matcherOut[ i ] ) ) {
  
                // Restore matcherIn since elem is not yet a final match
                temp.push( ( matcherIn[ i ] = elem ) );
              }
            }
            postFinder( null, ( matcherOut = [] ), temp, xml );
          }
  
          // Move matched elements from seed to results to keep them synchronized
          i = matcherOut.length;
          while ( i-- ) {
            if ( ( elem = matcherOut[ i ] ) &&
              ( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {
  
              seed[ temp ] = !( results[ temp ] = elem );
            }
          }
        }
  
      // Add elements to results, through postFinder if defined
      } else {
        matcherOut = condense(
          matcherOut === results ?
            matcherOut.splice( preexisting, matcherOut.length ) :
            matcherOut
        );
        if ( postFinder ) {
          postFinder( null, results, matcherOut, xml );
        } else {
          push.apply( results, matcherOut );
        }
      }
    } );
  }
  
  function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
      len = tokens.length,
      leadingRelative = Expr.relative[ tokens[ 0 ].type ],
      implicitRelative = leadingRelative || Expr.relative[ " " ],
      i = leadingRelative ? 1 : 0,
  
      // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator( function( elem ) {
        return elem === checkContext;
      }, implicitRelative, true ),
      matchAnyContext = addCombinator( function( elem ) {
        return indexOf( checkContext, elem ) > -1;
      }, implicitRelative, true ),
      matchers = [ function( elem, context, xml ) {
        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
          ( checkContext = context ).nodeType ?
            matchContext( elem, context, xml ) :
            matchAnyContext( elem, context, xml ) );
  
        // Avoid hanging onto element (issue #299)
        checkContext = null;
        return ret;
      } ];
  
    for ( ; i < len; i++ ) {
      if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
        matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
      } else {
        matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );
  
        // Return special upon seeing a positional matcher
        if ( matcher[ expando ] ) {
  
          // Find the next relative operator (if any) for proper handling
          j = ++i;
          for ( ; j < len; j++ ) {
            if ( Expr.relative[ tokens[ j ].type ] ) {
              break;
            }
          }
          return setMatcher(
            i > 1 && elementMatcher( matchers ),
            i > 1 && toSelector(
  
            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens
              .slice( 0, i - 1 )
              .concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
            ).replace( rtrim, "$1" ),
            matcher,
            i < j && matcherFromTokens( tokens.slice( i, j ) ),
            j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
            j < len && toSelector( tokens )
          );
        }
        matchers.push( matcher );
      }
    }
  
    return elementMatcher( matchers );
  }
  
  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers.length > 0,
      byElement = elementMatchers.length > 0,
      superMatcher = function( seed, context, xml, results, outermost ) {
        var elem, j, matcher,
          matchedCount = 0,
          i = "0",
          unmatched = seed && [],
          setMatched = [],
          contextBackup = outermostContext,
  
          // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),
  
          // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
          len = elems.length;
  
        if ( outermost ) {
  
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        }
  
        // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
        for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
          if ( byElement && elem ) {
            j = 0;
  
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ( !context && elem.ownerDocument != document ) {
              setDocument( elem );
              xml = !documentIsHTML;
            }
            while ( ( matcher = elementMatchers[ j++ ] ) ) {
              if ( matcher( elem, context || document, xml ) ) {
                results.push( elem );
                break;
              }
            }
            if ( outermost ) {
              dirruns = dirrunsUnique;
            }
          }
  
          // Track unmatched elements for set filters
          if ( bySet ) {
  
            // They will have gone through all possible matchers
            if ( ( elem = !matcher && elem ) ) {
              matchedCount--;
            }
  
            // Lengthen the array for every element, matched or not
            if ( seed ) {
              unmatched.push( elem );
            }
          }
        }
  
        // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.
        matchedCount += i;
  
        // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.
        if ( bySet && i !== matchedCount ) {
          j = 0;
          while ( ( matcher = setMatchers[ j++ ] ) ) {
            matcher( unmatched, setMatched, context, xml );
          }
  
          if ( seed ) {
  
            // Reintegrate element matches to eliminate the need for sorting
            if ( matchedCount > 0 ) {
              while ( i-- ) {
                if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
                  setMatched[ i ] = pop.call( results );
                }
              }
            }
  
            // Discard index placeholder values to get only actual matches
            setMatched = condense( setMatched );
          }
  
          // Add matches to results
          push.apply( results, setMatched );
  
          // Seedless set matches succeeding multiple successful matchers stipulate sorting
          if ( outermost && !seed && setMatched.length > 0 &&
            ( matchedCount + setMatchers.length ) > 1 ) {
  
            Sizzle.uniqueSort( results );
          }
        }
  
        // Override manipulation of globals by nested matchers
        if ( outermost ) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
  
        return unmatched;
      };
  
    return bySet ?
      markFunction( superMatcher ) :
      superMatcher;
  }
  
  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
    var i,
      setMatchers = [],
      elementMatchers = [],
      cached = compilerCache[ selector + " " ];
  
    if ( !cached ) {
  
      // Generate a function of recursive functions that can be used to check each element
      if ( !match ) {
        match = tokenize( selector );
      }
      i = match.length;
      while ( i-- ) {
        cached = matcherFromTokens( match[ i ] );
        if ( cached[ expando ] ) {
          setMatchers.push( cached );
        } else {
          elementMatchers.push( cached );
        }
      }
  
      // Cache the compiled function
      cached = compilerCache(
        selector,
        matcherFromGroupMatchers( elementMatchers, setMatchers )
      );
  
      // Save selector and tokenization
      cached.selector = selector;
    }
    return cached;
  };
  
  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
    var i, tokens, token, type, find,
      compiled = typeof selector === "function" && selector,
      match = !seed && tokenize( ( selector = compiled.selector || selector ) );
  
    results = results || [];
  
    // Try to minimize operations if there is only one selector in the list and no seed
    // (the latter of which guarantees us context)
    if ( match.length === 1 ) {
  
      // Reduce context if the leading compound selector is an ID
      tokens = match[ 0 ] = match[ 0 ].slice( 0 );
      if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
        context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {
  
        context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
          .replace( runescape, funescape ), context ) || [] )[ 0 ];
        if ( !context ) {
          return results;
  
        // Precompiled matchers will still verify ancestry, so step up a level
        } else if ( compiled ) {
          context = context.parentNode;
        }
  
        selector = selector.slice( tokens.shift().value.length );
      }
  
      // Fetch a seed set for right-to-left matching
      i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
      while ( i-- ) {
        token = tokens[ i ];
  
        // Abort if we hit a combinator
        if ( Expr.relative[ ( type = token.type ) ] ) {
          break;
        }
        if ( ( find = Expr.find[ type ] ) ) {
  
          // Search, expanding context for leading sibling combinators
          if ( ( seed = find(
            token.matches[ 0 ].replace( runescape, funescape ),
            rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
              context
          ) ) ) {
  
            // If seed is empty or no tokens remain, we can return early
            tokens.splice( i, 1 );
            selector = seed.length && toSelector( tokens );
            if ( !selector ) {
              push.apply( results, seed );
              return results;
            }
  
            break;
          }
        }
      }
    }
  
    // Compile and execute a filtering function if one is not provided
    // Provide `match` to avoid retokenization if we modified the selector above
    ( compiled || compile( selector, match ) )(
      seed,
      context,
      !documentIsHTML,
      results,
      !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
    );
    return results;
  };
  
  // One-time assignments
  
  // Sort stability
  support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;
  
  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;
  
  // Initialize against the default document
  setDocument();
  
  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert( function( el ) {
  
    // Should return 1, but returns 4 (following)
    return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  } );
  
  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert( function( el ) {
    el.innerHTML = "<a href='#'></a>";
    return el.firstChild.getAttribute( "href" ) === "#";
  } ) ) {
    addHandle( "type|href|height|width", function( elem, name, isXML ) {
      if ( !isXML ) {
        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
      }
    } );
  }
  
  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert( function( el ) {
    el.innerHTML = "<input/>";
    el.firstChild.setAttribute( "value", "" );
    return el.firstChild.getAttribute( "value" ) === "";
  } ) ) {
    addHandle( "value", function( elem, _name, isXML ) {
      if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
        return elem.defaultValue;
      }
    } );
  }
  
  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert( function( el ) {
    return el.getAttribute( "disabled" ) == null;
  } ) ) {
    addHandle( booleans, function( elem, name, isXML ) {
      var val;
      if ( !isXML ) {
        return elem[ name ] === true ? name.toLowerCase() :
          ( val = elem.getAttributeNode( name ) ) && val.specified ?
            val.value :
            null;
      }
    } );
  }
  
  return Sizzle;
  
  } )( window );
  
  
  
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  
  // Deprecated
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
  
  
  
  
  var dir = function( elem, dir, until ) {
    var matched = [],
      truncate = until !== undefined;
  
    while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
      if ( elem.nodeType === 1 ) {
        if ( truncate && jQuery( elem ).is( until ) ) {
          break;
        }
        matched.push( elem );
      }
    }
    return matched;
  };
  
  
  var siblings = function( n, elem ) {
    var matched = [];
  
    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        matched.push( n );
      }
    }
  
    return matched;
  };
  
  
  var rneedsContext = jQuery.expr.match.needsContext;
  
  
  
  function nodeName( elem, name ) {
  
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  
  }
  var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
  
  
  
  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
    if ( isFunction( qualifier ) ) {
      return jQuery.grep( elements, function( elem, i ) {
        return !!qualifier.call( elem, i, elem ) !== not;
      } );
    }
  
    // Single element
    if ( qualifier.nodeType ) {
      return jQuery.grep( elements, function( elem ) {
        return ( elem === qualifier ) !== not;
      } );
    }
  
    // Arraylike of elements (jQuery, arguments, Array)
    if ( typeof qualifier !== "string" ) {
      return jQuery.grep( elements, function( elem ) {
        return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
      } );
    }
  
    // Filtered directly for both simple and complex selectors
    return jQuery.filter( qualifier, elements, not );
  }
  
  jQuery.filter = function( expr, elems, not ) {
    var elem = elems[ 0 ];
  
    if ( not ) {
      expr = ":not(" + expr + ")";
    }
  
    if ( elems.length === 1 && elem.nodeType === 1 ) {
      return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
    }
  
    return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
      return elem.nodeType === 1;
    } ) );
  };
  
  jQuery.fn.extend( {
    find: function( selector ) {
      var i, ret,
        len = this.length,
        self = this;
  
      if ( typeof selector !== "string" ) {
        return this.pushStack( jQuery( selector ).filter( function() {
          for ( i = 0; i < len; i++ ) {
            if ( jQuery.contains( self[ i ], this ) ) {
              return true;
            }
          }
        } ) );
      }
  
      ret = this.pushStack( [] );
  
      for ( i = 0; i < len; i++ ) {
        jQuery.find( selector, self[ i ], ret );
      }
  
      return len > 1 ? jQuery.uniqueSort( ret ) : ret;
    },
    filter: function( selector ) {
      return this.pushStack( winnow( this, selector || [], false ) );
    },
    not: function( selector ) {
      return this.pushStack( winnow( this, selector || [], true ) );
    },
    is: function( selector ) {
      return !!winnow(
        this,
  
        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test( selector ) ?
          jQuery( selector ) :
          selector || [],
        false
      ).length;
    }
  } );
  
  
  // Initialize a jQuery object
  
  
  // A central reference to the root jQuery(document)
  var rootjQuery,
  
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
    // Strict HTML recognition (trac-11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
  
    init = jQuery.fn.init = function( selector, context, root ) {
      var match, elem;
  
      // HANDLE: $(""), $(null), $(undefined), $(false)
      if ( !selector ) {
        return this;
      }
  
      // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)
      root = root || rootjQuery;
  
      // Handle HTML strings
      if ( typeof selector === "string" ) {
        if ( selector[ 0 ] === "<" &&
          selector[ selector.length - 1 ] === ">" &&
          selector.length >= 3 ) {
  
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [ null, selector, null ];
  
        } else {
          match = rquickExpr.exec( selector );
        }
  
        // Match html or make sure no context is specified for #id
        if ( match && ( match[ 1 ] || !context ) ) {
  
          // HANDLE: $(html) -> $(array)
          if ( match[ 1 ] ) {
            context = context instanceof jQuery ? context[ 0 ] : context;
  
            // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge( this, jQuery.parseHTML(
              match[ 1 ],
              context && context.nodeType ? context.ownerDocument || context : document,
              true
            ) );
  
            // HANDLE: $(html, props)
            if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
              for ( match in context ) {
  
                // Properties of context are called as methods if possible
                if ( isFunction( this[ match ] ) ) {
                  this[ match ]( context[ match ] );
  
                // ...and otherwise set as attributes
                } else {
                  this.attr( match, context[ match ] );
                }
              }
            }
  
            return this;
  
          // HANDLE: $(#id)
          } else {
            elem = document.getElementById( match[ 2 ] );
  
            if ( elem ) {
  
              // Inject the element directly into the jQuery object
              this[ 0 ] = elem;
              this.length = 1;
            }
            return this;
          }
  
        // HANDLE: $(expr, $(...))
        } else if ( !context || context.jquery ) {
          return ( context || root ).find( selector );
  
        // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor( context ).find( selector );
        }
  
      // HANDLE: $(DOMElement)
      } else if ( selector.nodeType ) {
        this[ 0 ] = selector;
        this.length = 1;
        return this;
  
      // HANDLE: $(function)
      // Shortcut for document ready
      } else if ( isFunction( selector ) ) {
        return root.ready !== undefined ?
          root.ready( selector ) :
  
          // Execute immediately if ready is not present
          selector( jQuery );
      }
  
      return jQuery.makeArray( selector, this );
    };
  
  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;
  
  // Initialize central reference
  rootjQuery = jQuery( document );
  
  
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
  
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  
  jQuery.fn.extend( {
    has: function( target ) {
      var targets = jQuery( target, this ),
        l = targets.length;
  
      return this.filter( function() {
        var i = 0;
        for ( ; i < l; i++ ) {
          if ( jQuery.contains( this, targets[ i ] ) ) {
            return true;
          }
        }
      } );
    },
  
    closest: function( selectors, context ) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        targets = typeof selectors !== "string" && jQuery( selectors );
  
      // Positional selectors never match, since there's no _selection_ context
      if ( !rneedsContext.test( selectors ) ) {
        for ( ; i < l; i++ ) {
          for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
  
            // Always skip document fragments
            if ( cur.nodeType < 11 && ( targets ?
              targets.index( cur ) > -1 :
  
              // Don't pass non-elements to Sizzle
              cur.nodeType === 1 &&
                jQuery.find.matchesSelector( cur, selectors ) ) ) {
  
              matched.push( cur );
              break;
            }
          }
        }
      }
  
      return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
    },
  
    // Determine the position of an element within the set
    index: function( elem ) {
  
      // No argument, return index in parent
      if ( !elem ) {
        return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
      }
  
      // Index in selector
      if ( typeof elem === "string" ) {
        return indexOf.call( jQuery( elem ), this[ 0 ] );
      }
  
      // Locate the position of the desired element
      return indexOf.call( this,
  
        // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[ 0 ] : elem
      );
    },
  
    add: function( selector, context ) {
      return this.pushStack(
        jQuery.uniqueSort(
          jQuery.merge( this.get(), jQuery( selector, context ) )
        )
      );
    },
  
    addBack: function( selector ) {
      return this.add( selector == null ?
        this.prevObject : this.prevObject.filter( selector )
      );
    }
  } );
  
  function sibling( cur, dir ) {
    while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
    return cur;
  }
  
  jQuery.each( {
    parent: function( elem ) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
      return dir( elem, "parentNode" );
    },
    parentsUntil: function( elem, _i, until ) {
      return dir( elem, "parentNode", until );
    },
    next: function( elem ) {
      return sibling( elem, "nextSibling" );
    },
    prev: function( elem ) {
      return sibling( elem, "previousSibling" );
    },
    nextAll: function( elem ) {
      return dir( elem, "nextSibling" );
    },
    prevAll: function( elem ) {
      return dir( elem, "previousSibling" );
    },
    nextUntil: function( elem, _i, until ) {
      return dir( elem, "nextSibling", until );
    },
    prevUntil: function( elem, _i, until ) {
      return dir( elem, "previousSibling", until );
    },
    siblings: function( elem ) {
      return siblings( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
      return siblings( elem.firstChild );
    },
    contents: function( elem ) {
      if ( elem.contentDocument != null &&
  
        // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto( elem.contentDocument ) ) {
  
        return elem.contentDocument;
      }
  
      // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.
      if ( nodeName( elem, "template" ) ) {
        elem = elem.content || elem;
      }
  
      return jQuery.merge( [], elem.childNodes );
    }
  }, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
      var matched = jQuery.map( this, fn, until );
  
      if ( name.slice( -5 ) !== "Until" ) {
        selector = until;
      }
  
      if ( selector && typeof selector === "string" ) {
        matched = jQuery.filter( selector, matched );
      }
  
      if ( this.length > 1 ) {
  
        // Remove duplicates
        if ( !guaranteedUnique[ name ] ) {
          jQuery.uniqueSort( matched );
        }
  
        // Reverse order for parents* and prev-derivatives
        if ( rparentsprev.test( name ) ) {
          matched.reverse();
        }
      }
  
      return this.pushStack( matched );
    };
  } );
  var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
  
  
  
  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
    var object = {};
    jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
      object[ flag ] = true;
    } );
    return object;
  }
  
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {
  
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
      createOptions( options ) :
      jQuery.extend( {}, options );
  
    var // Flag to know if list is currently firing
      firing,
  
      // Last fire value for non-forgettable lists
      memory,
  
      // Flag to know if list was already fired
      fired,
  
      // Flag to prevent firing
      locked,
  
      // Actual callback list
      list = [],
  
      // Queue of execution data for repeatable lists
      queue = [],
  
      // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
  
      // Fire callbacks
      fire = function() {
  
        // Enforce single-firing
        locked = locked || options.once;
  
        // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes
        fired = firing = true;
        for ( ; queue.length; firingIndex = -1 ) {
          memory = queue.shift();
          while ( ++firingIndex < list.length ) {
  
            // Run callback and check for early termination
            if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
              options.stopOnFalse ) {
  
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        }
  
        // Forget the data if we're done with it
        if ( !options.memory ) {
          memory = false;
        }
  
        firing = false;
  
        // Clean up if we're done firing for good
        if ( locked ) {
  
          // Keep an empty list if we have data for future add calls
          if ( memory ) {
            list = [];
  
          // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
  
      // Actual Callbacks object
      self = {
  
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if ( list ) {
  
            // If we have memory from a past run, we should fire after adding
            if ( memory && !firing ) {
              firingIndex = list.length - 1;
              queue.push( memory );
            }
  
            ( function add( args ) {
              jQuery.each( args, function( _, arg ) {
                if ( isFunction( arg ) ) {
                  if ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                  }
                } else if ( arg && arg.length && toType( arg ) !== "string" ) {
  
                  // Inspect recursively
                  add( arg );
                }
              } );
            } )( arguments );
  
            if ( memory && !firing ) {
              fire();
            }
          }
          return this;
        },
  
        // Remove a callback from the list
        remove: function() {
          jQuery.each( arguments, function( _, arg ) {
            var index;
            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
              list.splice( index, 1 );
  
              // Handle firing indexes
              if ( index <= firingIndex ) {
                firingIndex--;
              }
            }
          } );
          return this;
        },
  
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function( fn ) {
          return fn ?
            jQuery.inArray( fn, list ) > -1 :
            list.length > 0;
        },
  
        // Remove all callbacks from the list
        empty: function() {
          if ( list ) {
            list = [];
          }
          return this;
        },
  
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
  
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue = [];
          if ( !memory && !firing ) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
  
        // Call all callbacks with the given context and arguments
        fireWith: function( context, args ) {
          if ( !locked ) {
            args = args || [];
            args = [ context, args.slice ? args.slice() : args ];
            queue.push( args );
            if ( !firing ) {
              fire();
            }
          }
          return this;
        },
  
        // Call all the callbacks with the given arguments
        fire: function() {
          self.fireWith( this, arguments );
          return this;
        },
  
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
  
    return self;
  };
  
  
  function Identity( v ) {
    return v;
  }
  function Thrower( ex ) {
    throw ex;
  }
  
  function adoptValue( value, resolve, reject, noValue ) {
    var method;
  
    try {
  
      // Check for promise aspect first to privilege synchronous behavior
      if ( value && isFunction( ( method = value.promise ) ) ) {
        method.call( value ).done( resolve ).fail( reject );
  
      // Other thenables
      } else if ( value && isFunction( ( method = value.then ) ) ) {
        method.call( value, resolve, reject );
  
      // Other non-thenables
      } else {
  
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply( undefined, [ value ].slice( noValue ) );
      }
  
    // For Promises/A+, convert exceptions into rejections
    // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
    // Deferred#then to conditionally suppress rejection.
    } catch ( value ) {
  
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply( undefined, [ value ] );
    }
  }
  
  jQuery.extend( {
  
    Deferred: function( func ) {
      var tuples = [
  
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [ "notify", "progress", jQuery.Callbacks( "memory" ),
            jQuery.Callbacks( "memory" ), 2 ],
          [ "resolve", "done", jQuery.Callbacks( "once memory" ),
            jQuery.Callbacks( "once memory" ), 0, "resolved" ],
          [ "reject", "fail", jQuery.Callbacks( "once memory" ),
            jQuery.Callbacks( "once memory" ), 1, "rejected" ]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done( arguments ).fail( arguments );
            return this;
          },
          "catch": function( fn ) {
            return promise.then( null, fn );
          },
  
          // Keep pipe for back-compat
          pipe: function( /* fnDone, fnFail, fnProgress */ ) {
            var fns = arguments;
  
            return jQuery.Deferred( function( newDefer ) {
              jQuery.each( tuples, function( _i, tuple ) {
  
                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
  
                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                deferred[ tuple[ 1 ] ]( function() {
                  var returned = fn && fn.apply( this, arguments );
                  if ( returned && isFunction( returned.promise ) ) {
                    returned.promise()
                      .progress( newDefer.notify )
                      .done( newDefer.resolve )
                      .fail( newDefer.reject );
                  } else {
                    newDefer[ tuple[ 0 ] + "With" ](
                      this,
                      fn ? [ returned ] : arguments
                    );
                  }
                } );
              } );
              fns = null;
            } ).promise();
          },
          then: function( onFulfilled, onRejected, onProgress ) {
            var maxDepth = 0;
            function resolve( depth, deferred, handler, special ) {
              return function() {
                var that = this,
                  args = arguments,
                  mightThrow = function() {
                    var returned, then;
  
                    // Support: Promises/A+ section 2.3.3.3.3
                    // https://promisesaplus.com/#point-59
                    // Ignore double-resolution attempts
                    if ( depth < maxDepth ) {
                      return;
                    }
  
                    returned = handler.apply( that, args );
  
                    // Support: Promises/A+ section 2.3.1
                    // https://promisesaplus.com/#point-48
                    if ( returned === deferred.promise() ) {
                      throw new TypeError( "Thenable self-resolution" );
                    }
  
                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                    // https://promisesaplus.com/#point-54
                    // https://promisesaplus.com/#point-75
                    // Retrieve `then` only once
                    then = returned &&
  
                      // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      ( typeof returned === "object" ||
                        typeof returned === "function" ) &&
                      returned.then;
  
                    // Handle a returned thenable
                    if ( isFunction( then ) ) {
  
                      // Special processors (notify) just wait for resolution
                      if ( special ) {
                        then.call(
                          returned,
                          resolve( maxDepth, deferred, Identity, special ),
                          resolve( maxDepth, deferred, Thrower, special )
                        );
  
                      // Normal processors (resolve) also hook into progress
                      } else {
  
                        // ...and disregard older resolution values
                        maxDepth++;
  
                        then.call(
                          returned,
                          resolve( maxDepth, deferred, Identity, special ),
                          resolve( maxDepth, deferred, Thrower, special ),
                          resolve( maxDepth, deferred, Identity,
                            deferred.notifyWith )
                        );
                      }
  
                    // Handle all other returned values
                    } else {
  
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if ( handler !== Identity ) {
                        that = undefined;
                        args = [ returned ];
                      }
  
                      // Process the value(s)
                      // Default process is resolve
                      ( special || deferred.resolveWith )( that, args );
                    }
                  },
  
                  // Only normal processors (resolve) catch and reject exceptions
                  process = special ?
                    mightThrow :
                    function() {
                      try {
                        mightThrow();
                      } catch ( e ) {
  
                        if ( jQuery.Deferred.exceptionHook ) {
                          jQuery.Deferred.exceptionHook( e,
                            process.stackTrace );
                        }
  
                        // Support: Promises/A+ section 2.3.3.3.4.1
                        // https://promisesaplus.com/#point-61
                        // Ignore post-resolution exceptions
                        if ( depth + 1 >= maxDepth ) {
  
                          // Only substitute handlers pass on context
                          // and multiple values (non-spec behavior)
                          if ( handler !== Thrower ) {
                            that = undefined;
                            args = [ e ];
                          }
  
                          deferred.rejectWith( that, args );
                        }
                      }
                    };
  
                // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors
                if ( depth ) {
                  process();
                } else {
  
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if ( jQuery.Deferred.getStackHook ) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window.setTimeout( process );
                }
              };
            }
  
            return jQuery.Deferred( function( newDefer ) {
  
              // progress_handlers.add( ... )
              tuples[ 0 ][ 3 ].add(
                resolve(
                  0,
                  newDefer,
                  isFunction( onProgress ) ?
                    onProgress :
                    Identity,
                  newDefer.notifyWith
                )
              );
  
              // fulfilled_handlers.add( ... )
              tuples[ 1 ][ 3 ].add(
                resolve(
                  0,
                  newDefer,
                  isFunction( onFulfilled ) ?
                    onFulfilled :
                    Identity
                )
              );
  
              // rejected_handlers.add( ... )
              tuples[ 2 ][ 3 ].add(
                resolve(
                  0,
                  newDefer,
                  isFunction( onRejected ) ?
                    onRejected :
                    Thrower
                )
              );
            } ).promise();
          },
  
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function( obj ) {
            return obj != null ? jQuery.extend( obj, promise ) : promise;
          }
        },
        deferred = {};
  
      // Add list-specific methods
      jQuery.each( tuples, function( i, tuple ) {
        var list = tuple[ 2 ],
          stateString = tuple[ 5 ];
  
        // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add
        promise[ tuple[ 1 ] ] = list.add;
  
        // Handle state
        if ( stateString ) {
          list.add(
            function() {
  
              // state = "resolved" (i.e., fulfilled)
              // state = "rejected"
              state = stateString;
            },
  
            // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            tuples[ 3 - i ][ 2 ].disable,
  
            // rejected_handlers.disable
            // fulfilled_handlers.disable
            tuples[ 3 - i ][ 3 ].disable,
  
            // progress_callbacks.lock
            tuples[ 0 ][ 2 ].lock,
  
            // progress_handlers.lock
            tuples[ 0 ][ 3 ].lock
          );
        }
  
        // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire
        list.add( tuple[ 3 ].fire );
  
        // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }
        deferred[ tuple[ 0 ] ] = function() {
          deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
          return this;
        };
  
        // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith
        deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
      } );
  
      // Make the deferred a promise
      promise.promise( deferred );
  
      // Call given func if any
      if ( func ) {
        func.call( deferred, deferred );
      }
  
      // All done!
      return deferred;
    },
  
    // Deferred helper
    when: function( singleValue ) {
      var
  
        // count of uncompleted subordinates
        remaining = arguments.length,
  
        // count of unprocessed arguments
        i = remaining,
  
        // subordinate fulfillment data
        resolveContexts = Array( i ),
        resolveValues = slice.call( arguments ),
  
        // the primary Deferred
        primary = jQuery.Deferred(),
  
        // subordinate callback factory
        updateFunc = function( i ) {
          return function( value ) {
            resolveContexts[ i ] = this;
            resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
            if ( !( --remaining ) ) {
              primary.resolveWith( resolveContexts, resolveValues );
            }
          };
        };
  
      // Single- and empty arguments are adopted like Promise.resolve
      if ( remaining <= 1 ) {
        adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
          !remaining );
  
        // Use .then() to unwrap secondary thenables (cf. gh-3000)
        if ( primary.state() === "pending" ||
          isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
  
          return primary.then();
        }
      }
  
      // Multiple arguments are aggregated like Promise.all array elements
      while ( i-- ) {
        adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
      }
  
      return primary.promise();
    }
  } );
  
  
  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  
  jQuery.Deferred.exceptionHook = function( error, stack ) {
  
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
      window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
    }
  };
  
  
  
  
  jQuery.readyException = function( error ) {
    window.setTimeout( function() {
      throw error;
    } );
  };
  
  
  
  
  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();
  
  jQuery.fn.ready = function( fn ) {
  
    readyList
      .then( fn )
  
      // Wrap jQuery.readyException in a function so that the lookup
      // happens at the time of error handling instead of callback
      // registration.
      .catch( function( error ) {
        jQuery.readyException( error );
      } );
  
    return this;
  };
  
  jQuery.extend( {
  
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
  
    // A counter to track how many items to wait for before
    // the ready event fires. See trac-6781
    readyWait: 1,
  
    // Handle when the DOM is ready
    ready: function( wait ) {
  
      // Abort if there are pending holds or we're already ready
      if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
        return;
      }
  
      // Remember that the DOM is ready
      jQuery.isReady = true;
  
      // If a normal DOM Ready event fired, decrement, and wait if need be
      if ( wait !== true && --jQuery.readyWait > 0 ) {
        return;
      }
  
      // If there are functions bound, to execute
      readyList.resolveWith( document, [ jQuery ] );
    }
  } );
  
  jQuery.ready.then = readyList.then;
  
  // The ready event handler and self cleanup method
  function completed() {
    document.removeEventListener( "DOMContentLoaded", completed );
    window.removeEventListener( "load", completed );
    jQuery.ready();
  }
  
  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if ( document.readyState === "complete" ||
    ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
  
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout( jQuery.ready );
  
  } else {
  
    // Use the handy event callback
    document.addEventListener( "DOMContentLoaded", completed );
  
    // A fallback to window.onload, that will always work
    window.addEventListener( "load", completed );
  }
  
  
  
  
  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    var i = 0,
      len = elems.length,
      bulk = key == null;
  
    // Sets many values
    if ( toType( key ) === "object" ) {
      chainable = true;
      for ( i in key ) {
        access( elems, fn, i, key[ i ], true, emptyGet, raw );
      }
  
    // Sets one value
    } else if ( value !== undefined ) {
      chainable = true;
  
      if ( !isFunction( value ) ) {
        raw = true;
      }
  
      if ( bulk ) {
  
        // Bulk operations run against the entire set
        if ( raw ) {
          fn.call( elems, value );
          fn = null;
  
        // ...except when executing function values
        } else {
          bulk = fn;
          fn = function( elem, _key, value ) {
            return bulk.call( jQuery( elem ), value );
          };
        }
      }
  
      if ( fn ) {
        for ( ; i < len; i++ ) {
          fn(
            elems[ i ], key, raw ?
              value :
              value.call( elems[ i ], i, fn( elems[ i ], key ) )
          );
        }
      }
    }
  
    if ( chainable ) {
      return elems;
    }
  
    // Gets
    if ( bulk ) {
      return fn.call( elems );
    }
  
    return len ? fn( elems[ 0 ], key ) : emptyGet;
  };
  
  
  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
    rdashAlpha = /-([a-z])/g;
  
  // Used by camelCase as callback to replace()
  function fcamelCase( _all, letter ) {
    return letter.toUpperCase();
  }
  
  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (trac-9572)
  function camelCase( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  }
  var acceptData = function( owner ) {
  
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };
  
  
  
  
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  
  Data.uid = 1;
  
  Data.prototype = {
  
    cache: function( owner ) {
  
      // Check if the owner object already has a cache
      var value = owner[ this.expando ];
  
      // If not, create one
      if ( !value ) {
        value = {};
  
        // We can accept data for non-element nodes in modern browsers,
        // but we should not, see trac-8335.
        // Always return an empty object.
        if ( acceptData( owner ) ) {
  
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if ( owner.nodeType ) {
            owner[ this.expando ] = value;
  
          // Otherwise secure it in a non-enumerable property
          // configurable must be true to allow the property to be
          // deleted when data is removed
          } else {
            Object.defineProperty( owner, this.expando, {
              value: value,
              configurable: true
            } );
          }
        }
      }
  
      return value;
    },
    set: function( owner, data, value ) {
      var prop,
        cache = this.cache( owner );
  
      // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)
      if ( typeof data === "string" ) {
        cache[ camelCase( data ) ] = value;
  
      // Handle: [ owner, { properties } ] args
      } else {
  
        // Copy the properties one-by-one to the cache object
        for ( prop in data ) {
          cache[ camelCase( prop ) ] = data[ prop ];
        }
      }
      return cache;
    },
    get: function( owner, key ) {
      return key === undefined ?
        this.cache( owner ) :
  
        // Always use camelCase key (gh-2257)
        owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
    },
    access: function( owner, key, value ) {
  
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if ( key === undefined ||
          ( ( key && typeof key === "string" ) && value === undefined ) ) {
  
        return this.get( owner, key );
      }
  
      // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set( owner, key, value );
  
      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
      var i,
        cache = owner[ this.expando ];
  
      if ( cache === undefined ) {
        return;
      }
  
      if ( key !== undefined ) {
  
        // Support array or space separated string of keys
        if ( Array.isArray( key ) ) {
  
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map( camelCase );
        } else {
          key = camelCase( key );
  
          // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace
          key = key in cache ?
            [ key ] :
            ( key.match( rnothtmlwhite ) || [] );
        }
  
        i = key.length;
  
        while ( i-- ) {
          delete cache[ key[ i ] ];
        }
      }
  
      // Remove the expando if there's no more data
      if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
  
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if ( owner.nodeType ) {
          owner[ this.expando ] = undefined;
        } else {
          delete owner[ this.expando ];
        }
      }
    },
    hasData: function( owner ) {
      var cache = owner[ this.expando ];
      return cache !== undefined && !jQuery.isEmptyObject( cache );
    }
  };
  var dataPriv = new Data();
  
  var dataUser = new Data();
  
  
  
  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
  
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /[A-Z]/g;
  
  function getData( data ) {
    if ( data === "true" ) {
      return true;
    }
  
    if ( data === "false" ) {
      return false;
    }
  
    if ( data === "null" ) {
      return null;
    }
  
    // Only convert to a number if it doesn't change the string
    if ( data === +data + "" ) {
      return +data;
    }
  
    if ( rbrace.test( data ) ) {
      return JSON.parse( data );
    }
  
    return data;
  }
  
  function dataAttr( elem, key, data ) {
    var name;
  
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem.nodeType === 1 ) {
      name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
      data = elem.getAttribute( name );
  
      if ( typeof data === "string" ) {
        try {
          data = getData( data );
        } catch ( e ) {}
  
        // Make sure we set the data so it isn't changed later
        dataUser.set( elem, key, data );
      } else {
        data = undefined;
      }
    }
    return data;
  }
  
  jQuery.extend( {
    hasData: function( elem ) {
      return dataUser.hasData( elem ) || dataPriv.hasData( elem );
    },
  
    data: function( elem, name, data ) {
      return dataUser.access( elem, name, data );
    },
  
    removeData: function( elem, name ) {
      dataUser.remove( elem, name );
    },
  
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function( elem, name, data ) {
      return dataPriv.access( elem, name, data );
    },
  
    _removeData: function( elem, name ) {
      dataPriv.remove( elem, name );
    }
  } );
  
  jQuery.fn.extend( {
    data: function( key, value ) {
      var i, name, data,
        elem = this[ 0 ],
        attrs = elem && elem.attributes;
  
      // Gets all values
      if ( key === undefined ) {
        if ( this.length ) {
          data = dataUser.get( elem );
  
          if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
            i = attrs.length;
            while ( i-- ) {
  
              // Support: IE 11 only
              // The attrs elements can be null (trac-14894)
              if ( attrs[ i ] ) {
                name = attrs[ i ].name;
                if ( name.indexOf( "data-" ) === 0 ) {
                  name = camelCase( name.slice( 5 ) );
                  dataAttr( elem, name, data[ name ] );
                }
              }
            }
            dataPriv.set( elem, "hasDataAttrs", true );
          }
        }
  
        return data;
      }
  
      // Sets multiple values
      if ( typeof key === "object" ) {
        return this.each( function() {
          dataUser.set( this, key );
        } );
      }
  
      return access( this, function( value ) {
        var data;
  
        // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.
        if ( elem && value === undefined ) {
  
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get( elem, key );
          if ( data !== undefined ) {
            return data;
          }
  
          // Attempt to "discover" the data in
          // HTML5 custom data-* attrs
          data = dataAttr( elem, key );
          if ( data !== undefined ) {
            return data;
          }
  
          // We tried really hard, but the data doesn't exist.
          return;
        }
  
        // Set the data...
        this.each( function() {
  
          // We always store the camelCased key
          dataUser.set( this, key, value );
        } );
      }, null, value, arguments.length > 1, null, true );
    },
  
    removeData: function( key ) {
      return this.each( function() {
        dataUser.remove( this, key );
      } );
    }
  } );
  
  
  jQuery.extend( {
    queue: function( elem, type, data ) {
      var queue;
  
      if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = dataPriv.get( elem, type );
  
        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
          if ( !queue || Array.isArray( data ) ) {
            queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
          } else {
            queue.push( data );
          }
        }
        return queue || [];
      }
    },
  
    dequeue: function( elem, type ) {
      type = type || "fx";
  
      var queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks( elem, type ),
        next = function() {
          jQuery.dequeue( elem, type );
        };
  
      // If the fx queue is dequeued, always remove the progress sentinel
      if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
      }
  
      if ( fn ) {
  
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
          queue.unshift( "inprogress" );
        }
  
        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
      }
  
      if ( !startLength && hooks ) {
        hooks.empty.fire();
      }
    },
  
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function( elem, type ) {
      var key = type + "queueHooks";
      return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
        empty: jQuery.Callbacks( "once memory" ).add( function() {
          dataPriv.remove( elem, [ type + "queue", key ] );
        } )
      } );
    }
  } );
  
  jQuery.fn.extend( {
    queue: function( type, data ) {
      var setter = 2;
  
      if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
      }
  
      if ( arguments.length < setter ) {
        return jQuery.queue( this[ 0 ], type );
      }
  
      return data === undefined ?
        this :
        this.each( function() {
          var queue = jQuery.queue( this, type, data );
  
          // Ensure a hooks for this queue
          jQuery._queueHooks( this, type );
  
          if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
            jQuery.dequeue( this, type );
          }
        } );
    },
    dequeue: function( type ) {
      return this.each( function() {
        jQuery.dequeue( this, type );
      } );
    },
    clearQueue: function( type ) {
      return this.queue( type || "fx", [] );
    },
  
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
          if ( !( --count ) ) {
            defer.resolveWith( elements, [ elements ] );
          }
        };
  
      if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
  
      while ( i-- ) {
        tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
          count++;
          tmp.empty.add( resolve );
        }
      }
      resolve();
      return defer.promise( obj );
    }
  } );
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
  
  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
  
  
  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
  
  var documentElement = document.documentElement;
  
  
  
    var isAttached = function( elem ) {
        return jQuery.contains( elem.ownerDocument, elem );
      },
      composed = { composed: true };
  
    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if ( documentElement.getRootNode ) {
      isAttached = function( elem ) {
        return jQuery.contains( elem.ownerDocument, elem ) ||
          elem.getRootNode( composed ) === elem.ownerDocument;
      };
    }
  var isHiddenWithinTree = function( elem, el ) {
  
      // isHiddenWithinTree might be called from jQuery#filter function;
      // in that case, element will be second argument
      elem = el || elem;
  
      // Inline style trumps all
      return elem.style.display === "none" ||
        elem.style.display === "" &&
  
        // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached( elem ) &&
  
        jQuery.css( elem, "display" ) === "none";
    };
  
  
  
  function adjustCSS( elem, prop, valueParts, tween ) {
    var adjusted, scale,
      maxIterations = 20,
      currentValue = tween ?
        function() {
          return tween.cur();
        } :
        function() {
          return jQuery.css( elem, prop, "" );
        },
      initial = currentValue(),
      unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
  
      // Starting value computation is required for potential unit mismatches
      initialInUnit = elem.nodeType &&
        ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
        rcssNum.exec( jQuery.css( elem, prop ) );
  
    if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
  
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2;
  
      // Trust units reported by jQuery.css
      unit = unit || initialInUnit[ 3 ];
  
      // Iteratively approximate from a nonzero starting point
      initialInUnit = +initial || 1;
  
      while ( maxIterations-- ) {
  
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style( elem, prop, initialInUnit + unit );
        if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
          maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;
  
      }
  
      initialInUnit = initialInUnit * 2;
      jQuery.style( elem, prop, initialInUnit + unit );
  
      // Make sure we update the tween properties later on
      valueParts = valueParts || [];
    }
  
    if ( valueParts ) {
      initialInUnit = +initialInUnit || +initial || 0;
  
      // Apply relative offset (+=/-=) if specified
      adjusted = valueParts[ 1 ] ?
        initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
        +valueParts[ 2 ];
      if ( tween ) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  
  
  var defaultDisplayMap = {};
  
  function getDefaultDisplay( elem ) {
    var temp,
      doc = elem.ownerDocument,
      nodeName = elem.nodeName,
      display = defaultDisplayMap[ nodeName ];
  
    if ( display ) {
      return display;
    }
  
    temp = doc.body.appendChild( doc.createElement( nodeName ) );
    display = jQuery.css( temp, "display" );
  
    temp.parentNode.removeChild( temp );
  
    if ( display === "none" ) {
      display = "block";
    }
    defaultDisplayMap[ nodeName ] = display;
  
    return display;
  }
  
  function showHide( elements, show ) {
    var display, elem,
      values = [],
      index = 0,
      length = elements.length;
  
    // Determine new display value for elements that need to change
    for ( ; index < length; index++ ) {
      elem = elements[ index ];
      if ( !elem.style ) {
        continue;
      }
  
      display = elem.style.display;
      if ( show ) {
  
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if ( display === "none" ) {
          values[ index ] = dataPriv.get( elem, "display" ) || null;
          if ( !values[ index ] ) {
            elem.style.display = "";
          }
        }
        if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
          values[ index ] = getDefaultDisplay( elem );
        }
      } else {
        if ( display !== "none" ) {
          values[ index ] = "none";
  
          // Remember what we're overwriting
          dataPriv.set( elem, "display", display );
        }
      }
    }
  
    // Set the display of the elements in a second loop to avoid constant reflow
    for ( index = 0; index < length; index++ ) {
      if ( values[ index ] != null ) {
        elements[ index ].style.display = values[ index ];
      }
    }
  
    return elements;
  }
  
  jQuery.fn.extend( {
    show: function() {
      return showHide( this, true );
    },
    hide: function() {
      return showHide( this );
    },
    toggle: function( state ) {
      if ( typeof state === "boolean" ) {
        return state ? this.show() : this.hide();
      }
  
      return this.each( function() {
        if ( isHiddenWithinTree( this ) ) {
          jQuery( this ).show();
        } else {
          jQuery( this ).hide();
        }
      } );
    }
  } );
  var rcheckableType = ( /^(?:checkbox|radio)$/i );
  
  var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );
  
  var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );
  
  
  
  ( function() {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild( document.createElement( "div" ) ),
      input = document.createElement( "input" );
  
    // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (trac-11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (trac-14901)
    input.setAttribute( "type", "radio" );
    input.setAttribute( "checked", "checked" );
    input.setAttribute( "name", "t" );
  
    div.appendChild( input );
  
    // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
  
    // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
  
    // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.
    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  } )();
  
  
  // We have to close these tags to support XHTML (trac-13200)
  var wrapMap = {
  
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [ 1, "<table>", "</table>" ],
    col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
  
    _default: [ 0, "", "" ]
  };
  
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  
  // Support: IE <=9 only
  if ( !support.option ) {
    wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  }
  
  
  function getAll( context, tag ) {
  
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
    var ret;
  
    if ( typeof context.getElementsByTagName !== "undefined" ) {
      ret = context.getElementsByTagName( tag || "*" );
  
    } else if ( typeof context.querySelectorAll !== "undefined" ) {
      ret = context.querySelectorAll( tag || "*" );
  
    } else {
      ret = [];
    }
  
    if ( tag === undefined || tag && nodeName( context, tag ) ) {
      return jQuery.merge( [ context ], ret );
    }
  
    return ret;
  }
  
  
  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
    var i = 0,
      l = elems.length;
  
    for ( ; i < l; i++ ) {
      dataPriv.set(
        elems[ i ],
        "globalEval",
        !refElements || dataPriv.get( refElements[ i ], "globalEval" )
      );
    }
  }
  
  
  var rhtml = /<|&#?\w+;/;
  
  function buildFragment( elems, context, scripts, selection, ignored ) {
    var elem, tmp, tag, wrap, attached, j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;
  
    for ( ; i < l; i++ ) {
      elem = elems[ i ];
  
      if ( elem || elem === 0 ) {
  
        // Add nodes directly
        if ( toType( elem ) === "object" ) {
  
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
  
        // Convert non-html into a text node
        } else if ( !rhtml.test( elem ) ) {
          nodes.push( context.createTextNode( elem ) );
  
        // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
  
          // Deserialize a standard representation
          tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
          wrap = wrapMap[ tag ] || wrapMap._default;
          tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
  
          // Descend through wrappers to the right content
          j = wrap[ 0 ];
          while ( j-- ) {
            tmp = tmp.lastChild;
          }
  
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge( nodes, tmp.childNodes );
  
          // Remember the top-level container
          tmp = fragment.firstChild;
  
          // Ensure the created nodes are orphaned (trac-12392)
          tmp.textContent = "";
        }
      }
    }
  
    // Remove wrapper from fragment
    fragment.textContent = "";
  
    i = 0;
    while ( ( elem = nodes[ i++ ] ) ) {
  
      // Skip elements already in the context collection (trac-4087)
      if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
        if ( ignored ) {
          ignored.push( elem );
        }
        continue;
      }
  
      attached = isAttached( elem );
  
      // Append to fragment
      tmp = getAll( fragment.appendChild( elem ), "script" );
  
      // Preserve script evaluation history
      if ( attached ) {
        setGlobalEval( tmp );
      }
  
      // Capture executables
      if ( scripts ) {
        j = 0;
        while ( ( elem = tmp[ j++ ] ) ) {
          if ( rscriptType.test( elem.type || "" ) ) {
            scripts.push( elem );
          }
        }
      }
    }
  
    return fragment;
  }
  
  
  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  
  function returnTrue() {
    return true;
  }
  
  function returnFalse() {
    return false;
  }
  
  // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).
  function expectSync( elem, type ) {
    return ( elem === safeActiveElement() ) === ( type === "focus" );
  }
  
  // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch ( err ) { }
  }
  
  function on( elem, types, selector, data, fn, one ) {
    var origFn, type;
  
    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
  
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) {
  
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for ( type in types ) {
        on( elem, type, selector, data, types[ type ], one );
      }
      return elem;
    }
  
    if ( data == null && fn == null ) {
  
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
  
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
  
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return elem;
    }
  
    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
  
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
  
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return elem.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    } );
  }
  
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {
  
    global: {},
  
    add: function( elem, types, handler, data, selector ) {
  
      var handleObjIn, eventHandle, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = dataPriv.get( elem );
  
      // Only attach events to objects that accept data
      if ( !acceptData( elem ) ) {
        return;
      }
  
      // Caller can pass in an object of custom data in lieu of the handler
      if ( handler.handler ) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
  
      // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)
      if ( selector ) {
        jQuery.find.matchesSelector( documentElement, selector );
      }
  
      // Make sure that the handler has a unique ID, used to find/remove it later
      if ( !handler.guid ) {
        handler.guid = jQuery.guid++;
      }
  
      // Init the element's event structure and main handler, if this is the first
      if ( !( events = elemData.events ) ) {
        events = elemData.events = Object.create( null );
      }
      if ( !( eventHandle = elemData.handle ) ) {
        eventHandle = elemData.handle = function( e ) {
  
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, arguments ) : undefined;
        };
      }
  
      // Handle multiple events separated by a space
      types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
      t = types.length;
      while ( t-- ) {
        tmp = rtypenamespace.exec( types[ t ] ) || [];
        type = origType = tmp[ 1 ];
        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
  
        // There *must* be a type, no attaching namespace-only handlers
        if ( !type ) {
          continue;
        }
  
        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[ type ] || {};
  
        // If selector defined, determine special event api type, otherwise given type
        type = ( selector ? special.delegateType : special.bindType ) || type;
  
        // Update special based on newly reset type
        special = jQuery.event.special[ type ] || {};
  
        // handleObj is passed to all event handlers
        handleObj = jQuery.extend( {
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
          namespace: namespaces.join( "." )
        }, handleObjIn );
  
        // Init the event handler queue if we're the first
        if ( !( handlers = events[ type ] ) ) {
          handlers = events[ type ] = [];
          handlers.delegateCount = 0;
  
          // Only use addEventListener if the special events handler returns false
          if ( !special.setup ||
            special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
  
            if ( elem.addEventListener ) {
              elem.addEventListener( type, eventHandle );
            }
          }
        }
  
        if ( special.add ) {
          special.add.call( elem, handleObj );
  
          if ( !handleObj.handler.guid ) {
            handleObj.handler.guid = handler.guid;
          }
        }
  
        // Add to the element's handler list, delegates in front
        if ( selector ) {
          handlers.splice( handlers.delegateCount++, 0, handleObj );
        } else {
          handlers.push( handleObj );
        }
  
        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[ type ] = true;
      }
  
    },
  
    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {
  
      var j, origCount, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
  
      if ( !elemData || !( events = elemData.events ) ) {
        return;
      }
  
      // Once for each type.namespace in types; type may be omitted
      types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
      t = types.length;
      while ( t-- ) {
        tmp = rtypenamespace.exec( types[ t ] ) || [];
        type = origType = tmp[ 1 ];
        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
  
        // Unbind all events (on this namespace, if provided) for the element
        if ( !type ) {
          for ( type in events ) {
            jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
          }
          continue;
        }
  
        special = jQuery.event.special[ type ] || {};
        type = ( selector ? special.delegateType : special.bindType ) || type;
        handlers = events[ type ] || [];
        tmp = tmp[ 2 ] &&
          new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
  
        // Remove matching events
        origCount = j = handlers.length;
        while ( j-- ) {
          handleObj = handlers[ j ];
  
          if ( ( mappedTypes || origType === handleObj.origType ) &&
            ( !handler || handler.guid === handleObj.guid ) &&
            ( !tmp || tmp.test( handleObj.namespace ) ) &&
            ( !selector || selector === handleObj.selector ||
              selector === "**" && handleObj.selector ) ) {
            handlers.splice( j, 1 );
  
            if ( handleObj.selector ) {
              handlers.delegateCount--;
            }
            if ( special.remove ) {
              special.remove.call( elem, handleObj );
            }
          }
        }
  
        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if ( origCount && !handlers.length ) {
          if ( !special.teardown ||
            special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
  
            jQuery.removeEvent( elem, type, elemData.handle );
          }
  
          delete events[ type ];
        }
      }
  
      // Remove data and the expando if it's no longer used
      if ( jQuery.isEmptyObject( events ) ) {
        dataPriv.remove( elem, "handle events" );
      }
    },
  
    dispatch: function( nativeEvent ) {
  
      var i, j, ret, matched, handleObj, handlerQueue,
        args = new Array( arguments.length ),
  
        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( nativeEvent ),
  
        handlers = (
          dataPriv.get( this, "events" ) || Object.create( null )
        )[ event.type ] || [],
        special = jQuery.event.special[ event.type ] || {};
  
      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[ 0 ] = event;
  
      for ( i = 1; i < arguments.length; i++ ) {
        args[ i ] = arguments[ i ];
      }
  
      event.delegateTarget = this;
  
      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
        return;
      }
  
      // Determine handlers
      handlerQueue = jQuery.event.handlers.call( this, event, handlers );
  
      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
        event.currentTarget = matched.elem;
  
        j = 0;
        while ( ( handleObj = matched.handlers[ j++ ] ) &&
          !event.isImmediatePropagationStopped() ) {
  
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if ( !event.rnamespace || handleObj.namespace === false ||
            event.rnamespace.test( handleObj.namespace ) ) {
  
            event.handleObj = handleObj;
            event.data = handleObj.data;
  
            ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
              handleObj.handler ).apply( matched.elem, args );
  
            if ( ret !== undefined ) {
              if ( ( event.result = ret ) === false ) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
  
      // Call the postDispatch hook for the mapped type
      if ( special.postDispatch ) {
        special.postDispatch.call( this, event );
      }
  
      return event.result;
    },
  
    handlers: function( event, handlers ) {
      var i, handleObj, sel, matchedHandlers, matchedSelectors,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;
  
      // Find delegate handlers
      if ( delegateCount &&
  
        // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType &&
  
        // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !( event.type === "click" && event.button >= 1 ) ) {
  
        for ( ; cur !== this; cur = cur.parentNode || this ) {
  
          // Don't check non-elements (trac-13208)
          // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
          if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
            matchedHandlers = [];
            matchedSelectors = {};
            for ( i = 0; i < delegateCount; i++ ) {
              handleObj = handlers[ i ];
  
              // Don't conflict with Object.prototype properties (trac-13203)
              sel = handleObj.selector + " ";
  
              if ( matchedSelectors[ sel ] === undefined ) {
                matchedSelectors[ sel ] = handleObj.needsContext ?
                  jQuery( sel, this ).index( cur ) > -1 :
                  jQuery.find( sel, this, null, [ cur ] ).length;
              }
              if ( matchedSelectors[ sel ] ) {
                matchedHandlers.push( handleObj );
              }
            }
            if ( matchedHandlers.length ) {
              handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
            }
          }
        }
      }
  
      // Add the remaining (directly-bound) handlers
      cur = this;
      if ( delegateCount < handlers.length ) {
        handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
      }
  
      return handlerQueue;
    },
  
    addProp: function( name, hook ) {
      Object.defineProperty( jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
  
        get: isFunction( hook ) ?
          function() {
            if ( this.originalEvent ) {
              return hook( this.originalEvent );
            }
          } :
          function() {
            if ( this.originalEvent ) {
              return this.originalEvent[ name ];
            }
          },
  
        set: function( value ) {
          Object.defineProperty( this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          } );
        }
      } );
    },
  
    fix: function( originalEvent ) {
      return originalEvent[ jQuery.expando ] ?
        originalEvent :
        new jQuery.Event( originalEvent );
    },
  
    special: {
      load: {
  
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
  
        // Utilize native event to ensure correct state for checkable inputs
        setup: function( data ) {
  
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data;
  
          // Claim the first handler
          if ( rcheckableType.test( el.type ) &&
            el.click && nodeName( el, "input" ) ) {
  
            // dataPriv.set( el, "click", ... )
            leverageNative( el, "click", returnTrue );
          }
  
          // Return false to allow normal processing in the caller
          return false;
        },
        trigger: function( data ) {
  
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data;
  
          // Force setup before triggering a click
          if ( rcheckableType.test( el.type ) &&
            el.click && nodeName( el, "input" ) ) {
  
            leverageNative( el, "click" );
          }
  
          // Return non-false to allow normal event-path propagation
          return true;
        },
  
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function( event ) {
          var target = event.target;
          return rcheckableType.test( target.type ) &&
            target.click && nodeName( target, "input" ) &&
            dataPriv.get( target, "click" ) ||
            nodeName( target, "a" );
        }
      },
  
      beforeunload: {
        postDispatch: function( event ) {
  
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if ( event.result !== undefined && event.originalEvent ) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };
  
  // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.
  function leverageNative( el, type, expectSync ) {
  
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if ( !expectSync ) {
      if ( dataPriv.get( el, type ) === undefined ) {
        jQuery.event.add( el, type, returnTrue );
      }
      return;
    }
  
    // Register the controller as a special universal handler for all event namespaces
    dataPriv.set( el, type, false );
    jQuery.event.add( el, type, {
      namespace: false,
      handler: function( event ) {
        var notAsync, result,
          saved = dataPriv.get( this, type );
  
        if ( ( event.isTrigger & 1 ) && this[ type ] ) {
  
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if ( !saved.length ) {
  
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = slice.call( arguments );
            dataPriv.set( this, type, saved );
  
            // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous
            notAsync = expectSync( this, type );
            this[ type ]();
            result = dataPriv.get( this, type );
            if ( saved !== result || notAsync ) {
              dataPriv.set( this, type, false );
            } else {
              result = {};
            }
            if ( saved !== result ) {
  
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault();
  
              // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.
              return result && result.value;
            }
  
          // If this is an inner synthetic event for an event with a bubbling surrogate
          // (focus or blur), assume that the surrogate already propagated from triggering the
          // native event and prevent that from happening again here.
          // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
          // bubbling surrogate propagates *after* the non-bubbling base), but that seems
          // less bad than duplication.
          } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
            event.stopPropagation();
          }
  
        // If this is a native event triggered above, everything is now in order
        // Fire an inner synthetic event with the original arguments
        } else if ( saved.length ) {
  
          // ...and capture the result
          dataPriv.set( this, type, {
            value: jQuery.event.trigger(
  
              // Support: IE <=9 - 11+
              // Extend with the prototype to reset the above stopImmediatePropagation()
              jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
              saved.slice( 1 ),
              this
            )
          } );
  
          // Abort handling of the native event
          event.stopImmediatePropagation();
        }
      }
    } );
  }
  
  jQuery.removeEvent = function( elem, type, handle ) {
  
    // This "if" is needed for plain objects
    if ( elem.removeEventListener ) {
      elem.removeEventListener( type, handle );
    }
  };
  
  jQuery.Event = function( src, props ) {
  
    // Allow instantiation without the 'new' keyword
    if ( !( this instanceof jQuery.Event ) ) {
      return new jQuery.Event( src, props );
    }
  
    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;
  
      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented ||
          src.defaultPrevented === undefined &&
  
          // Support: Android <=2.3 only
          src.returnValue === false ?
        returnTrue :
        returnFalse;
  
      // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (trac-504, trac-13143)
      this.target = ( src.target && src.target.nodeType === 3 ) ?
        src.target.parentNode :
        src.target;
  
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
  
    // Event type
    } else {
      this.type = src;
    }
  
    // Put explicitly provided properties onto the event object
    if ( props ) {
      jQuery.extend( this, props );
    }
  
    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || Date.now();
  
    // Mark it as fixed
    this[ jQuery.expando ] = true;
  };
  
  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
  
    preventDefault: function() {
      var e = this.originalEvent;
  
      this.isDefaultPrevented = returnTrue;
  
      if ( e && !this.isSimulated ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
  
      this.isPropagationStopped = returnTrue;
  
      if ( e && !this.isSimulated ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
  
      this.isImmediatePropagationStopped = returnTrue;
  
      if ( e && !this.isSimulated ) {
        e.stopImmediatePropagation();
      }
  
      this.stopPropagation();
    }
  };
  
  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each( {
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp );
  
  jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
    jQuery.event.special[ type ] = {
  
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function() {
  
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative( this, type, expectSync );
  
        // Return false to allow normal processing in the caller
        return false;
      },
      trigger: function() {
  
        // Force setup before trigger
        leverageNative( this, type );
  
        // Return non-false to allow normal event-path propagation
        return true;
      },
  
      // Suppress native focus or blur if we're currently inside
      // a leveraged native-event stack
      _default: function( event ) {
        return dataPriv.get( event.target, type );
      },
  
      delegateType: delegateType
    };
  } );
  
  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
      delegateType: fix,
      bindType: fix,
  
      handle: function( event ) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;
  
        // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply( this, arguments );
          event.type = fix;
        }
        return ret;
      }
    };
  } );
  
  jQuery.fn.extend( {
  
    on: function( types, selector, data, fn ) {
      return on( this, types, selector, data, fn );
    },
    one: function( types, selector, data, fn ) {
      return on( this, types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
      var handleObj, type;
      if ( types && types.preventDefault && types.handleObj ) {
  
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery( types.delegateTarget ).off(
          handleObj.namespace ?
            handleObj.origType + "." + handleObj.namespace :
            handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if ( typeof types === "object" ) {
  
        // ( types-object [, selector] )
        for ( type in types ) {
          this.off( type, selector, types[ type ] );
        }
        return this;
      }
      if ( selector === false || typeof selector === "function" ) {
  
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if ( fn === false ) {
        fn = returnFalse;
      }
      return this.each( function() {
        jQuery.event.remove( this, types, fn, selector );
      } );
    }
  } );
  
  
  var
  
    // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
  
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  
    rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
  
  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget( elem, content ) {
    if ( nodeName( elem, "table" ) &&
      nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
  
      return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
    }
  
    return elem;
  }
  
  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
    elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
    return elem;
  }
  function restoreScript( elem ) {
    if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
      elem.type = elem.type.slice( 5 );
    } else {
      elem.removeAttribute( "type" );
    }
  
    return elem;
  }
  
  function cloneCopyEvent( src, dest ) {
    var i, l, type, pdataOld, udataOld, udataCur, events;
  
    if ( dest.nodeType !== 1 ) {
      return;
    }
  
    // 1. Copy private data: events, handlers, etc.
    if ( dataPriv.hasData( src ) ) {
      pdataOld = dataPriv.get( src );
      events = pdataOld.events;
  
      if ( events ) {
        dataPriv.remove( dest, "handle events" );
  
        for ( type in events ) {
          for ( i = 0, l = events[ type ].length; i < l; i++ ) {
            jQuery.event.add( dest, type, events[ type ][ i ] );
          }
        }
      }
    }
  
    // 2. Copy user data
    if ( dataUser.hasData( src ) ) {
      udataOld = dataUser.access( src );
      udataCur = jQuery.extend( {}, udataOld );
  
      dataUser.set( dest, udataCur );
    }
  }
  
  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
    var nodeName = dest.nodeName.toLowerCase();
  
    // Fails to persist the checked state of a cloned checkbox or radio button.
    if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
      dest.checked = src.checked;
  
    // Fails to return the selected option to the default selected state when cloning options
    } else if ( nodeName === "input" || nodeName === "textarea" ) {
      dest.defaultValue = src.defaultValue;
    }
  }
  
  function domManip( collection, args, callback, ignored ) {
  
    // Flatten any nested arrays
    args = flat( args );
  
    var fragment, first, scripts, hasScripts, node, doc,
      i = 0,
      l = collection.length,
      iNoClone = l - 1,
      value = args[ 0 ],
      valueIsFunction = isFunction( value );
  
    // We can't cloneNode fragments that contain checked, in WebKit
    if ( valueIsFunction ||
        ( l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test( value ) ) ) {
      return collection.each( function( index ) {
        var self = collection.eq( index );
        if ( valueIsFunction ) {
          args[ 0 ] = value.call( this, index, self.html() );
        }
        domManip( self, args, callback, ignored );
      } );
    }
  
    if ( l ) {
      fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
      first = fragment.firstChild;
  
      if ( fragment.childNodes.length === 1 ) {
        fragment = first;
      }
  
      // Require either new content or an interest in ignored elements to invoke the callback
      if ( first || ignored ) {
        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
        hasScripts = scripts.length;
  
        // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (trac-8070).
        for ( ; i < l; i++ ) {
          node = fragment;
  
          if ( i !== iNoClone ) {
            node = jQuery.clone( node, true, true );
  
            // Keep references to cloned scripts for later restoration
            if ( hasScripts ) {
  
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge( scripts, getAll( node, "script" ) );
            }
          }
  
          callback.call( collection[ i ], node, i );
        }
  
        if ( hasScripts ) {
          doc = scripts[ scripts.length - 1 ].ownerDocument;
  
          // Reenable scripts
          jQuery.map( scripts, restoreScript );
  
          // Evaluate executable scripts on first document insertion
          for ( i = 0; i < hasScripts; i++ ) {
            node = scripts[ i ];
            if ( rscriptType.test( node.type || "" ) &&
              !dataPriv.access( node, "globalEval" ) &&
              jQuery.contains( doc, node ) ) {
  
              if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {
  
                // Optional AJAX dependency, but won't run scripts if not present
                if ( jQuery._evalUrl && !node.noModule ) {
                  jQuery._evalUrl( node.src, {
                    nonce: node.nonce || node.getAttribute( "nonce" )
                  }, doc );
                }
              } else {
  
                // Unwrap a CDATA section containing script contents. This shouldn't be
                // needed as in XML documents they're already not visible when
                // inspecting element contents and in HTML documents they have no
                // meaning but we're preserving that logic for backwards compatibility.
                // This will be removed completely in 4.0. See gh-4904.
                DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
              }
            }
          }
        }
      }
    }
  
    return collection;
  }
  
  function remove( elem, selector, keepData ) {
    var node,
      nodes = selector ? jQuery.filter( selector, elem ) : elem,
      i = 0;
  
    for ( ; ( node = nodes[ i ] ) != null; i++ ) {
      if ( !keepData && node.nodeType === 1 ) {
        jQuery.cleanData( getAll( node ) );
      }
  
      if ( node.parentNode ) {
        if ( keepData && isAttached( node ) ) {
          setGlobalEval( getAll( node, "script" ) );
        }
        node.parentNode.removeChild( node );
      }
    }
  
    return elem;
  }
  
  jQuery.extend( {
    htmlPrefilter: function( html ) {
      return html;
    },
  
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
      var i, l, srcElements, destElements,
        clone = elem.cloneNode( true ),
        inPage = isAttached( elem );
  
      // Fix IE cloning issues
      if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
          !jQuery.isXMLDoc( elem ) ) {
  
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll( clone );
        srcElements = getAll( elem );
  
        for ( i = 0, l = srcElements.length; i < l; i++ ) {
          fixInput( srcElements[ i ], destElements[ i ] );
        }
      }
  
      // Copy the events from the original to the clone
      if ( dataAndEvents ) {
        if ( deepDataAndEvents ) {
          srcElements = srcElements || getAll( elem );
          destElements = destElements || getAll( clone );
  
          for ( i = 0, l = srcElements.length; i < l; i++ ) {
            cloneCopyEvent( srcElements[ i ], destElements[ i ] );
          }
        } else {
          cloneCopyEvent( elem, clone );
        }
      }
  
      // Preserve script evaluation history
      destElements = getAll( clone, "script" );
      if ( destElements.length > 0 ) {
        setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
      }
  
      // Return the cloned set
      return clone;
    },
  
    cleanData: function( elems ) {
      var data, elem, type,
        special = jQuery.event.special,
        i = 0;
  
      for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
        if ( acceptData( elem ) ) {
          if ( ( data = elem[ dataPriv.expando ] ) ) {
            if ( data.events ) {
              for ( type in data.events ) {
                if ( special[ type ] ) {
                  jQuery.event.remove( elem, type );
  
                // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent( elem, type, data.handle );
                }
              }
            }
  
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[ dataPriv.expando ] = undefined;
          }
          if ( elem[ dataUser.expando ] ) {
  
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[ dataUser.expando ] = undefined;
          }
        }
      }
    }
  } );
  
  jQuery.fn.extend( {
    detach: function( selector ) {
      return remove( this, selector, true );
    },
  
    remove: function( selector ) {
      return remove( this, selector );
    },
  
    text: function( value ) {
      return access( this, function( value ) {
        return value === undefined ?
          jQuery.text( this ) :
          this.empty().each( function() {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
              this.textContent = value;
            }
          } );
      }, null, value, arguments.length );
    },
  
    append: function() {
      return domManip( this, arguments, function( elem ) {
        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
          var target = manipulationTarget( this, elem );
          target.appendChild( elem );
        }
      } );
    },
  
    prepend: function() {
      return domManip( this, arguments, function( elem ) {
        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
          var target = manipulationTarget( this, elem );
          target.insertBefore( elem, target.firstChild );
        }
      } );
    },
  
    before: function() {
      return domManip( this, arguments, function( elem ) {
        if ( this.parentNode ) {
          this.parentNode.insertBefore( elem, this );
        }
      } );
    },
  
    after: function() {
      return domManip( this, arguments, function( elem ) {
        if ( this.parentNode ) {
          this.parentNode.insertBefore( elem, this.nextSibling );
        }
      } );
    },
  
    empty: function() {
      var elem,
        i = 0;
  
      for ( ; ( elem = this[ i ] ) != null; i++ ) {
        if ( elem.nodeType === 1 ) {
  
          // Prevent memory leaks
          jQuery.cleanData( getAll( elem, false ) );
  
          // Remove any remaining nodes
          elem.textContent = "";
        }
      }
  
      return this;
    },
  
    clone: function( dataAndEvents, deepDataAndEvents ) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
  
      return this.map( function() {
        return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
      } );
    },
  
    html: function( value ) {
      return access( this, function( value ) {
        var elem = this[ 0 ] || {},
          i = 0,
          l = this.length;
  
        if ( value === undefined && elem.nodeType === 1 ) {
          return elem.innerHTML;
        }
  
        // See if we can take a shortcut and just use innerHTML
        if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
          !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
  
          value = jQuery.htmlPrefilter( value );
  
          try {
            for ( ; i < l; i++ ) {
              elem = this[ i ] || {};
  
              // Remove element nodes and prevent memory leaks
              if ( elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem, false ) );
                elem.innerHTML = value;
              }
            }
  
            elem = 0;
  
          // If using innerHTML throws an exception, use the fallback method
          } catch ( e ) {}
        }
  
        if ( elem ) {
          this.empty().append( value );
        }
      }, null, value, arguments.length );
    },
  
    replaceWith: function() {
      var ignored = [];
  
      // Make the changes, replacing each non-ignored context element with the new content
      return domManip( this, arguments, function( elem ) {
        var parent = this.parentNode;
  
        if ( jQuery.inArray( this, ignored ) < 0 ) {
          jQuery.cleanData( getAll( this ) );
          if ( parent ) {
            parent.replaceChild( elem, this );
          }
        }
  
      // Force callback invocation
      }, ignored );
    }
  } );
  
  jQuery.each( {
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
      var elems,
        ret = [],
        insert = jQuery( selector ),
        last = insert.length - 1,
        i = 0;
  
      for ( ; i <= last; i++ ) {
        elems = i === last ? this : this.clone( true );
        jQuery( insert[ i ] )[ original ]( elems );
  
        // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit
        push.apply( ret, elems.get() );
      }
  
      return this.pushStack( ret );
    };
  } );
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
  
  var rcustomProp = /^--/;
  
  
  var getStyles = function( elem ) {
  
      // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;
  
      if ( !view || !view.opener ) {
        view = window;
      }
  
      return view.getComputedStyle( elem );
    };
  
  var swap = function( elem, options, callback ) {
    var ret, name,
      old = {};
  
    // Remember the old values, and insert the new ones
    for ( name in options ) {
      old[ name ] = elem.style[ name ];
      elem.style[ name ] = options[ name ];
    }
  
    ret = callback.call( elem );
  
    // Revert the old values
    for ( name in options ) {
      elem.style[ name ] = old[ name ];
    }
  
    return ret;
  };
  
  
  var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );
  
  var whitespace = "[\\x20\\t\\r\\n\\f]";
  
  
  var rtrimCSS = new RegExp(
    "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
    "g"
  );
  
  
  
  
  ( function() {
  
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
  
      // This is a singleton, we need to execute it only once
      if ( !div ) {
        return;
      }
  
      container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
        "margin-top:1px;padding:0;border:0";
      div.style.cssText =
        "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
        "margin:auto;border:1px;padding:1px;" +
        "width:60%;top:1%";
      documentElement.appendChild( container ).appendChild( div );
  
      var divStyle = window.getComputedStyle( div );
      pixelPositionVal = divStyle.top !== "1%";
  
      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
      reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;
  
      // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't
      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;
  
      // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements
      boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;
  
      // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)
      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;
  
      documentElement.removeChild( container );
  
      // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed
      div = null;
    }
  
    function roundPixelMeasures( measure ) {
      return Math.round( parseFloat( measure ) );
    }
  
    var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
      reliableTrDimensionsVal, reliableMarginLeftVal,
      container = document.createElement( "div" ),
      div = document.createElement( "div" );
  
    // Finish early in limited (non-browser) environments
    if ( !div.style ) {
      return;
    }
  
    // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (trac-8908)
    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
  
    jQuery.extend( support, {
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function() {
        computeStyleTests();
        return scrollboxSizeVal;
      },
  
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function() {
        var table, tr, trChild, trStyle;
        if ( reliableTrDimensionsVal == null ) {
          table = document.createElement( "table" );
          tr = document.createElement( "tr" );
          trChild = document.createElement( "div" );
  
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid";
  
          // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.
          tr.style.height = "1px";
          trChild.style.height = "9px";
  
          // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.
          trChild.style.display = "block";
  
          documentElement
            .appendChild( table )
            .appendChild( tr )
            .appendChild( trChild );
  
          trStyle = window.getComputedStyle( tr );
          reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
            parseInt( trStyle.borderTopWidth, 10 ) +
            parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;
  
          documentElement.removeChild( table );
        }
        return reliableTrDimensionsVal;
      }
    } );
  } )();
  
  
  function curCSS( elem, name, computed ) {
    var width, minWidth, maxWidth, ret,
      isCustomProp = rcustomProp.test( name ),
  
      // Support: Firefox 51+
      // Retrieving style before computed somehow
      // fixes an issue with getting wrong values
      // on detached elements
      style = elem.style;
  
    computed = computed || getStyles( elem );
  
    // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, trac-12537)
    //   .css('--customProperty) (gh-3144)
    if ( computed ) {
  
      // Support: IE <=9 - 11+
      // IE only supports `"float"` in `getPropertyValue`; in computed styles
      // it's only available as `"cssFloat"`. We no longer modify properties
      // sent to `.css()` apart from camelCasing, so we need to check both.
      // Normally, this would create difference in behavior: if
      // `getPropertyValue` returns an empty string, the value returned
      // by `.css()` would be `undefined`. This is usually the case for
      // disconnected elements. However, in IE even disconnected elements
      // with no styles return `"none"` for `getPropertyValue( "float" )`
      ret = computed.getPropertyValue( name ) || computed[ name ];
  
      if ( isCustomProp && ret ) {
  
        // Support: Firefox 105+, Chrome <=105+
        // Spec requires trimming whitespace for custom properties (gh-4926).
        // Firefox only trims leading whitespace. Chrome just collapses
        // both leading & trailing whitespace to a single space.
        //
        // Fall back to `undefined` if empty string returned.
        // This collapses a missing definition with property defined
        // and set to an empty string but there's no standard API
        // allowing us to differentiate them without a performance penalty
        // and returning `undefined` aligns with older jQuery.
        //
        // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
        // as whitespace while CSS does not, but this is not a problem
        // because CSS preprocessing replaces them with U+000A LINE FEED
        // (which *is* CSS whitespace)
        // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
        ret = ret.replace( rtrimCSS, "$1" ) || undefined;
      }
  
      if ( ret === "" && !isAttached( elem ) ) {
        ret = jQuery.style( elem, name );
      }
  
      // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values
      if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {
  
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
  
        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
  
        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
  
    return ret !== undefined ?
  
      // Support: IE <=9 - 11 only
      // IE returns zIndex value as an integer.
      ret + "" :
      ret;
  }
  
  
  function addGetHookIf( conditionFn, hookFn ) {
  
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function() {
        if ( conditionFn() ) {
  
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }
  
        // Hook needed; redefine it so that the support test is not executed again.
        return ( this.get = hookFn ).apply( this, arguments );
      }
    };
  }
  
  
  var cssPrefixes = [ "Webkit", "Moz", "ms" ],
    emptyStyle = document.createElement( "div" ).style,
    vendorProps = {};
  
  // Return a vendor-prefixed property or undefined
  function vendorPropName( name ) {
  
    // Check for vendor prefixed names
    var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
      i = cssPrefixes.length;
  
    while ( i-- ) {
      name = cssPrefixes[ i ] + capName;
      if ( name in emptyStyle ) {
        return name;
      }
    }
  }
  
  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  function finalPropName( name ) {
    var final = jQuery.cssProps[ name ] || vendorProps[ name ];
  
    if ( final ) {
      return final;
    }
    if ( name in emptyStyle ) {
      return name;
    }
    return vendorProps[ name ] = vendorPropName( name ) || name;
  }
  
  
  var
  
    // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
  
  function setPositiveNumber( _elem, value, subtract ) {
  
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec( value );
    return matches ?
  
      // Guard against undefined "subtract", e.g., when used as in cssHooks
      Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
      value;
  }
  
  function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
    var i = dimension === "width" ? 1 : 0,
      extra = 0,
      delta = 0;
  
    // Adjustment may not be necessary
    if ( box === ( isBorderBox ? "border" : "content" ) ) {
      return 0;
    }
  
    for ( ; i < 4; i += 2 ) {
  
      // Both box models exclude margin
      if ( box === "margin" ) {
        delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
      }
  
      // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
      if ( !isBorderBox ) {
  
        // Add padding
        delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  
        // For "border" or "margin", add border
        if ( box !== "padding" ) {
          delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  
        // But still keep track of it otherwise
        } else {
          extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
        }
  
      // If we get here with a border-box (content + padding + border), we're seeking "content" or
      // "padding" or "margin"
      } else {
  
        // For "content", subtract padding
        if ( box === "content" ) {
          delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
        }
  
        // For "content" or "padding", subtract border
        if ( box !== "margin" ) {
          delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
        }
      }
    }
  
    // Account for positive content-box scroll gutter when requested by providing computedVal
    if ( !isBorderBox && computedVal >= 0 ) {
  
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max( 0, Math.ceil(
        elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
        computedVal -
        delta -
        extra -
        0.5
  
      // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      ) ) || 0;
    }
  
    return delta;
  }
  
  function getWidthOrHeight( elem, dimension, extra ) {
  
    // Start with computed style
    var styles = getStyles( elem ),
  
      // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
      // Fake content-box until we know it's needed to know the true value.
      boxSizingNeeded = !support.boxSizingReliable() || extra,
      isBorderBox = boxSizingNeeded &&
        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
      valueIsBorderBox = isBorderBox,
  
      val = curCSS( elem, dimension, styles ),
      offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );
  
    // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.
    if ( rnumnonpx.test( val ) ) {
      if ( !extra ) {
        return val;
      }
      val = "auto";
    }
  
  
    // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.
    if ( ( !support.boxSizingReliable() && isBorderBox ||
  
      // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName( elem, "tr" ) ||
  
      // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" ||
  
      // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
  
      // Make sure the element is visible & connected
      elem.getClientRects().length ) {
  
      isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
  
      // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.
      valueIsBorderBox = offsetProp in elem;
      if ( valueIsBorderBox ) {
        val = elem[ offsetProp ];
      }
    }
  
    // Normalize "" and auto
    val = parseFloat( val ) || 0;
  
    // Adjust for the element's box model
    return ( val +
      boxModelAdjustment(
        elem,
        dimension,
        extra || ( isBorderBox ? "border" : "content" ),
        valueIsBorderBox,
        styles,
  
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
      )
    ) + "px";
  }
  
  jQuery.extend( {
  
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function( elem, computed ) {
          if ( computed ) {
  
            // We should always get a number back from opacity
            var ret = curCSS( elem, "opacity" );
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
  
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
  
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
  
    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
  
      // Don't set styles on text and comment nodes
      if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
        return;
      }
  
      // Make sure that we're working with the right name
      var ret, type, hooks,
        origName = camelCase( name ),
        isCustomProp = rcustomProp.test( name ),
        style = elem.style;
  
      // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.
      if ( !isCustomProp ) {
        name = finalPropName( origName );
      }
  
      // Gets hook for the prefixed version, then unprefixed version
      hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
  
      // Check if we're setting a value
      if ( value !== undefined ) {
        type = typeof value;
  
        // Convert "+=" or "-=" to relative numbers (trac-7345)
        if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
          value = adjustCSS( elem, name, ret );
  
          // Fixes bug trac-9237
          type = "number";
        }
  
        // Make sure that null and NaN values aren't set (trac-7116)
        if ( value == null || value !== value ) {
          return;
        }
  
        // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.
        if ( type === "number" && !isCustomProp ) {
          value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
        }
  
        // background-* props affect original clone's values
        if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
          style[ name ] = "inherit";
        }
  
        // If a hook was provided, use that value, otherwise just set the specified value
        if ( !hooks || !( "set" in hooks ) ||
          ( value = hooks.set( elem, value, extra ) ) !== undefined ) {
  
          if ( isCustomProp ) {
            style.setProperty( name, value );
          } else {
            style[ name ] = value;
          }
        }
  
      } else {
  
        // If a hook was provided get the non-computed value from there
        if ( hooks && "get" in hooks &&
          ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
  
          return ret;
        }
  
        // Otherwise just get the value from the style object
        return style[ name ];
      }
    },
  
    css: function( elem, name, extra, styles ) {
      var val, num, hooks,
        origName = camelCase( name ),
        isCustomProp = rcustomProp.test( name );
  
      // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.
      if ( !isCustomProp ) {
        name = finalPropName( origName );
      }
  
      // Try prefixed name followed by the unprefixed name
      hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
  
      // If a hook was provided get the computed value from there
      if ( hooks && "get" in hooks ) {
        val = hooks.get( elem, true, extra );
      }
  
      // Otherwise, if a way to get the computed value exists, use that
      if ( val === undefined ) {
        val = curCSS( elem, name, styles );
      }
  
      // Convert "normal" to computed value
      if ( val === "normal" && name in cssNormalTransform ) {
        val = cssNormalTransform[ name ];
      }
  
      // Make numeric if forced or a qualifier was provided and val looks numeric
      if ( extra === "" || extra ) {
        num = parseFloat( val );
        return extra === true || isFinite( num ) ? num || 0 : val;
      }
  
      return val;
    }
  } );
  
  jQuery.each( [ "height", "width" ], function( _i, dimension ) {
    jQuery.cssHooks[ dimension ] = {
      get: function( elem, computed, extra ) {
        if ( computed ) {
  
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
  
            // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
            swap( elem, cssShow, function() {
              return getWidthOrHeight( elem, dimension, extra );
            } ) :
            getWidthOrHeight( elem, dimension, extra );
        }
      },
  
      set: function( elem, value, extra ) {
        var matches,
          styles = getStyles( elem ),
  
          // Only read styles.position if the test has a chance to fail
          // to avoid forcing a reflow.
          scrollboxSizeBuggy = !support.scrollboxSize() &&
            styles.position === "absolute",
  
          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
          boxSizingNeeded = scrollboxSizeBuggy || extra,
          isBorderBox = boxSizingNeeded &&
            jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
          subtract = extra ?
            boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) :
            0;
  
        // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)
        if ( isBorderBox && scrollboxSizeBuggy ) {
          subtract -= Math.ceil(
            elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
            parseFloat( styles[ dimension ] ) -
            boxModelAdjustment( elem, dimension, "border", false, styles ) -
            0.5
          );
        }
  
        // Convert to pixels if value adjustment is needed
        if ( subtract && ( matches = rcssNum.exec( value ) ) &&
          ( matches[ 3 ] || "px" ) !== "px" ) {
  
          elem.style[ dimension ] = value;
          value = jQuery.css( elem, dimension );
        }
  
        return setPositiveNumber( elem, value, subtract );
      }
    };
  } );
  
  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
    function( elem, computed ) {
      if ( computed ) {
        return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
          elem.getBoundingClientRect().left -
            swap( elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            } )
        ) + "px";
      }
    }
  );
  
  // These hooks are used by animate to expand properties
  jQuery.each( {
    margin: "",
    padding: "",
    border: "Width"
  }, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
      expand: function( value ) {
        var i = 0,
          expanded = {},
  
          // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split( " " ) : [ value ];
  
        for ( ; i < 4; i++ ) {
          expanded[ prefix + cssExpand[ i ] + suffix ] =
            parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
        }
  
        return expanded;
      }
    };
  
    if ( prefix !== "margin" ) {
      jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
  } );
  
  jQuery.fn.extend( {
    css: function( name, value ) {
      return access( this, function( elem, name, value ) {
        var styles, len,
          map = {},
          i = 0;
  
        if ( Array.isArray( name ) ) {
          styles = getStyles( elem );
          len = name.length;
  
          for ( ; i < len; i++ ) {
            map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
          }
  
          return map;
        }
  
        return value !== undefined ?
          jQuery.style( elem, name, value ) :
          jQuery.css( elem, name );
      }, name, value, arguments.length > 1 );
    }
  } );
  
  
  function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;
  
  Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    },
    cur: function() {
      var hooks = Tween.propHooks[ this.prop ];
  
      return hooks && hooks.get ?
        hooks.get( this ) :
        Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
      var eased,
        hooks = Tween.propHooks[ this.prop ];
  
      if ( this.options.duration ) {
        this.pos = eased = jQuery.easing[ this.easing ](
          percent, this.options.duration * percent, 0, 1, this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = ( this.end - this.start ) * eased + this.start;
  
      if ( this.options.step ) {
        this.options.step.call( this.elem, this.now, this );
      }
  
      if ( hooks && hooks.set ) {
        hooks.set( this );
      } else {
        Tween.propHooks._default.set( this );
      }
      return this;
    }
  };
  
  Tween.prototype.init.prototype = Tween.prototype;
  
  Tween.propHooks = {
    _default: {
      get: function( tween ) {
        var result;
  
        // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.
        if ( tween.elem.nodeType !== 1 ||
          tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
          return tween.elem[ tween.prop ];
        }
  
        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css( tween.elem, tween.prop, "" );
  
        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
      },
      set: function( tween ) {
  
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if ( jQuery.fx.step[ tween.prop ] ) {
          jQuery.fx.step[ tween.prop ]( tween );
        } else if ( tween.elem.nodeType === 1 && (
          jQuery.cssHooks[ tween.prop ] ||
            tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
          jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
        } else {
          tween.elem[ tween.prop ] = tween.now;
        }
      }
    }
  };
  
  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
      if ( tween.elem.nodeType && tween.elem.parentNode ) {
        tween.elem[ tween.prop ] = tween.now;
      }
    }
  };
  
  jQuery.easing = {
    linear: function( p ) {
      return p;
    },
    swing: function( p ) {
      return 0.5 - Math.cos( p * Math.PI ) / 2;
    },
    _default: "swing"
  };
  
  jQuery.fx = Tween.prototype.init;
  
  // Back compat <1.8 extension point
  jQuery.fx.step = {};
  
  
  
  
  var
    fxNow, inProgress,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rrun = /queueHooks$/;
  
  function schedule() {
    if ( inProgress ) {
      if ( document.hidden === false && window.requestAnimationFrame ) {
        window.requestAnimationFrame( schedule );
      } else {
        window.setTimeout( schedule, jQuery.fx.interval );
      }
  
      jQuery.fx.tick();
    }
  }
  
  // Animations created synchronously will run synchronously
  function createFxNow() {
    window.setTimeout( function() {
      fxNow = undefined;
    } );
    return ( fxNow = Date.now() );
  }
  
  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
    var which,
      i = 0,
      attrs = { height: type };
  
    // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for ( ; i < 4; i += 2 - includeWidth ) {
      which = cssExpand[ i ];
      attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    }
  
    if ( includeWidth ) {
      attrs.opacity = attrs.width = type;
    }
  
    return attrs;
  }
  
  function createTween( value, prop, animation ) {
    var tween,
      collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
      index = 0,
      length = collection.length;
    for ( ; index < length; index++ ) {
      if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
  
        // We're done with this property
        return tween;
      }
    }
  }
  
  function defaultPrefilter( elem, props, opts ) {
    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
      isBox = "width" in props || "height" in props,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHiddenWithinTree( elem ),
      dataShow = dataPriv.get( elem, "fxshow" );
  
    // Queue-skipping animations hijack the fx hooks
    if ( !opts.queue ) {
      hooks = jQuery._queueHooks( elem, "fx" );
      if ( hooks.unqueued == null ) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if ( !hooks.unqueued ) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
  
      anim.always( function() {
  
        // Ensure the complete handler is called before this completes
        anim.always( function() {
          hooks.unqueued--;
          if ( !jQuery.queue( elem, "fx" ).length ) {
            hooks.empty.fire();
          }
        } );
      } );
    }
  
    // Detect show/hide animations
    for ( prop in props ) {
      value = props[ prop ];
      if ( rfxtypes.test( value ) ) {
        delete props[ prop ];
        toggle = toggle || value === "toggle";
        if ( value === ( hidden ? "hide" : "show" ) ) {
  
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
            hidden = true;
  
          // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }
        orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
      }
    }
  
    // Bail out if this is a no-op like .hide().hide()
    propTween = !jQuery.isEmptyObject( props );
    if ( !propTween && jQuery.isEmptyObject( orig ) ) {
      return;
    }
  
    // Restrict "overflow" and "display" styles during box animations
    if ( isBox && elem.nodeType === 1 ) {
  
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
  
      // Identify a display type, preferring old show/hide data over the CSS cascade
      restoreDisplay = dataShow && dataShow.display;
      if ( restoreDisplay == null ) {
        restoreDisplay = dataPriv.get( elem, "display" );
      }
      display = jQuery.css( elem, "display" );
      if ( display === "none" ) {
        if ( restoreDisplay ) {
          display = restoreDisplay;
        } else {
  
          // Get nonempty value(s) by temporarily forcing visibility
          showHide( [ elem ], true );
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css( elem, "display" );
          showHide( [ elem ] );
        }
      }
  
      // Animate inline elements as inline-block
      if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
        if ( jQuery.css( elem, "float" ) === "none" ) {
  
          // Restore the original display value at the end of pure show/hide animations
          if ( !propTween ) {
            anim.done( function() {
              style.display = restoreDisplay;
            } );
            if ( restoreDisplay == null ) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
  
    if ( opts.overflow ) {
      style.overflow = "hidden";
      anim.always( function() {
        style.overflow = opts.overflow[ 0 ];
        style.overflowX = opts.overflow[ 1 ];
        style.overflowY = opts.overflow[ 2 ];
      } );
    }
  
    // Implement show/hide animations
    propTween = false;
    for ( prop in orig ) {
  
      // General show/hide setup for this element animation
      if ( !propTween ) {
        if ( dataShow ) {
          if ( "hidden" in dataShow ) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
        }
  
        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
        if ( toggle ) {
          dataShow.hidden = !hidden;
        }
  
        // Show elements before animating them
        if ( hidden ) {
          showHide( [ elem ], true );
        }
  
        /* eslint-disable no-loop-func */
  
        anim.done( function() {
  
          /* eslint-enable no-loop-func */
  
          // The final step of a "hide" animation is actually hiding the element
          if ( !hidden ) {
            showHide( [ elem ] );
          }
          dataPriv.remove( elem, "fxshow" );
          for ( prop in orig ) {
            jQuery.style( elem, prop, orig[ prop ] );
          }
        } );
      }
  
      // Per-property setup
      propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
      if ( !( prop in dataShow ) ) {
        dataShow[ prop ] = propTween.start;
        if ( hidden ) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  
  function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;
  
    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
      name = camelCase( index );
      easing = specialEasing[ name ];
      value = props[ index ];
      if ( Array.isArray( value ) ) {
        easing = value[ 1 ];
        value = props[ index ] = value[ 0 ];
      }
  
      if ( index !== name ) {
        props[ name ] = value;
        delete props[ index ];
      }
  
      hooks = jQuery.cssHooks[ name ];
      if ( hooks && "expand" in hooks ) {
        value = hooks.expand( value );
        delete props[ name ];
  
        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for ( index in value ) {
          if ( !( index in props ) ) {
            props[ index ] = value[ index ];
            specialEasing[ index ] = easing;
          }
        }
      } else {
        specialEasing[ name ] = easing;
      }
    }
  }
  
  function Animation( elem, properties, options ) {
    var result,
      stopped,
      index = 0,
      length = Animation.prefilters.length,
      deferred = jQuery.Deferred().always( function() {
  
        // Don't match elem in the :animated selector
        delete tick.elem;
      } ),
      tick = function() {
        if ( stopped ) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
  
          // Support: Android 2.3 only
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
  
        for ( ; index < length; index++ ) {
          animation.tweens[ index ].run( percent );
        }
  
        deferred.notifyWith( elem, [ animation, percent, remaining ] );
  
        // If there's more to do, yield
        if ( percent < 1 && length ) {
          return remaining;
        }
  
        // If this was an empty animation, synthesize a final progress notification
        if ( !length ) {
          deferred.notifyWith( elem, [ animation, 1, 0 ] );
        }
  
        // Resolve the animation and report its conclusion
        deferred.resolveWith( elem, [ animation ] );
        return false;
      },
      animation = deferred.promise( {
        elem: elem,
        props: jQuery.extend( {}, properties ),
        opts: jQuery.extend( true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options ),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function( prop, end ) {
          var tween = jQuery.Tween( elem, animation.opts, prop, end,
            animation.opts.specialEasing[ prop ] || animation.opts.easing );
          animation.tweens.push( tween );
          return tween;
        },
        stop: function( gotoEnd ) {
          var index = 0,
  
            // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if ( stopped ) {
            return this;
          }
          stopped = true;
          for ( ; index < length; index++ ) {
            animation.tweens[ index ].run( 1 );
          }
  
          // Resolve when we played the last frame; otherwise, reject
          if ( gotoEnd ) {
            deferred.notifyWith( elem, [ animation, 1, 0 ] );
            deferred.resolveWith( elem, [ animation, gotoEnd ] );
          } else {
            deferred.rejectWith( elem, [ animation, gotoEnd ] );
          }
          return this;
        }
      } ),
      props = animation.props;
  
    propFilter( props, animation.opts.specialEasing );
  
    for ( ; index < length; index++ ) {
      result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
      if ( result ) {
        if ( isFunction( result.stop ) ) {
          jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
            result.stop.bind( result );
        }
        return result;
      }
    }
  
    jQuery.map( props, createTween, animation );
  
    if ( isFunction( animation.opts.start ) ) {
      animation.opts.start.call( elem, animation );
    }
  
    // Attach callbacks from options
    animation
      .progress( animation.opts.progress )
      .done( animation.opts.done, animation.opts.complete )
      .fail( animation.opts.fail )
      .always( animation.opts.always );
  
    jQuery.fx.timer(
      jQuery.extend( tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      } )
    );
  
    return animation;
  }
  
  jQuery.Animation = jQuery.extend( Animation, {
  
    tweeners: {
      "*": [ function( prop, value ) {
        var tween = this.createTween( prop, value );
        adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
        return tween;
      } ]
    },
  
    tweener: function( props, callback ) {
      if ( isFunction( props ) ) {
        callback = props;
        props = [ "*" ];
      } else {
        props = props.match( rnothtmlwhite );
      }
  
      var prop,
        index = 0,
        length = props.length;
  
      for ( ; index < length; index++ ) {
        prop = props[ index ];
        Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
        Animation.tweeners[ prop ].unshift( callback );
      }
    },
  
    prefilters: [ defaultPrefilter ],
  
    prefilter: function( callback, prepend ) {
      if ( prepend ) {
        Animation.prefilters.unshift( callback );
      } else {
        Animation.prefilters.push( callback );
      }
    }
  } );
  
  jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
      complete: fn || !fn && easing ||
        isFunction( speed ) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction( easing ) && easing
    };
  
    // Go to the end state if fx are off
    if ( jQuery.fx.off ) {
      opt.duration = 0;
  
    } else {
      if ( typeof opt.duration !== "number" ) {
        if ( opt.duration in jQuery.fx.speeds ) {
          opt.duration = jQuery.fx.speeds[ opt.duration ];
  
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }
  
    // Normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
      opt.queue = "fx";
    }
  
    // Queueing
    opt.old = opt.complete;
  
    opt.complete = function() {
      if ( isFunction( opt.old ) ) {
        opt.old.call( this );
      }
  
      if ( opt.queue ) {
        jQuery.dequeue( this, opt.queue );
      }
    };
  
    return opt;
  };
  
  jQuery.fn.extend( {
    fadeTo: function( speed, to, easing, callback ) {
  
      // Show any hidden elements after setting opacity to 0
      return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
  
        // Animate to the value specified
        .end().animate( { opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
      var empty = jQuery.isEmptyObject( prop ),
        optall = jQuery.speed( speed, easing, callback ),
        doAnimation = function() {
  
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation( this, jQuery.extend( {}, prop ), optall );
  
          // Empty animations, or finishing resolves immediately
          if ( empty || dataPriv.get( this, "finish" ) ) {
            anim.stop( true );
          }
        };
  
      doAnimation.finish = doAnimation;
  
      return empty || optall.queue === false ?
        this.each( doAnimation ) :
        this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
      var stopQueue = function( hooks ) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop( gotoEnd );
      };
  
      if ( typeof type !== "string" ) {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if ( clearQueue ) {
        this.queue( type || "fx", [] );
      }
  
      return this.each( function() {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = dataPriv.get( this );
  
        if ( index ) {
          if ( data[ index ] && data[ index ].stop ) {
            stopQueue( data[ index ] );
          }
        } else {
          for ( index in data ) {
            if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
              stopQueue( data[ index ] );
            }
          }
        }
  
        for ( index = timers.length; index--; ) {
          if ( timers[ index ].elem === this &&
            ( type == null || timers[ index ].queue === type ) ) {
  
            timers[ index ].anim.stop( gotoEnd );
            dequeue = false;
            timers.splice( index, 1 );
          }
        }
  
        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if ( dequeue || !gotoEnd ) {
          jQuery.dequeue( this, type );
        }
      } );
    },
    finish: function( type ) {
      if ( type !== false ) {
        type = type || "fx";
      }
      return this.each( function() {
        var index,
          data = dataPriv.get( this ),
          queue = data[ type + "queue" ],
          hooks = data[ type + "queueHooks" ],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;
  
        // Enable finishing flag on private data
        data.finish = true;
  
        // Empty the queue first
        jQuery.queue( this, type, [] );
  
        if ( hooks && hooks.stop ) {
          hooks.stop.call( this, true );
        }
  
        // Look for any active animations, and finish them
        for ( index = timers.length; index--; ) {
          if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
            timers[ index ].anim.stop( true );
            timers.splice( index, 1 );
          }
        }
  
        // Look for any animations in the old queue and finish them
        for ( index = 0; index < length; index++ ) {
          if ( queue[ index ] && queue[ index ].finish ) {
            queue[ index ].finish.call( this );
          }
        }
  
        // Turn off finishing flag
        delete data.finish;
      } );
    }
  } );
  
  jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
      return speed == null || typeof speed === "boolean" ?
        cssFn.apply( this, arguments ) :
        this.animate( genFx( name, true ), speed, easing, callback );
    };
  } );
  
  // Generate shortcuts for custom animations
  jQuery.each( {
    slideDown: genFx( "show" ),
    slideUp: genFx( "hide" ),
    slideToggle: genFx( "toggle" ),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
      return this.animate( props, speed, easing, callback );
    };
  } );
  
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
      i = 0,
      timers = jQuery.timers;
  
    fxNow = Date.now();
  
    for ( ; i < timers.length; i++ ) {
      timer = timers[ i ];
  
      // Run the timer and safely remove it when done (allowing for external removal)
      if ( !timer() && timers[ i ] === timer ) {
        timers.splice( i--, 1 );
      }
    }
  
    if ( !timers.length ) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  
  jQuery.fx.timer = function( timer ) {
    jQuery.timers.push( timer );
    jQuery.fx.start();
  };
  
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if ( inProgress ) {
      return;
    }
  
    inProgress = true;
    schedule();
  };
  
  jQuery.fx.stop = function() {
    inProgress = null;
  };
  
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
  
    // Default speed
    _default: 400
  };
  
  
  // Based off of the plugin by Clint Helfers, with permission.
  jQuery.fn.delay = function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";
  
    return this.queue( type, function( next, hooks ) {
      var timeout = window.setTimeout( next, time );
      hooks.stop = function() {
        window.clearTimeout( timeout );
      };
    } );
  };
  
  
  ( function() {
    var input = document.createElement( "input" ),
      select = document.createElement( "select" ),
      opt = select.appendChild( document.createElement( "option" ) );
  
    input.type = "checkbox";
  
    // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"
    support.checkOn = input.value !== "";
  
    // Support: IE <=11 only
    // Must access selectedIndex to make default options select
    support.optSelected = opt.selected;
  
    // Support: IE <=11 only
    // An input loses its value after becoming a radio
    input = document.createElement( "input" );
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  } )();
  
  
  var boolHook,
    attrHandle = jQuery.expr.attrHandle;
  
  jQuery.fn.extend( {
    attr: function( name, value ) {
      return access( this, jQuery.attr, name, value, arguments.length > 1 );
    },
  
    removeAttr: function( name ) {
      return this.each( function() {
        jQuery.removeAttr( this, name );
      } );
    }
  } );
  
  jQuery.extend( {
    attr: function( elem, name, value ) {
      var ret, hooks,
        nType = elem.nodeType;
  
      // Don't get/set attributes on text, comment and attribute nodes
      if ( nType === 3 || nType === 8 || nType === 2 ) {
        return;
      }
  
      // Fallback to prop when attributes are not supported
      if ( typeof elem.getAttribute === "undefined" ) {
        return jQuery.prop( elem, name, value );
      }
  
      // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined
      if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
        hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
          ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
      }
  
      if ( value !== undefined ) {
        if ( value === null ) {
          jQuery.removeAttr( elem, name );
          return;
        }
  
        if ( hooks && "set" in hooks &&
          ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
          return ret;
        }
  
        elem.setAttribute( name, value + "" );
        return value;
      }
  
      if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
        return ret;
      }
  
      ret = jQuery.find.attr( elem, name );
  
      // Non-existent attributes return null, we normalize to undefined
      return ret == null ? undefined : ret;
    },
  
    attrHooks: {
      type: {
        set: function( elem, value ) {
          if ( !support.radioValue && value === "radio" &&
            nodeName( elem, "input" ) ) {
            var val = elem.value;
            elem.setAttribute( "type", value );
            if ( val ) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
  
    removeAttr: function( elem, value ) {
      var name,
        i = 0,
  
        // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match( rnothtmlwhite );
  
      if ( attrNames && elem.nodeType === 1 ) {
        while ( ( name = attrNames[ i++ ] ) ) {
          elem.removeAttribute( name );
        }
      }
    }
  } );
  
  // Hooks for boolean attributes
  boolHook = {
    set: function( elem, value, name ) {
      if ( value === false ) {
  
        // Remove boolean attributes when set to false
        jQuery.removeAttr( elem, name );
      } else {
        elem.setAttribute( name, name );
      }
      return name;
    }
  };
  
  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
    var getter = attrHandle[ name ] || jQuery.find.attr;
  
    attrHandle[ name ] = function( elem, name, isXML ) {
      var ret, handle,
        lowercaseName = name.toLowerCase();
  
      if ( !isXML ) {
  
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[ lowercaseName ];
        attrHandle[ lowercaseName ] = ret;
        ret = getter( elem, name, isXML ) != null ?
          lowercaseName :
          null;
        attrHandle[ lowercaseName ] = handle;
      }
      return ret;
    };
  } );
  
  
  
  
  var rfocusable = /^(?:input|select|textarea|button)$/i,
    rclickable = /^(?:a|area)$/i;
  
  jQuery.fn.extend( {
    prop: function( name, value ) {
      return access( this, jQuery.prop, name, value, arguments.length > 1 );
    },
  
    removeProp: function( name ) {
      return this.each( function() {
        delete this[ jQuery.propFix[ name ] || name ];
      } );
    }
  } );
  
  jQuery.extend( {
    prop: function( elem, name, value ) {
      var ret, hooks,
        nType = elem.nodeType;
  
      // Don't get/set properties on text, comment and attribute nodes
      if ( nType === 3 || nType === 8 || nType === 2 ) {
        return;
      }
  
      if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  
        // Fix name and attach hooks
        name = jQuery.propFix[ name ] || name;
        hooks = jQuery.propHooks[ name ];
      }
  
      if ( value !== undefined ) {
        if ( hooks && "set" in hooks &&
          ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
          return ret;
        }
  
        return ( elem[ name ] = value );
      }
  
      if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
        return ret;
      }
  
      return elem[ name ];
    },
  
    propHooks: {
      tabIndex: {
        get: function( elem ) {
  
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // Use proper attribute retrieval (trac-12072)
          var tabindex = jQuery.find.attr( elem, "tabindex" );
  
          if ( tabindex ) {
            return parseInt( tabindex, 10 );
          }
  
          if (
            rfocusable.test( elem.nodeName ) ||
            rclickable.test( elem.nodeName ) &&
            elem.href
          ) {
            return 0;
          }
  
          return -1;
        }
      }
    },
  
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  } );
  
  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if ( !support.optSelected ) {
    jQuery.propHooks.selected = {
      get: function( elem ) {
  
        /* eslint no-unused-expressions: "off" */
  
        var parent = elem.parentNode;
        if ( parent && parent.parentNode ) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function( elem ) {
  
        /* eslint no-unused-expressions: "off" */
  
        var parent = elem.parentNode;
        if ( parent ) {
          parent.selectedIndex;
  
          if ( parent.parentNode ) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  
  jQuery.each( [
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
  ], function() {
    jQuery.propFix[ this.toLowerCase() ] = this;
  } );
  
  
  
  
    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse( value ) {
      var tokens = value.match( rnothtmlwhite ) || [];
      return tokens.join( " " );
    }
  
  
  function getClass( elem ) {
    return elem.getAttribute && elem.getAttribute( "class" ) || "";
  }
  
  function classesToArray( value ) {
    if ( Array.isArray( value ) ) {
      return value;
    }
    if ( typeof value === "string" ) {
      return value.match( rnothtmlwhite ) || [];
    }
    return [];
  }
  
  jQuery.fn.extend( {
    addClass: function( value ) {
      var classNames, cur, curValue, className, i, finalValue;
  
      if ( isFunction( value ) ) {
        return this.each( function( j ) {
          jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
        } );
      }
  
      classNames = classesToArray( value );
  
      if ( classNames.length ) {
        return this.each( function() {
          curValue = getClass( this );
          cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
  
          if ( cur ) {
            for ( i = 0; i < classNames.length; i++ ) {
              className = classNames[ i ];
              if ( cur.indexOf( " " + className + " " ) < 0 ) {
                cur += className + " ";
              }
            }
  
            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse( cur );
            if ( curValue !== finalValue ) {
              this.setAttribute( "class", finalValue );
            }
          }
        } );
      }
  
      return this;
    },
  
    removeClass: function( value ) {
      var classNames, cur, curValue, className, i, finalValue;
  
      if ( isFunction( value ) ) {
        return this.each( function( j ) {
          jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
        } );
      }
  
      if ( !arguments.length ) {
        return this.attr( "class", "" );
      }
  
      classNames = classesToArray( value );
  
      if ( classNames.length ) {
        return this.each( function() {
          curValue = getClass( this );
  
          // This expression is here for better compressibility (see addClass)
          cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
  
          if ( cur ) {
            for ( i = 0; i < classNames.length; i++ ) {
              className = classNames[ i ];
  
              // Remove *all* instances
              while ( cur.indexOf( " " + className + " " ) > -1 ) {
                cur = cur.replace( " " + className + " ", " " );
              }
            }
  
            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse( cur );
            if ( curValue !== finalValue ) {
              this.setAttribute( "class", finalValue );
            }
          }
        } );
      }
  
      return this;
    },
  
    toggleClass: function( value, stateVal ) {
      var classNames, className, i, self,
        type = typeof value,
        isValidValue = type === "string" || Array.isArray( value );
  
      if ( isFunction( value ) ) {
        return this.each( function( i ) {
          jQuery( this ).toggleClass(
            value.call( this, i, getClass( this ), stateVal ),
            stateVal
          );
        } );
      }
  
      if ( typeof stateVal === "boolean" && isValidValue ) {
        return stateVal ? this.addClass( value ) : this.removeClass( value );
      }
  
      classNames = classesToArray( value );
  
      return this.each( function() {
        if ( isValidValue ) {
  
          // Toggle individual class names
          self = jQuery( this );
  
          for ( i = 0; i < classNames.length; i++ ) {
            className = classNames[ i ];
  
            // Check each className given, space separated list
            if ( self.hasClass( className ) ) {
              self.removeClass( className );
            } else {
              self.addClass( className );
            }
          }
  
        // Toggle whole class name
        } else if ( value === undefined || type === "boolean" ) {
          className = getClass( this );
          if ( className ) {
  
            // Store className if set
            dataPriv.set( this, "__className__", className );
          }
  
          // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          if ( this.setAttribute ) {
            this.setAttribute( "class",
              className || value === false ?
                "" :
                dataPriv.get( this, "__className__" ) || ""
            );
          }
        }
      } );
    },
  
    hasClass: function( selector ) {
      var className, elem,
        i = 0;
  
      className = " " + selector + " ";
      while ( ( elem = this[ i++ ] ) ) {
        if ( elem.nodeType === 1 &&
          ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
          return true;
        }
      }
  
      return false;
    }
  } );
  
  
  
  
  var rreturn = /\r/g;
  
  jQuery.fn.extend( {
    val: function( value ) {
      var hooks, ret, valueIsFunction,
        elem = this[ 0 ];
  
      if ( !arguments.length ) {
        if ( elem ) {
          hooks = jQuery.valHooks[ elem.type ] ||
            jQuery.valHooks[ elem.nodeName.toLowerCase() ];
  
          if ( hooks &&
            "get" in hooks &&
            ( ret = hooks.get( elem, "value" ) ) !== undefined
          ) {
            return ret;
          }
  
          ret = elem.value;
  
          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( rreturn, "" );
          }
  
          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;
        }
  
        return;
      }
  
      valueIsFunction = isFunction( value );
  
      return this.each( function( i ) {
        var val;
  
        if ( this.nodeType !== 1 ) {
          return;
        }
  
        if ( valueIsFunction ) {
          val = value.call( this, i, jQuery( this ).val() );
        } else {
          val = value;
        }
  
        // Treat null/undefined as ""; convert numbers to string
        if ( val == null ) {
          val = "";
  
        } else if ( typeof val === "number" ) {
          val += "";
  
        } else if ( Array.isArray( val ) ) {
          val = jQuery.map( val, function( value ) {
            return value == null ? "" : value + "";
          } );
        }
  
        hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
  
        // If set returns undefined, fall back to normal setting
        if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
          this.value = val;
        }
      } );
    }
  } );
  
  jQuery.extend( {
    valHooks: {
      option: {
        get: function( elem ) {
  
          var val = jQuery.find.attr( elem, "value" );
          return val != null ?
            val :
  
            // Support: IE <=10 - 11 only
            // option.text throws exceptions (trac-14686, trac-14858)
            // Strip and collapse whitespace
            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
            stripAndCollapse( jQuery.text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;
  
          if ( index < 0 ) {
            i = max;
  
          } else {
            i = one ? index : 0;
          }
  
          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];
  
            // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (trac-2551)
            if ( ( option.selected || i === index ) &&
  
                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !nodeName( option.parentNode, "optgroup" ) ) ) {
  
              // Get the specific value for the option
              value = jQuery( option ).val();
  
              // We don't need an array for one selects
              if ( one ) {
                return value;
              }
  
              // Multi-Selects return an array
              values.push( value );
            }
          }
  
          return values;
        },
  
        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = jQuery.makeArray( value ),
            i = options.length;
  
          while ( i-- ) {
            option = options[ i ];
  
            /* eslint-disable no-cond-assign */
  
            if ( option.selected =
              jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }
  
            /* eslint-enable no-cond-assign */
          }
  
          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  } );
  
  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
      set: function( elem, value ) {
        if ( Array.isArray( value ) ) {
          return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
        }
      }
    };
    if ( !support.checkOn ) {
      jQuery.valHooks[ this ].get = function( elem ) {
        return elem.getAttribute( "value" ) === null ? "on" : elem.value;
      };
    }
  } );
  
  
  
  
  // Return jQuery for attributes-only inclusion
  
  
  support.focusin = "onfocusin" in window;
  
  
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    stopPropagationCallback = function( e ) {
      e.stopPropagation();
    };
  
  jQuery.extend( jQuery.event, {
  
    trigger: function( event, data, elem, onlyHandlers ) {
  
      var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
        eventPath = [ elem || document ],
        type = hasOwn.call( event, "type" ) ? event.type : event,
        namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
  
      cur = lastElement = tmp = elem = elem || document;
  
      // Don't do events on text and comment nodes
      if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
        return;
      }
  
      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
        return;
      }
  
      if ( type.indexOf( "." ) > -1 ) {
  
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split( "." );
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf( ":" ) < 0 && "on" + type;
  
      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[ jQuery.expando ] ?
        event :
        new jQuery.Event( type, typeof event === "object" && event );
  
      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join( "." );
      event.rnamespace = event.namespace ?
        new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
        null;
  
      // Clean up the event in case it is being reused
      event.result = undefined;
      if ( !event.target ) {
        event.target = elem;
      }
  
      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ?
        [ event ] :
        jQuery.makeArray( data, [ event ] );
  
      // Allow special events to draw outside the lines
      special = jQuery.event.special[ type ] || {};
      if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
        return;
      }
  
      // Determine event propagation path in advance, per W3C events spec (trac-9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
      if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {
  
        bubbleType = special.delegateType || type;
        if ( !rfocusMorph.test( bubbleType + type ) ) {
          cur = cur.parentNode;
        }
        for ( ; cur; cur = cur.parentNode ) {
          eventPath.push( cur );
          tmp = cur;
        }
  
        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if ( tmp === ( elem.ownerDocument || document ) ) {
          eventPath.push( tmp.defaultView || tmp.parentWindow || window );
        }
      }
  
      // Fire handlers on the event path
      i = 0;
      while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
        lastElement = cur;
        event.type = i > 1 ?
          bubbleType :
          special.bindType || type;
  
        // jQuery handler
        handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
          dataPriv.get( cur, "handle" );
        if ( handle ) {
          handle.apply( cur, data );
        }
  
        // Native handler
        handle = ontype && cur[ ontype ];
        if ( handle && handle.apply && acceptData( cur ) ) {
          event.result = handle.apply( cur, data );
          if ( event.result === false ) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
  
      // If nobody prevented the default action, do it now
      if ( !onlyHandlers && !event.isDefaultPrevented() ) {
  
        if ( ( !special._default ||
          special._default.apply( eventPath.pop(), data ) === false ) &&
          acceptData( elem ) ) {
  
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (trac-6170)
          if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {
  
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ ontype ];
  
            if ( tmp ) {
              elem[ ontype ] = null;
            }
  
            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
  
            if ( event.isPropagationStopped() ) {
              lastElement.addEventListener( type, stopPropagationCallback );
            }
  
            elem[ type ]();
  
            if ( event.isPropagationStopped() ) {
              lastElement.removeEventListener( type, stopPropagationCallback );
            }
  
            jQuery.event.triggered = undefined;
  
            if ( tmp ) {
              elem[ ontype ] = tmp;
            }
          }
        }
      }
  
      return event.result;
    },
  
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function( type, elem, event ) {
      var e = jQuery.extend(
        new jQuery.Event(),
        event,
        {
          type: type,
          isSimulated: true
        }
      );
  
      jQuery.event.trigger( e, null, elem );
    }
  
  } );
  
  jQuery.fn.extend( {
  
    trigger: function( type, data ) {
      return this.each( function() {
        jQuery.event.trigger( type, data, this );
      } );
    },
    triggerHandler: function( type, data ) {
      var elem = this[ 0 ];
      if ( elem ) {
        return jQuery.event.trigger( type, data, elem, true );
      }
    }
  } );
  
  
  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if ( !support.focusin ) {
    jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
  
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
      };
  
      jQuery.event.special[ fix ] = {
        setup: function() {
  
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
            attaches = dataPriv.access( doc, fix );
  
          if ( !attaches ) {
            doc.addEventListener( orig, handler, true );
          }
          dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
        },
        teardown: function() {
          var doc = this.ownerDocument || this.document || this,
            attaches = dataPriv.access( doc, fix ) - 1;
  
          if ( !attaches ) {
            doc.removeEventListener( orig, handler, true );
            dataPriv.remove( doc, fix );
  
          } else {
            dataPriv.access( doc, fix, attaches );
          }
        }
      };
    } );
  }
  var location = window.location;
  
  var nonce = { guid: Date.now() };
  
  var rquery = ( /\?/ );
  
  
  
  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
    var xml, parserErrorElem;
    if ( !data || typeof data !== "string" ) {
      return null;
    }
  
    // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.
    try {
      xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
    } catch ( e ) {}
  
    parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
    if ( !xml || parserErrorElem ) {
      jQuery.error( "Invalid XML: " + (
        parserErrorElem ?
          jQuery.map( parserErrorElem.childNodes, function( el ) {
            return el.textContent;
          } ).join( "\n" ) :
          data
      ) );
    }
    return xml;
  };
  
  
  var
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;
  
  function buildParams( prefix, obj, traditional, add ) {
    var name;
  
    if ( Array.isArray( obj ) ) {
  
      // Serialize array item.
      jQuery.each( obj, function( i, v ) {
        if ( traditional || rbracket.test( prefix ) ) {
  
          // Treat each array item as a scalar.
          add( prefix, v );
  
        } else {
  
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(
            prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
            v,
            traditional,
            add
          );
        }
      } );
  
    } else if ( !traditional && toType( obj ) === "object" ) {
  
      // Serialize object item.
      for ( name in obj ) {
        buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
      }
  
    } else {
  
      // Serialize scalar item.
      add( prefix, obj );
    }
  }
  
  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
    var prefix,
      s = [],
      add = function( key, valueOrFunction ) {
  
        // If value is a function, invoke it and use its return value
        var value = isFunction( valueOrFunction ) ?
          valueOrFunction() :
          valueOrFunction;
  
        s[ s.length ] = encodeURIComponent( key ) + "=" +
          encodeURIComponent( value == null ? "" : value );
      };
  
    if ( a == null ) {
      return "";
    }
  
    // If an array was passed in, assume that it is an array of form elements.
    if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
  
      // Serialize the form elements
      jQuery.each( a, function() {
        add( this.name, this.value );
      } );
  
    } else {
  
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for ( prefix in a ) {
        buildParams( prefix, a[ prefix ], traditional, add );
      }
    }
  
    // Return the resulting serialization
    return s.join( "&" );
  };
  
  jQuery.fn.extend( {
    serialize: function() {
      return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
      return this.map( function() {
  
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop( this, "elements" );
        return elements ? jQuery.makeArray( elements ) : this;
      } ).filter( function() {
        var type = this.type;
  
        // Use .is( ":disabled" ) so that fieldset[disabled] works
        return this.name && !jQuery( this ).is( ":disabled" ) &&
          rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
          ( this.checked || !rcheckableType.test( type ) );
      } ).map( function( _i, elem ) {
        var val = jQuery( this ).val();
  
        if ( val == null ) {
          return null;
        }
  
        if ( Array.isArray( val ) ) {
          return jQuery.map( val, function( val ) {
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          } );
        }
  
        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
      } ).get();
    }
  } );
  
  
  var
    r20 = /%20/g,
    rhash = /#.*$/,
    rantiCache = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
  
    // trac-7653, trac-8125, trac-8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
  
    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},
  
    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},
  
    // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
    allTypes = "*/".concat( "*" ),
  
    // Anchor tag for parsing the document origin
    originAnchor = document.createElement( "a" );
  
  originAnchor.href = location.href;
  
  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {
  
    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {
  
      if ( typeof dataTypeExpression !== "string" ) {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
  
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
  
      if ( isFunction( func ) ) {
  
        // For each dataType in the dataTypeExpression
        while ( ( dataType = dataTypes[ i++ ] ) ) {
  
          // Prepend if requested
          if ( dataType[ 0 ] === "+" ) {
            dataType = dataType.slice( 1 ) || "*";
            ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
  
          // Otherwise append
          } else {
            ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
          }
        }
      }
    };
  }
  
  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
  
    var inspected = {},
      seekingTransport = ( structure === transports );
  
    function inspect( dataType ) {
      var selected;
      inspected[ dataType ] = true;
      jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
        var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
        if ( typeof dataTypeOrTransport === "string" &&
          !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
  
          options.dataTypes.unshift( dataTypeOrTransport );
          inspect( dataTypeOrTransport );
          return false;
        } else if ( seekingTransport ) {
          return !( selected = dataTypeOrTransport );
        }
      } );
      return selected;
    }
  
    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }
  
  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes trac-9887
  function ajaxExtend( target, src ) {
    var key, deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};
  
    for ( key in src ) {
      if ( src[ key ] !== undefined ) {
        ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
      }
    }
    if ( deep ) {
      jQuery.extend( true, target, deep );
    }
  
    return target;
  }
  
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {
  
    var ct, type, finalDataType, firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;
  
    // Remove auto dataType and get content-type in the process
    while ( dataTypes[ 0 ] === "*" ) {
      dataTypes.shift();
      if ( ct === undefined ) {
        ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
      }
    }
  
    // Check if we're dealing with a known content-type
    if ( ct ) {
      for ( type in contents ) {
        if ( contents[ type ] && contents[ type ].test( ct ) ) {
          dataTypes.unshift( type );
          break;
        }
      }
    }
  
    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
      finalDataType = dataTypes[ 0 ];
    } else {
  
      // Try convertible dataTypes
      for ( type in responses ) {
        if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
          finalDataType = type;
          break;
        }
        if ( !firstDataType ) {
          firstDataType = type;
        }
      }
  
      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }
  
    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
      if ( finalDataType !== dataTypes[ 0 ] ) {
        dataTypes.unshift( finalDataType );
      }
      return responses[ finalDataType ];
    }
  }
  
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
    var conv2, current, conv, tmp, prev,
      converters = {},
  
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();
  
    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
      for ( conv in s.converters ) {
        converters[ conv.toLowerCase() ] = s.converters[ conv ];
      }
    }
  
    current = dataTypes.shift();
  
    // Convert to each sequential dataType
    while ( current ) {
  
      if ( s.responseFields[ current ] ) {
        jqXHR[ s.responseFields[ current ] ] = response;
      }
  
      // Apply the dataFilter if provided
      if ( !prev && isSuccess && s.dataFilter ) {
        response = s.dataFilter( response, s.dataType );
      }
  
      prev = current;
      current = dataTypes.shift();
  
      if ( current ) {
  
        // There's only work to do if current dataType is non-auto
        if ( current === "*" ) {
  
          current = prev;
  
        // Convert response if prev dataType is non-auto and differs from current
        } else if ( prev !== "*" && prev !== current ) {
  
          // Seek a direct converter
          conv = converters[ prev + " " + current ] || converters[ "* " + current ];
  
          // If none found, seek a pair
          if ( !conv ) {
            for ( conv2 in converters ) {
  
              // If conv2 outputs current
              tmp = conv2.split( " " );
              if ( tmp[ 1 ] === current ) {
  
                // If prev can be converted to accepted input
                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                  converters[ "* " + tmp[ 0 ] ];
                if ( conv ) {
  
                  // Condense equivalence converters
                  if ( conv === true ) {
                    conv = converters[ conv2 ];
  
                  // Otherwise, insert the intermediate dataType
                  } else if ( converters[ conv2 ] !== true ) {
                    current = tmp[ 0 ];
                    dataTypes.unshift( tmp[ 1 ] );
                  }
                  break;
                }
              }
            }
          }
  
          // Apply converter (if not an equivalence)
          if ( conv !== true ) {
  
            // Unless errors are allowed to bubble, catch and return them
            if ( conv && s.throws ) {
              response = conv( response );
            } else {
              try {
                response = conv( response );
              } catch ( e ) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
  
    return { state: "success", data: response };
  }
  
  jQuery.extend( {
  
    // Counter for holding the number of active queries
    active: 0,
  
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
  
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test( location.protocol ),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
  
      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
  
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
  
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
  
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
  
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
  
        // Convert anything to text
        "* text": String,
  
        // Text to html (true = no transformation)
        "text html": true,
  
        // Evaluate text as a json expression
        "text json": JSON.parse,
  
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
  
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
  
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
      return settings ?
  
        // Building a settings object
        ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
  
        // Extending ajaxSettings
        ajaxExtend( jQuery.ajaxSettings, target );
    },
  
    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),
  
    // Main method
    ajax: function( url, options ) {
  
      // If url is an object, simulate pre-1.5 signature
      if ( typeof url === "object" ) {
        options = url;
        url = undefined;
      }
  
      // Force options to be an object
      options = options || {};
  
      var transport,
  
        // URL without anti-cache param
        cacheURL,
  
        // Response headers
        responseHeadersString,
        responseHeaders,
  
        // timeout handle
        timeoutTimer,
  
        // Url cleanup var
        urlAnchor,
  
        // Request state (becomes false upon send and true upon completion)
        completed,
  
        // To know if global events are to be dispatched
        fireGlobals,
  
        // Loop variable
        i,
  
        // uncached part of the url
        uncached,
  
        // Create the final options object
        s = jQuery.ajaxSetup( {}, options ),
  
        // Callbacks context
        callbackContext = s.context || s,
  
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context &&
          ( callbackContext.nodeType || callbackContext.jquery ) ?
          jQuery( callbackContext ) :
          jQuery.event,
  
        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks( "once memory" ),
  
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
  
        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},
  
        // Default abort message
        strAbort = "canceled",
  
        // Fake xhr
        jqXHR = {
          readyState: 0,
  
          // Builds headers hashtable if needed
          getResponseHeader: function( key ) {
            var match;
            if ( completed ) {
              if ( !responseHeaders ) {
                responseHeaders = {};
                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                  responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
                    ( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
                      .concat( match[ 2 ] );
                }
              }
              match = responseHeaders[ key.toLowerCase() + " " ];
            }
            return match == null ? null : match.join( ", " );
          },
  
          // Raw string
          getAllResponseHeaders: function() {
            return completed ? responseHeadersString : null;
          },
  
          // Caches the header
          setRequestHeader: function( name, value ) {
            if ( completed == null ) {
              name = requestHeadersNames[ name.toLowerCase() ] =
                requestHeadersNames[ name.toLowerCase() ] || name;
              requestHeaders[ name ] = value;
            }
            return this;
          },
  
          // Overrides response content-type header
          overrideMimeType: function( type ) {
            if ( completed == null ) {
              s.mimeType = type;
            }
            return this;
          },
  
          // Status-dependent callbacks
          statusCode: function( map ) {
            var code;
            if ( map ) {
              if ( completed ) {
  
                // Execute the appropriate callbacks
                jqXHR.always( map[ jqXHR.status ] );
              } else {
  
                // Lazy-add the new callbacks in a way that preserves old ones
                for ( code in map ) {
                  statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                }
              }
            }
            return this;
          },
  
          // Cancel the request
          abort: function( statusText ) {
            var finalText = statusText || strAbort;
            if ( transport ) {
              transport.abort( finalText );
            }
            done( 0, finalText );
            return this;
          }
        };
  
      // Attach deferreds
      deferred.promise( jqXHR );
  
      // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (trac-10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ( ( url || s.url || location.href ) + "" )
        .replace( rprotocol, location.protocol + "//" );
  
      // Alias method option to type as per ticket trac-12004
      s.type = options.method || options.type || s.method || s.type;
  
      // Extract dataTypes list
      s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
  
      // A cross-domain request is in order when the origin doesn't match the current origin.
      if ( s.crossDomain == null ) {
        urlAnchor = document.createElement( "a" );
  
        // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/
        try {
          urlAnchor.href = s.url;
  
          // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
            urlAnchor.protocol + "//" + urlAnchor.host;
        } catch ( e ) {
  
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      }
  
      // Convert data if not already a string
      if ( s.data && s.processData && typeof s.data !== "string" ) {
        s.data = jQuery.param( s.data, s.traditional );
      }
  
      // Apply prefilters
      inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
  
      // If request was aborted inside a prefilter, stop there
      if ( completed ) {
        return jqXHR;
      }
  
      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
      fireGlobals = jQuery.event && s.global;
  
      // Watch for a new set of requests
      if ( fireGlobals && jQuery.active++ === 0 ) {
        jQuery.event.trigger( "ajaxStart" );
      }
  
      // Uppercase the type
      s.type = s.type.toUpperCase();
  
      // Determine if request has content
      s.hasContent = !rnoContent.test( s.type );
  
      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation
      cacheURL = s.url.replace( rhash, "" );
  
      // More options handling for requests with no content
      if ( !s.hasContent ) {
  
        // Remember the hash so we can put it back
        uncached = s.url.slice( cacheURL.length );
  
        // If data is available and should be processed, append data to url
        if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
          cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
  
          // trac-9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }
  
        // Add or update anti-cache param if needed
        if ( s.cache === false ) {
          cacheURL = cacheURL.replace( rantiCache, "$1" );
          uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
            uncached;
        }
  
        // Put hash and anti-cache on the URL that will be requested (gh-1732)
        s.url = cacheURL + uncached;
  
      // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if ( s.data && s.processData &&
        ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
        s.data = s.data.replace( r20, "+" );
      }
  
      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if ( s.ifModified ) {
        if ( jQuery.lastModified[ cacheURL ] ) {
          jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
        }
        if ( jQuery.etag[ cacheURL ] ) {
          jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
        }
      }
  
      // Set the correct header, if data is being sent
      if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
        jqXHR.setRequestHeader( "Content-Type", s.contentType );
      }
  
      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
          s.accepts[ s.dataTypes[ 0 ] ] +
            ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
          s.accepts[ "*" ]
      );
  
      // Check for headers option
      for ( i in s.headers ) {
        jqXHR.setRequestHeader( i, s.headers[ i ] );
      }
  
      // Allow custom headers/mimetypes and early abort
      if ( s.beforeSend &&
        ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
  
        // Abort if not done already and return
        return jqXHR.abort();
      }
  
      // Aborting is no longer a cancellation
      strAbort = "abort";
  
      // Install callbacks on deferreds
      completeDeferred.add( s.complete );
      jqXHR.done( s.success );
      jqXHR.fail( s.error );
  
      // Get transport
      transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
  
      // If no transport, we auto-abort
      if ( !transport ) {
        done( -1, "No Transport" );
      } else {
        jqXHR.readyState = 1;
  
        // Send global event
        if ( fireGlobals ) {
          globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
        }
  
        // If request was aborted inside ajaxSend, stop there
        if ( completed ) {
          return jqXHR;
        }
  
        // Timeout
        if ( s.async && s.timeout > 0 ) {
          timeoutTimer = window.setTimeout( function() {
            jqXHR.abort( "timeout" );
          }, s.timeout );
        }
  
        try {
          completed = false;
          transport.send( requestHeaders, done );
        } catch ( e ) {
  
          // Rethrow post-completion exceptions
          if ( completed ) {
            throw e;
          }
  
          // Propagate others as results
          done( -1, e );
        }
      }
  
      // Callback for when everything is done
      function done( status, nativeStatusText, responses, headers ) {
        var isSuccess, success, error, response, modified,
          statusText = nativeStatusText;
  
        // Ignore repeat invocations
        if ( completed ) {
          return;
        }
  
        completed = true;
  
        // Clear timeout if it exists
        if ( timeoutTimer ) {
          window.clearTimeout( timeoutTimer );
        }
  
        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;
  
        // Cache response headers
        responseHeadersString = headers || "";
  
        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;
  
        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;
  
        // Get response data
        if ( responses ) {
          response = ajaxHandleResponses( s, jqXHR, responses );
        }
  
        // Use a noop converter for missing script but not if jsonp
        if ( !isSuccess &&
          jQuery.inArray( "script", s.dataTypes ) > -1 &&
          jQuery.inArray( "json", s.dataTypes ) < 0 ) {
          s.converters[ "text script" ] = function() {};
        }
  
        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert( s, response, jqXHR, isSuccess );
  
        // If successful, handle type chaining
        if ( isSuccess ) {
  
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if ( s.ifModified ) {
            modified = jqXHR.getResponseHeader( "Last-Modified" );
            if ( modified ) {
              jQuery.lastModified[ cacheURL ] = modified;
            }
            modified = jqXHR.getResponseHeader( "etag" );
            if ( modified ) {
              jQuery.etag[ cacheURL ] = modified;
            }
          }
  
          // if no content
          if ( status === 204 || s.type === "HEAD" ) {
            statusText = "nocontent";
  
          // if not modified
          } else if ( status === 304 ) {
            statusText = "notmodified";
  
          // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
  
          // Extract error from statusText and normalize for non-aborts
          error = statusText;
          if ( status || !statusText ) {
            statusText = "error";
            if ( status < 0 ) {
              status = 0;
            }
          }
        }
  
        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = ( nativeStatusText || statusText ) + "";
  
        // Success/Error
        if ( isSuccess ) {
          deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
        } else {
          deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
        }
  
        // Status-dependent callbacks
        jqXHR.statusCode( statusCode );
        statusCode = undefined;
  
        if ( fireGlobals ) {
          globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
            [ jqXHR, s, isSuccess ? success : error ] );
        }
  
        // Complete
        completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
  
        if ( fireGlobals ) {
          globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
  
          // Handle the global AJAX counter
          if ( !( --jQuery.active ) ) {
            jQuery.event.trigger( "ajaxStop" );
          }
        }
      }
  
      return jqXHR;
    },
  
    getJSON: function( url, data, callback ) {
      return jQuery.get( url, data, callback, "json" );
    },
  
    getScript: function( url, callback ) {
      return jQuery.get( url, undefined, callback, "script" );
    }
  } );
  
  jQuery.each( [ "get", "post" ], function( _i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
  
      // Shift arguments if data argument was omitted
      if ( isFunction( data ) ) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
  
      // The url can be an options object (which then must have .url)
      return jQuery.ajax( jQuery.extend( {
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject( url ) && url ) );
    };
  } );
  
  jQuery.ajaxPrefilter( function( s ) {
    var i;
    for ( i in s.headers ) {
      if ( i.toLowerCase() === "content-type" ) {
        s.contentType = s.headers[ i ] || "";
      }
    }
  } );
  
  
  jQuery._evalUrl = function( url, options, doc ) {
    return jQuery.ajax( {
      url: url,
  
      // Make this explicit, since user can override this through ajaxSetup (trac-11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
  
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function() {}
      },
      dataFilter: function( response ) {
        jQuery.globalEval( response, options, doc );
      }
    } );
  };
  
  
  jQuery.fn.extend( {
    wrapAll: function( html ) {
      var wrap;
  
      if ( this[ 0 ] ) {
        if ( isFunction( html ) ) {
          html = html.call( this[ 0 ] );
        }
  
        // The elements to wrap the target around
        wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
  
        if ( this[ 0 ].parentNode ) {
          wrap.insertBefore( this[ 0 ] );
        }
  
        wrap.map( function() {
          var elem = this;
  
          while ( elem.firstElementChild ) {
            elem = elem.firstElementChild;
          }
  
          return elem;
        } ).append( this );
      }
  
      return this;
    },
  
    wrapInner: function( html ) {
      if ( isFunction( html ) ) {
        return this.each( function( i ) {
          jQuery( this ).wrapInner( html.call( this, i ) );
        } );
      }
  
      return this.each( function() {
        var self = jQuery( this ),
          contents = self.contents();
  
        if ( contents.length ) {
          contents.wrapAll( html );
  
        } else {
          self.append( html );
        }
      } );
    },
  
    wrap: function( html ) {
      var htmlIsFunction = isFunction( html );
  
      return this.each( function( i ) {
        jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
      } );
    },
  
    unwrap: function( selector ) {
      this.parent( selector ).not( "body" ).each( function() {
        jQuery( this ).replaceWith( this.childNodes );
      } );
      return this;
    }
  } );
  
  
  jQuery.expr.pseudos.hidden = function( elem ) {
    return !jQuery.expr.pseudos.visible( elem );
  };
  jQuery.expr.pseudos.visible = function( elem ) {
    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  };
  
  
  
  
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch ( e ) {}
  };
  
  var xhrSuccessStatus = {
  
      // File protocol always yields status code 0, assume 200
      0: 200,
  
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();
  
  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  support.ajax = xhrSupported = !!xhrSupported;
  
  jQuery.ajaxTransport( function( options ) {
    var callback, errorCallback;
  
    // Cross domain only allowed if supported through XMLHttpRequest
    if ( support.cors || xhrSupported && !options.crossDomain ) {
      return {
        send: function( headers, complete ) {
          var i,
            xhr = options.xhr();
  
          xhr.open(
            options.type,
            options.url,
            options.async,
            options.username,
            options.password
          );
  
          // Apply custom fields if provided
          if ( options.xhrFields ) {
            for ( i in options.xhrFields ) {
              xhr[ i ] = options.xhrFields[ i ];
            }
          }
  
          // Override mime type if needed
          if ( options.mimeType && xhr.overrideMimeType ) {
            xhr.overrideMimeType( options.mimeType );
          }
  
          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
            headers[ "X-Requested-With" ] = "XMLHttpRequest";
          }
  
          // Set headers
          for ( i in headers ) {
            xhr.setRequestHeader( i, headers[ i ] );
          }
  
          // Callback
          callback = function( type ) {
            return function() {
              if ( callback ) {
                callback = errorCallback = xhr.onload =
                  xhr.onerror = xhr.onabort = xhr.ontimeout =
                    xhr.onreadystatechange = null;
  
                if ( type === "abort" ) {
                  xhr.abort();
                } else if ( type === "error" ) {
  
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if ( typeof xhr.status !== "number" ) {
                    complete( 0, "error" );
                  } else {
                    complete(
  
                      // File: protocol always yields status 0; see trac-8605, trac-14207
                      xhr.status,
                      xhr.statusText
                    );
                  }
                } else {
                  complete(
                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                    xhr.statusText,
  
                    // Support: IE <=9 only
                    // IE9 has no XHR2 but throws on binary (trac-11426)
                    // For XHR2 non-text, let the caller handle it (gh-2498)
                    ( xhr.responseType || "text" ) !== "text"  ||
                    typeof xhr.responseText !== "string" ?
                      { binary: xhr.response } :
                      { text: xhr.responseText },
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };
  
          // Listen to events
          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );
  
          // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts
          if ( xhr.onabort !== undefined ) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
  
              // Check readyState before timeout as it changes
              if ( xhr.readyState === 4 ) {
  
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout( function() {
                  if ( callback ) {
                    errorCallback();
                  }
                } );
              }
            };
          }
  
          // Create the abort callback
          callback = callback( "abort" );
  
          try {
  
            // Do send the request (this may raise an exception)
            xhr.send( options.hasContent && options.data || null );
          } catch ( e ) {
  
            // trac-14683: Only rethrow if this hasn't been notified as an error yet
            if ( callback ) {
              throw e;
            }
          }
        },
  
        abort: function() {
          if ( callback ) {
            callback();
          }
        }
      };
    }
  } );
  
  
  
  
  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter( function( s ) {
    if ( s.crossDomain ) {
      s.contents.script = false;
    }
  } );
  
  // Install script dataType
  jQuery.ajaxSetup( {
    accepts: {
      script: "text/javascript, application/javascript, " +
        "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function( text ) {
        jQuery.globalEval( text );
        return text;
      }
    }
  } );
  
  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter( "script", function( s ) {
    if ( s.cache === undefined ) {
      s.cache = false;
    }
    if ( s.crossDomain ) {
      s.type = "GET";
    }
  } );
  
  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {
  
    // This transport only deals with cross domain or forced-by-attrs requests
    if ( s.crossDomain || s.scriptAttrs ) {
      var script, callback;
      return {
        send: function( _, complete ) {
          script = jQuery( "<script>" )
            .attr( s.scriptAttrs || {} )
            .prop( { charset: s.scriptCharset, src: s.url } )
            .on( "load error", callback = function( evt ) {
              script.remove();
              callback = null;
              if ( evt ) {
                complete( evt.type === "error" ? 404 : 200, evt.type );
              }
            } );
  
          // Use native DOM manipulation to avoid our domManip AJAX trickery
          document.head.appendChild( script[ 0 ] );
        },
        abort: function() {
          if ( callback ) {
            callback();
          }
        }
      };
    }
  } );
  
  
  
  
  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;
  
  // Default jsonp settings
  jQuery.ajaxSetup( {
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
      this[ callback ] = true;
      return callback;
    }
  } );
  
  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
  
    var callbackName, overwritten, responseContainer,
      jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
        "url" :
        typeof s.data === "string" &&
          ( s.contentType || "" )
            .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
          rjsonp.test( s.data ) && "data"
      );
  
    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
  
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
        s.jsonpCallback() :
        s.jsonpCallback;
  
      // Insert callback into url or form data
      if ( jsonProp ) {
        s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
      } else if ( s.jsonp !== false ) {
        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
      }
  
      // Use data converter to retrieve json after script execution
      s.converters[ "script json" ] = function() {
        if ( !responseContainer ) {
          jQuery.error( callbackName + " was not called" );
        }
        return responseContainer[ 0 ];
      };
  
      // Force json dataType
      s.dataTypes[ 0 ] = "json";
  
      // Install callback
      overwritten = window[ callbackName ];
      window[ callbackName ] = function() {
        responseContainer = arguments;
      };
  
      // Clean-up function (fires after converters)
      jqXHR.always( function() {
  
        // If previous value didn't exist - remove it
        if ( overwritten === undefined ) {
          jQuery( window ).removeProp( callbackName );
  
        // Otherwise restore preexisting value
        } else {
          window[ callbackName ] = overwritten;
        }
  
        // Save back as free
        if ( s[ callbackName ] ) {
  
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;
  
          // Save the callback name for future use
          oldCallbacks.push( callbackName );
        }
  
        // Call if it was a function and we have a response
        if ( responseContainer && isFunction( overwritten ) ) {
          overwritten( responseContainer[ 0 ] );
        }
  
        responseContainer = overwritten = undefined;
      } );
  
      // Delegate to script
      return "script";
    }
  } );
  
  
  
  
  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = ( function() {
    var body = document.implementation.createHTMLDocument( "" ).body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  } )();
  
  
  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
    if ( typeof data !== "string" ) {
      return [];
    }
    if ( typeof context === "boolean" ) {
      keepScripts = context;
      context = false;
    }
  
    var base, parsed, scripts;
  
    if ( !context ) {
  
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if ( support.createHTMLDocument ) {
        context = document.implementation.createHTMLDocument( "" );
  
        // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)
        base = context.createElement( "base" );
        base.href = document.location.href;
        context.head.appendChild( base );
      } else {
        context = document;
      }
    }
  
    parsed = rsingleTag.exec( data );
    scripts = !keepScripts && [];
  
    // Single tag
    if ( parsed ) {
      return [ context.createElement( parsed[ 1 ] ) ];
    }
  
    parsed = buildFragment( [ data ], context, scripts );
  
    if ( scripts && scripts.length ) {
      jQuery( scripts ).remove();
    }
  
    return jQuery.merge( [], parsed.childNodes );
  };
  
  
  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
    var selector, type, response,
      self = this,
      off = url.indexOf( " " );
  
    if ( off > -1 ) {
      selector = stripAndCollapse( url.slice( off ) );
      url = url.slice( 0, off );
    }
  
    // If it's a function
    if ( isFunction( params ) ) {
  
      // We assume that it's the callback
      callback = params;
      params = undefined;
  
    // Otherwise, build a param string
    } else if ( params && typeof params === "object" ) {
      type = "POST";
    }
  
    // If we have elements to modify, make the request
    if ( self.length > 0 ) {
      jQuery.ajax( {
        url: url,
  
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      } ).done( function( responseText ) {
  
        // Save response for use in complete callback
        response = arguments;
  
        self.html( selector ?
  
          // If a selector was specified, locate the right elements in a dummy div
          // Exclude scripts to avoid IE 'Permission Denied' errors
          jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
  
          // Otherwise use the full result
          responseText );
  
      // If the request succeeds, this function gets "data", "status", "jqXHR"
      // but they are ignored because response was set above.
      // If it fails, this function gets "jqXHR", "status", "error"
      } ).always( callback && function( jqXHR, status ) {
        self.each( function() {
          callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
        } );
      } );
    }
  
    return this;
  };
  
  
  
  
  jQuery.expr.pseudos.animated = function( elem ) {
    return jQuery.grep( jQuery.timers, function( fn ) {
      return elem === fn.elem;
    } ).length;
  };
  
  
  
  
  jQuery.offset = {
    setOffset: function( elem, options, i ) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
        position = jQuery.css( elem, "position" ),
        curElem = jQuery( elem ),
        props = {};
  
      // Set position first, in-case top/left are set even on static elem
      if ( position === "static" ) {
        elem.style.position = "relative";
      }
  
      curOffset = curElem.offset();
      curCSSTop = jQuery.css( elem, "top" );
      curCSSLeft = jQuery.css( elem, "left" );
      calculatePosition = ( position === "absolute" || position === "fixed" ) &&
        ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
  
      // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed
      if ( calculatePosition ) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
  
      } else {
        curTop = parseFloat( curCSSTop ) || 0;
        curLeft = parseFloat( curCSSLeft ) || 0;
      }
  
      if ( isFunction( options ) ) {
  
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
      }
  
      if ( options.top != null ) {
        props.top = ( options.top - curOffset.top ) + curTop;
      }
      if ( options.left != null ) {
        props.left = ( options.left - curOffset.left ) + curLeft;
      }
  
      if ( "using" in options ) {
        options.using.call( elem, props );
  
      } else {
        curElem.css( props );
      }
    }
  };
  
  jQuery.fn.extend( {
  
    // offset() relates an element's border box to the document origin
    offset: function( options ) {
  
      // Preserve chaining for setter
      if ( arguments.length ) {
        return options === undefined ?
          this :
          this.each( function( i ) {
            jQuery.offset.setOffset( this, options, i );
          } );
      }
  
      var rect, win,
        elem = this[ 0 ];
  
      if ( !elem ) {
        return;
      }
  
      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error
      if ( !elem.getClientRects().length ) {
        return { top: 0, left: 0 };
      }
  
      // Get document-relative position by adding viewport scroll to viewport-relative gBCR
      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
  
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function() {
      if ( !this[ 0 ] ) {
        return;
      }
  
      var offsetParent, offset, doc,
        elem = this[ 0 ],
        parentOffset = { top: 0, left: 0 };
  
      // position:fixed elements are offset from the viewport, which itself always has zero offset
      if ( jQuery.css( elem, "position" ) === "fixed" ) {
  
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
  
      } else {
        offset = this.offset();
  
        // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while ( offsetParent &&
          ( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
          jQuery.css( offsetParent, "position" ) === "static" ) {
  
          offsetParent = offsetParent.parentNode;
        }
        if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {
  
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery( offsetParent ).offset();
          parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
          parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
        }
      }
  
      // Subtract parent offsets and element margins
      return {
        top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
        left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
      };
    },
  
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function() {
      return this.map( function() {
        var offsetParent = this.offsetParent;
  
        while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
          offsetParent = offsetParent.offsetParent;
        }
  
        return offsetParent || documentElement;
      } );
    }
  } );
  
  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    var top = "pageYOffset" === prop;
  
    jQuery.fn[ method ] = function( val ) {
      return access( this, function( elem, method, val ) {
  
        // Coalesce documents and windows
        var win;
        if ( isWindow( elem ) ) {
          win = elem;
        } else if ( elem.nodeType === 9 ) {
          win = elem.defaultView;
        }
  
        if ( val === undefined ) {
          return win ? win[ prop ] : elem[ method ];
        }
  
        if ( win ) {
          win.scrollTo(
            !top ? val : win.pageXOffset,
            top ? val : win.pageYOffset
          );
  
        } else {
          elem[ method ] = val;
        }
      }, method, val, arguments.length );
    };
  } );
  
  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( _i, prop ) {
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
      function( elem, computed ) {
        if ( computed ) {
          computed = curCSS( elem, prop );
  
          // If curCSS returns percentage, fallback to offset
          return rnumnonpx.test( computed ) ?
            jQuery( elem ).position()[ prop ] + "px" :
            computed;
        }
      }
    );
  } );
  
  
  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    jQuery.each( {
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function( defaultExtra, funcName ) {
  
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[ funcName ] = function( margin, value ) {
        var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
          extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
  
        return access( this, function( elem, type, value ) {
          var doc;
  
          if ( isWindow( elem ) ) {
  
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf( "outer" ) === 0 ?
              elem[ "inner" + name ] :
              elem.document.documentElement[ "client" + name ];
          }
  
          // Get document width or height
          if ( elem.nodeType === 9 ) {
            doc = elem.documentElement;
  
            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest
            return Math.max(
              elem.body[ "scroll" + name ], doc[ "scroll" + name ],
              elem.body[ "offset" + name ], doc[ "offset" + name ],
              doc[ "client" + name ]
            );
          }
  
          return value === undefined ?
  
            // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css( elem, type, extra ) :
  
            // Set width or height on the element
            jQuery.style( elem, type, value, extra );
        }, type, chainable ? margin : undefined, chainable );
      };
    } );
  } );
  
  
  jQuery.each( [
    "ajaxStart",
    "ajaxStop",
    "ajaxComplete",
    "ajaxError",
    "ajaxSuccess",
    "ajaxSend"
  ], function( _i, type ) {
    jQuery.fn[ type ] = function( fn ) {
      return this.on( type, fn );
    };
  } );
  
  
  
  
  jQuery.fn.extend( {
  
    bind: function( types, data, fn ) {
      return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
      return this.off( types, null, fn );
    },
  
    delegate: function( selector, types, data, fn ) {
      return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
  
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ?
        this.off( selector, "**" ) :
        this.off( types, selector || "**", fn );
    },
  
    hover: function( fnOver, fnOut ) {
      return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
  } );
  
  jQuery.each(
    ( "blur focus focusin focusout resize scroll click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup contextmenu" ).split( " " ),
    function( _i, name ) {
  
      // Handle event binding
      jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length > 0 ?
          this.on( name, null, data, fn ) :
          this.trigger( name );
      };
    }
  );
  
  
  
  
  // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  // Require that the "whitespace run" starts from a non-whitespace
  // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
  var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
  
  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function( fn, context ) {
    var tmp, args, proxy;
  
    if ( typeof context === "string" ) {
      tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }
  
    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !isFunction( fn ) ) {
      return undefined;
    }
  
    // Simulated bind
    args = slice.call( arguments, 2 );
    proxy = function() {
      return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
    };
  
    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
  
    return proxy;
  };
  
  jQuery.holdReady = function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  
  jQuery.now = Date.now;
  
  jQuery.isNumeric = function( obj ) {
  
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type( obj );
    return ( type === "number" || type === "string" ) &&
  
      // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN( obj - parseFloat( obj ) );
  };
  
  jQuery.trim = function( text ) {
    return text == null ?
      "" :
      ( text + "" ).replace( rtrim, "$1" );
  };
  
  
  
  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
  
  if ( true ) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  
  
  
  
  var
  
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
  
    // Map over the $ in case of overwrite
    _$ = window.$;
  
  jQuery.noConflict = function( deep ) {
    if ( window.$ === jQuery ) {
      window.$ = _$;
    }
  
    if ( deep && window.jQuery === jQuery ) {
      window.jQuery = _jQuery;
    }
  
    return jQuery;
  };
  
  // Expose jQuery and $ identifiers, even in AMD
  // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (trac-13566)
  if ( typeof noGlobal === "undefined" ) {
    window.jQuery = window.$ = jQuery;
  }
  
  
  
  
  return jQuery;
  } );
  
  
  /***/ }),
  
  /***/ "./node_modules/js-datepicker/dist/datepicker.min.js":
  /*!***********************************************************!*\
    !*** ./node_modules/js-datepicker/dist/datepicker.min.js ***!
    \***********************************************************/
  /***/ ((module) => {
  
  !function(e,t){ true?module.exports=t():0}(window,(function(){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);var a=[],r=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],i=["January","February","March","April","May","June","July","August","September","October","November","December"],o={t:"top",r:"right",b:"bottom",l:"left",c:"centered"};function s(){}var l=["click","focusin","keydown","input"];function d(e){l.forEach((function(t){e.addEventListener(t,e===document?L:Y)}))}function c(e){return Array.isArray(e)?e.map(c):"[object Object]"===x(e)?Object.keys(e).reduce((function(t,n){return t[n]=c(e[n]),t}),{}):e}function u(e,t){var n=e.calendar.querySelector(".qs-overlay"),a=n&&!n.classList.contains("qs-hidden");t=t||new Date(e.currentYear,e.currentMonth),e.calendar.innerHTML=[h(t,e,a),f(t,e,a),v(e,a)].join(""),a&&window.requestAnimationFrame((function(){M(!0,e)}))}function h(e,t,n){return['<div class="qs-controls'+(n?" qs-blur":"")+'">','<div class="qs-arrow qs-left"></div>','<div class="qs-month-year'+(t.disableYearOverlay?" qs-disabled-year-overlay":"")+'">','<span class="qs-month">'+t.months[e.getMonth()]+"</span>",'<span class="qs-year">'+e.getFullYear()+"</span>","</div>",'<div class="qs-arrow qs-right"></div>',"</div>"].join("")}function f(e,t,n){var a=t.currentMonth,r=t.currentYear,i=t.dateSelected,o=t.maxDate,s=t.minDate,l=t.showAllDates,d=t.days,c=t.disabledDates,u=t.startDay,h=t.weekendIndices,f=t.events,v=t.getRange?t.getRange():{},m=+v.start,y=+v.end,p=g(new Date(e).setDate(1)),w=p.getDay()-u,D=w<0?7:0;p.setMonth(p.getMonth()+1),p.setDate(0);var b=p.getDate(),q=[],S=D+7*((w+b)/7|0);S+=(w+b)%7?7:0;for(var M=1;M<=S;M++){var E=(M-1)%7,x=d[E],C=M-(w>=0?w:7+w),L=new Date(r,a,C),Y=f[+L],j=C<1||C>b,O=j?C<1?-1:1:0,P=j&&!l,k=P?"":L.getDate(),N=+L==+i,_=E===h[0]||E===h[1],I=m!==y,A="qs-square "+x;Y&&!P&&(A+=" qs-event"),j&&(A+=" qs-outside-current-month"),!l&&j||(A+=" qs-num"),N&&(A+=" qs-active"),(c[+L]||t.disabler(L)||_&&t.noWeekends||s&&+L<+s||o&&+L>+o)&&!P&&(A+=" qs-disabled"),+g(new Date)==+L&&(A+=" qs-current"),+L===m&&y&&I&&(A+=" qs-range-start"),+L>m&&+L<y&&(A+=" qs-range-middle"),+L===y&&m&&I&&(A+=" qs-range-end"),P&&(A+=" qs-empty",k=""),q.push('<div class="'+A+'" data-direction="'+O+'">'+k+"</div>")}var R=d.map((function(e){return'<div class="qs-square qs-day">'+e+"</div>"})).concat(q);return R.unshift('<div class="qs-squares'+(n?" qs-blur":"")+'">'),R.push("</div>"),R.join("")}function v(e,t){var n=e.overlayPlaceholder,a=e.overlayButton;return['<div class="qs-overlay'+(t?"":" qs-hidden")+'">',"<div>",'<input class="qs-overlay-year" placeholder="'+n+'" inputmode="numeric" />','<div class="qs-close">&#10005;</div>',"</div>",'<div class="qs-overlay-month-container">'+e.overlayMonths.map((function(e,t){return'<div class="qs-overlay-month" data-month-num="'+t+'">'+e+"</div>"})).join("")+"</div>",'<div class="qs-submit qs-disabled">'+a+"</div>","</div>"].join("")}function m(e,t,n){var a=t.el,r=t.calendar.querySelector(".qs-active"),i=e.textContent,o=t.sibling;(a.disabled||a.readOnly)&&t.respectDisabledReadOnly||(t.dateSelected=n?void 0:new Date(t.currentYear,t.currentMonth,i),r&&r.classList.remove("qs-active"),n||e.classList.add("qs-active"),p(a,t,n),n||q(t),o&&(y({instance:t,deselect:n}),t.first&&!o.dateSelected&&(o.currentYear=t.currentYear,o.currentMonth=t.currentMonth,o.currentMonthName=t.currentMonthName),u(t),u(o)),t.onSelect(t,n?void 0:new Date(t.dateSelected)))}function y(e){var t=e.instance.first?e.instance:e.instance.sibling,n=t.sibling;t===e.instance?e.deselect?(t.minDate=t.originalMinDate,n.minDate=n.originalMinDate):n.minDate=t.dateSelected:e.deselect?(n.maxDate=n.originalMaxDate,t.maxDate=t.originalMaxDate):t.maxDate=n.dateSelected}function p(e,t,n){if(!t.nonInput)return n?e.value="":t.formatter!==s?t.formatter(e,t.dateSelected,t):void(e.value=t.dateSelected.toDateString())}function w(e,t,n,a){n||a?(n&&(t.currentYear=+n),a&&(t.currentMonth=+a)):(t.currentMonth+=e.contains("qs-right")?1:-1,12===t.currentMonth?(t.currentMonth=0,t.currentYear++):-1===t.currentMonth&&(t.currentMonth=11,t.currentYear--)),t.currentMonthName=t.months[t.currentMonth],u(t),t.onMonthChange(t)}function D(e){if(!e.noPosition){var t=e.position.top,n=e.position.right;if(e.position.centered)return e.calendarContainer.classList.add("qs-centered");var a=e.positionedEl.getBoundingClientRect(),r=e.el.getBoundingClientRect(),i=e.calendarContainer.getBoundingClientRect(),o=r.top-a.top+(t?-1*i.height:r.height)+"px",s=r.left-a.left+(n?r.width-i.width:0)+"px";e.calendarContainer.style.setProperty("top",o),e.calendarContainer.style.setProperty("left",s)}}function b(e){return"[object Date]"===x(e)&&"Invalid Date"!==e.toString()}function g(e){if(b(e)||"number"==typeof e&&!isNaN(e)){var t=new Date(+e);return new Date(t.getFullYear(),t.getMonth(),t.getDate())}}function q(e){e.disabled||!e.calendarContainer.classList.contains("qs-hidden")&&!e.alwaysShow&&("overlay"!==e.defaultView&&M(!0,e),e.calendarContainer.classList.add("qs-hidden"),e.onHide(e))}function S(e){e.disabled||(e.calendarContainer.classList.remove("qs-hidden"),"overlay"===e.defaultView&&M(!1,e),D(e),e.onShow(e))}function M(e,t){var n=t.calendar,a=n.querySelector(".qs-overlay"),r=a.querySelector(".qs-overlay-year"),i=n.querySelector(".qs-controls"),o=n.querySelector(".qs-squares");e?(a.classList.add("qs-hidden"),i.classList.remove("qs-blur"),o.classList.remove("qs-blur"),r.value=""):(a.classList.remove("qs-hidden"),i.classList.add("qs-blur"),o.classList.add("qs-blur"),r.focus())}function E(e,t,n,a){var r=isNaN(+(new Date).setFullYear(t.value||void 0)),i=r?null:t.value;if(13===e.which||13===e.keyCode||"click"===e.type)a?w(null,n,i,a):r||t.classList.contains("qs-disabled")||w(null,n,i);else if(n.calendar.contains(t)){n.calendar.querySelector(".qs-submit").classList[r?"add":"remove"]("qs-disabled")}}function x(e){return{}.toString.call(e)}function C(e){a.forEach((function(t){t!==e&&q(t)}))}function L(e){if(!e.__qs_shadow_dom){var t=e.which||e.keyCode,n=e.type,r=e.target,o=r.classList,s=a.filter((function(e){return e.calendar.contains(r)||e.el===r}))[0],l=s&&s.calendar.contains(r);if(!(s&&s.isMobile&&s.disableMobile))if("click"===n){if(!s)return a.forEach(q);if(s.disabled)return;var d=s.calendar,c=s.calendarContainer,h=s.disableYearOverlay,f=s.nonInput,v=d.querySelector(".qs-overlay-year"),y=!!d.querySelector(".qs-hidden"),p=d.querySelector(".qs-month-year").contains(r),D=r.dataset.monthNum;if(s.noPosition&&!l)(c.classList.contains("qs-hidden")?S:q)(s);else if(o.contains("qs-arrow"))w(o,s);else if(p||o.contains("qs-close"))h||M(!y,s);else if(D)E(e,v,s,D);else{if(o.contains("qs-disabled"))return;if(o.contains("qs-num")){var b=r.textContent,g=+r.dataset.direction,x=new Date(s.currentYear,s.currentMonth+g,b);if(g){s.currentYear=x.getFullYear(),s.currentMonth=x.getMonth(),s.currentMonthName=i[s.currentMonth],u(s);for(var L,Y=s.calendar.querySelectorAll('[data-direction="0"]'),j=0;!L;){var O=Y[j];O.textContent===b&&(L=O),j++}r=L}return void(+x==+s.dateSelected?m(r,s,!0):r.classList.contains("qs-disabled")||m(r,s))}o.contains("qs-submit")?E(e,v,s):f&&r===s.el&&(S(s),C(s))}}else if("focusin"===n&&s)S(s),C(s);else if("keydown"===n&&9===t&&s)q(s);else if("keydown"===n&&s&&!s.disabled){var P=!s.calendar.querySelector(".qs-overlay").classList.contains("qs-hidden");13===t&&P&&l?E(e,r,s):27===t&&P&&l&&M(!0,s)}else if("input"===n){if(!s||!s.calendar.contains(r))return;var k=s.calendar.querySelector(".qs-submit"),N=r.value.split("").reduce((function(e,t){return e||"0"!==t?e+(t.match(/[0-9]/)?t:""):""}),"").slice(0,4);r.value=N,k.classList[4===N.length?"remove":"add"]("qs-disabled")}}}function Y(e){L(e),e.__qs_shadow_dom=!0}function j(e,t){l.forEach((function(n){e.removeEventListener(n,t)}))}function O(){S(this)}function P(){q(this)}function k(e,t){var n=g(e),a=this.currentYear,r=this.currentMonth,i=this.sibling;if(null==e)return this.dateSelected=void 0,p(this.el,this,!0),i&&(y({instance:this,deselect:!0}),u(i)),u(this),this;if(!b(e))throw new Error("`setDate` needs a JavaScript Date object.");if(this.disabledDates[+n]||n<this.minDate||n>this.maxDate)throw new Error("You can't manually set a date that's disabled.");this.dateSelected=n,t&&(this.currentYear=n.getFullYear(),this.currentMonth=n.getMonth(),this.currentMonthName=this.months[n.getMonth()]),p(this.el,this),i&&(y({instance:this}),u(i));var o=a===n.getFullYear()&&r===n.getMonth();return o||t?u(this,n):o||u(this,new Date(a,r,1)),this}function N(e){return I(this,e,!0)}function _(e){return I(this,e)}function I(e,t,n){var a=e.dateSelected,r=e.first,i=e.sibling,o=e.minDate,s=e.maxDate,l=g(t),d=n?"Min":"Max";function c(){return"original"+d+"Date"}function h(){return d.toLowerCase()+"Date"}function f(){return"set"+d}function v(){throw new Error("Out-of-range date passed to "+f())}if(null==t)e[c()]=void 0,i?(i[c()]=void 0,n?(r&&!a||!r&&!i.dateSelected)&&(e.minDate=void 0,i.minDate=void 0):(r&&!i.dateSelected||!r&&!a)&&(e.maxDate=void 0,i.maxDate=void 0)):e[h()]=void 0;else{if(!b(t))throw new Error("Invalid date passed to "+f());i?((r&&n&&l>(a||s)||r&&!n&&l<(i.dateSelected||o)||!r&&n&&l>(i.dateSelected||s)||!r&&!n&&l<(a||o))&&v(),e[c()]=l,i[c()]=l,(n&&(r&&!a||!r&&!i.dateSelected)||!n&&(r&&!i.dateSelected||!r&&!a))&&(e[h()]=l,i[h()]=l)):((n&&l>(a||s)||!n&&l<(a||o))&&v(),e[h()]=l)}return i&&u(i),u(e),e}function A(){var e=this.first?this:this.sibling,t=e.sibling;return{start:e.dateSelected,end:t.dateSelected}}function R(){var e=this.shadowDom,t=this.positionedEl,n=this.calendarContainer,r=this.sibling,i=this;this.inlinePosition&&(a.some((function(e){return e!==i&&e.positionedEl===t}))||t.style.setProperty("position",null));n.remove(),a=a.filter((function(e){return e!==i})),r&&delete r.sibling,a.length||j(document,L);var o=a.some((function(t){return t.shadowDom===e}));for(var s in e&&!o&&j(e,Y),this)delete this[s];a.length||l.forEach((function(e){document.removeEventListener(e,L)}))}function F(e,t){var n=new Date(e);if(!b(n))throw new Error("Invalid date passed to `navigate`");this.currentYear=n.getFullYear(),this.currentMonth=n.getMonth(),u(this),t&&this.onMonthChange(this)}function B(){var e=!this.calendarContainer.classList.contains("qs-hidden"),t=!this.calendarContainer.querySelector(".qs-overlay").classList.contains("qs-hidden");e&&M(t,this)}t.default=function(e,t){var n=function(e,t){var n,l,d=function(e){var t=c(e);t.events&&(t.events=t.events.reduce((function(e,t){if(!b(t))throw new Error('"options.events" must only contain valid JavaScript Date objects.');return e[+g(t)]=!0,e}),{}));["startDate","dateSelected","minDate","maxDate"].forEach((function(e){var n=t[e];if(n&&!b(n))throw new Error('"options.'+e+'" needs to be a valid JavaScript Date object.');t[e]=g(n)}));var n=t.position,i=t.maxDate,l=t.minDate,d=t.dateSelected,u=t.overlayPlaceholder,h=t.overlayButton,f=t.startDay,v=t.id;if(t.startDate=g(t.startDate||d||new Date),t.disabledDates=(t.disabledDates||[]).reduce((function(e,t){var n=+g(t);if(!b(t))throw new Error('You supplied an invalid date to "options.disabledDates".');if(n===+g(d))throw new Error('"disabledDates" cannot contain the same date as "dateSelected".');return e[n]=1,e}),{}),t.hasOwnProperty("id")&&null==v)throw new Error("`id` cannot be `null` or `undefined`");if(null!=v){var m=a.filter((function(e){return e.id===v}));if(m.length>1)throw new Error("Only two datepickers can share an id.");m.length?(t.second=!0,t.sibling=m[0]):t.first=!0}var y=["tr","tl","br","bl","c"].some((function(e){return n===e}));if(n&&!y)throw new Error('"options.position" must be one of the following: tl, tr, bl, br, or c.');function p(e){throw new Error('"dateSelected" in options is '+(e?"less":"greater")+' than "'+(e||"max")+'Date".')}if(t.position=function(e){var t=e[0],n=e[1],a={};a[o[t]]=1,n&&(a[o[n]]=1);return a}(n||"bl"),i<l)throw new Error('"maxDate" in options is less than "minDate".');d&&(l>d&&p("min"),i<d&&p());if(["onSelect","onShow","onHide","onMonthChange","formatter","disabler"].forEach((function(e){"function"!=typeof t[e]&&(t[e]=s)})),["customDays","customMonths","customOverlayMonths"].forEach((function(e,n){var a=t[e],r=n?12:7;if(a){if(!Array.isArray(a)||a.length!==r||a.some((function(e){return"string"!=typeof e})))throw new Error('"'+e+'" must be an array with '+r+" strings.");t[n?n<2?"months":"overlayMonths":"days"]=a}})),f&&f>0&&f<7){var w=(t.customDays||r).slice(),D=w.splice(0,f);t.customDays=w.concat(D),t.startDay=+f,t.weekendIndices=[w.length-1,w.length]}else t.startDay=0,t.weekendIndices=[6,0];"string"!=typeof u&&delete t.overlayPlaceholder;"string"!=typeof h&&delete t.overlayButton;var q=t.defaultView;if(q&&"calendar"!==q&&"overlay"!==q)throw new Error('options.defaultView must either be "calendar" or "overlay".');return t.defaultView=q||"calendar",t}(t||{startDate:g(new Date),position:"bl",defaultView:"calendar"}),u=e;if("string"==typeof u)u="#"===u[0]?document.getElementById(u.slice(1)):document.querySelector(u);else{if("[object ShadowRoot]"===x(u))throw new Error("Using a shadow DOM as your selector is not supported.");for(var h,f=u.parentNode;!h;){var v=x(f);"[object HTMLDocument]"===v?h=!0:"[object ShadowRoot]"===v?(h=!0,n=f,l=f.host):f=f.parentNode}}if(!u)throw new Error("No selector / element found.");if(a.some((function(e){return e.el===u})))throw new Error("A datepicker already exists on that element.");var m=u===document.body,y=n?u.parentElement||n:m?document.body:u.parentElement,w=n?u.parentElement||l:y,D=document.createElement("div"),q=document.createElement("div");D.className="qs-datepicker-container qs-hidden",q.className="qs-datepicker";var M={shadowDom:n,customElement:l,positionedEl:w,el:u,parent:y,nonInput:"INPUT"!==u.nodeName,noPosition:m,position:!m&&d.position,startDate:d.startDate,dateSelected:d.dateSelected,disabledDates:d.disabledDates,minDate:d.minDate,maxDate:d.maxDate,noWeekends:!!d.noWeekends,weekendIndices:d.weekendIndices,calendarContainer:D,calendar:q,currentMonth:(d.startDate||d.dateSelected).getMonth(),currentMonthName:(d.months||i)[(d.startDate||d.dateSelected).getMonth()],currentYear:(d.startDate||d.dateSelected).getFullYear(),events:d.events||{},defaultView:d.defaultView,setDate:k,remove:R,setMin:N,setMax:_,show:O,hide:P,navigate:F,toggleOverlay:B,onSelect:d.onSelect,onShow:d.onShow,onHide:d.onHide,onMonthChange:d.onMonthChange,formatter:d.formatter,disabler:d.disabler,months:d.months||i,days:d.customDays||r,startDay:d.startDay,overlayMonths:d.overlayMonths||(d.months||i).map((function(e){return e.slice(0,3)})),overlayPlaceholder:d.overlayPlaceholder||"4-digit year",overlayButton:d.overlayButton||"Submit",disableYearOverlay:!!d.disableYearOverlay,disableMobile:!!d.disableMobile,isMobile:"ontouchstart"in window,alwaysShow:!!d.alwaysShow,id:d.id,showAllDates:!!d.showAllDates,respectDisabledReadOnly:!!d.respectDisabledReadOnly,first:d.first,second:d.second};if(d.sibling){var E=d.sibling,C=M,L=E.minDate||C.minDate,Y=E.maxDate||C.maxDate;C.sibling=E,E.sibling=C,E.minDate=L,E.maxDate=Y,C.minDate=L,C.maxDate=Y,E.originalMinDate=L,E.originalMaxDate=Y,C.originalMinDate=L,C.originalMaxDate=Y,E.getRange=A,C.getRange=A}d.dateSelected&&p(u,M);var j=getComputedStyle(w).position;m||j&&"static"!==j||(M.inlinePosition=!0,w.style.setProperty("position","relative"));var I=a.filter((function(e){return e.positionedEl===M.positionedEl}));I.some((function(e){return e.inlinePosition}))&&(M.inlinePosition=!0,I.forEach((function(e){e.inlinePosition=!0})));D.appendChild(q),y.appendChild(D),M.alwaysShow&&S(M);return M}(e,t);if(a.length||d(document),n.shadowDom&&(a.some((function(e){return e.shadowDom===n.shadowDom}))||d(n.shadowDom)),a.push(n),n.second){var l=n.sibling;y({instance:n,deselect:!n.dateSelected}),y({instance:l,deselect:!l.dateSelected}),u(l)}return u(n,n.startDate||n.dateSelected),n.alwaysShow&&D(n),n}}]).default}));
  
  /***/ }),
  
  /***/ "./node_modules/orgchart/dist/js/jquery.orgchart.min.js":
  /*!**************************************************************!*\
    !*** ./node_modules/orgchart/dist/js/jquery.orgchart.min.js ***!
    \**************************************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  
  "use strict";
  !function(e){ true&&"object"==typeof module.exports?e(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),window,document):e(jQuery,window,document)}(function(l,h,c,d){function t(e,t){this.$chartContainer=l(e),this.opts=t,this.defaultOptions={icons:{theme:"oci",parentNode:"oci-menu",expandToUp:"oci-chevron-up",collapseToDown:"oci-chevron-down",collapseToLeft:"oci-chevron-left",expandToRight:"oci-chevron-right",collapsed:"oci-plus-square",expanded:"oci-minus-square",spinner:"oci-spinner"},nodeTitle:"name",nodeId:"id",toggleSiblingsResp:!1,visibleLevel:999,chartClass:"",exportButton:!1,exportButtonName:"Export",exportFilename:"OrgChart",exportFileextension:"png",draggable:!1,direction:"t2b",pan:!1,zoom:!1,zoominLimit:7,zoomoutLimit:.5}}t.prototype={init:function(e){var n=this,e=(this.options=l.extend({},this.defaultOptions,this.opts,e),this.$chartContainer),t=(this.$chart&&this.$chart.remove(),this.options.data),i=this.$chart=l("<div>",{data:{options:this.options},class:"orgchart"+(""!==this.options.chartClass?" "+this.options.chartClass:"")+("t2b"!==this.options.direction?" "+this.options.direction:""),click:function(e){l(e.target).closest(".node").length||i.find(".node.focused").removeClass("focused")}}),s=("undefined"!=typeof MutationObserver&&this.triggerInitEvent(),i.append(l('<ul class="nodes"><li class="hierarchy"></li></ul>')).find(".hierarchy"));return"object"===l.type(t)?t instanceof l?this.buildHierarchy(s,this.buildJsonDS(t.children()),0,this.options):this.buildHierarchy(s,this.options.ajaxURL?t:this.attachRel(t,"00")):(i.append(`<i class="${this.options.icons.theme} ${this.options.icons.spinner} spinner"></i>`),l.ajax({url:t,dataType:"json"}).done(function(e,t,i){n.buildHierarchy(s,n.options.ajaxURL?e:n.attachRel(e,"00"),0,n.options)}).fail(function(e,t,i){console.log(i)}).always(function(){i.children(".spinner").remove()})),e.append(i),this.options.exportButton&&!l(".oc-export-btn").length&&this.attachExportButton(),this.options.pan&&this.bindPan(),this.options.zoom&&this.bindZoom(),this},triggerInitEvent:function(){var s=this,o=new MutationObserver(function(e){o.disconnect();e:for(var t=0;t<e.length;t++)for(var i=0;i<e[t].addedNodes.length;i++)if(e[t].addedNodes[i].classList.contains("orgchart")){s.options.initCompleted&&"function"==typeof s.options.initCompleted&&s.options.initCompleted(s.$chart);var n=l.Event("init.orgchart");s.$chart.trigger(n);break e}});o.observe(this.$chartContainer[0],{childList:!0})},triggerLoadEvent:function(e,t){t=l.Event("load-"+t+".orgchart");e.trigger(t)},triggerShowEvent:function(e,t){t=l.Event("show-"+t+".orgchart");e.trigger(t)},triggerHideEvent:function(e,t){t=l.Event("hide-"+t+".orgchart");e.trigger(t)},attachExportButton:function(){var t=this,e=l("<button>",{class:"oc-export-btn",text:this.options.exportButtonName,click:function(e){e.preventDefault(),t.export()}});this.$chartContainer.after(e)},setOptions:function(e,t){return"string"==typeof e&&("pan"===e&&(t?this.bindPan():this.unbindPan()),"zoom"===e)&&(t?this.bindZoom():this.unbindZoom()),"object"==typeof e&&(e.data?this.init(e):(void 0!==e.pan&&(e.pan?this.bindPan():this.unbindPan()),void 0!==e.zoom&&(e.zoom?this.bindZoom():this.unbindZoom()))),this},panStartHandler:function(e){var s=l(e.delegateTarget);if(l(e.target).closest(".node").length||e.touches&&1<e.touches.length)s.data("panning",!1);else{s.css("cursor","move").data("panning",!0);var t,i=0,n=0,o=s.css("transform"),a=("none"!==o&&(t=o.split(","),n=-1===o.indexOf("3d")?(i=parseInt(t[4]),parseInt(t[5])):(i=parseInt(t[12]),parseInt(t[13]))),0),d=0;if(e.targetTouches){if(1===e.targetTouches.length)a=e.targetTouches[0].pageX-i,d=e.targetTouches[0].pageY-n;else if(1<e.targetTouches.length)return}else a=e.pageX-i,d=e.pageY-n;s.on("mousemove touchmove",function(e){if(s.data("panning")){var t=0,i=0;if(e.targetTouches){if(1===e.targetTouches.length)t=e.targetTouches[0].pageX-a,i=e.targetTouches[0].pageY-d;else if(1<e.targetTouches.length)return}else t=e.pageX-a,i=e.pageY-d;var n,e=s.css("transform");"none"===e?-1===e.indexOf("3d")?s.css("transform","matrix(1, 0, 0, 1, "+t+", "+i+")"):s.css("transform","matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, "+t+", "+i+", 0, 1)"):(n=e.split(","),-1===e.indexOf("3d")?(n[4]=" "+t,n[5]=" "+i+")"):(n[12]=" "+t,n[13]=" "+i),s.css("transform",n.join(",")))}})}},panEndHandler:function(e){e.data.chart.data("panning")&&e.data.chart.data("panning",!1).css("cursor","default").off("mousemove")},bindPan:function(){this.$chartContainer.css("overflow","hidden"),this.$chart.on("mousedown touchstart",this.panStartHandler),l(c).on("mouseup touchend",{chart:this.$chart},this.panEndHandler)},unbindPan:function(){this.$chartContainer.css("overflow","auto"),this.$chart.off("mousedown touchstart",this.panStartHandler),l(c).off("mouseup touchend",this.panEndHandler)},zoomWheelHandler:function(e){var t=e.data.oc,e=(e.preventDefault(),1+(0<e.originalEvent.deltaY?-.2:.2));t.setChartScale(t.$chart,e)},zoomStartHandler:function(e){var t;e.touches&&2===e.touches.length&&((t=e.data.oc).$chart.data("pinching",!0),e=t.getPinchDist(e),t.$chart.data("pinchDistStart",e))},zoomingHandler:function(e){var t=e.data.oc;t.$chart.data("pinching")&&(e=t.getPinchDist(e),t.$chart.data("pinchDistEnd",e))},zoomEndHandler:function(e){var t,e=e.data.oc;e.$chart.data("pinching")&&(e.$chart.data("pinching",!1),0<(t=e.$chart.data("pinchDistEnd")-e.$chart.data("pinchDistStart"))?e.setChartScale(e.$chart,1.2):t<0&&e.setChartScale(e.$chart,.8))},bindZoom:function(){this.$chartContainer.on("wheel",{oc:this},this.zoomWheelHandler),this.$chartContainer.on("touchstart",{oc:this},this.zoomStartHandler),l(c).on("touchmove",{oc:this},this.zoomingHandler),l(c).on("touchend",{oc:this},this.zoomEndHandler)},unbindZoom:function(){this.$chartContainer.off("wheel",this.zoomWheelHandler),this.$chartContainer.off("touchstart",this.zoomStartHandler),l(c).off("touchmove",this.zoomingHandler),l(c).off("touchend",this.zoomEndHandler)},getPinchDist:function(e){return Math.sqrt((e.touches[0].clientX-e.touches[1].clientX)*(e.touches[0].clientX-e.touches[1].clientX)+(e.touches[0].clientY-e.touches[1].clientY)*(e.touches[0].clientY-e.touches[1].clientY))},setChartScale:function(e,t){var i,n=e.data("options"),s=e.css("transform"),o=1;"none"===s?e.css("transform","scale("+t+","+t+")"):(i=s.split(","),-1===s.indexOf("3d")?(o=Math.abs(h.parseFloat(i[3])*t))>n.zoomoutLimit&&o<n.zoominLimit&&e.css("transform",s+" scale("+t+","+t+")"):(o=Math.abs(h.parseFloat(i[1])*t))>n.zoomoutLimit&&o<n.zoominLimit&&e.css("transform",s+" scale3d("+t+","+t+", 1)"))},buildJsonDS:function(e){var t=this,i={name:e.contents().eq(0).text().trim(),relationship:(e.parent().parent().is("li")?"1":"0")+(e.siblings("li").length?1:0)+(e.children("ul").length?1:0)};return l.each(e.data(),function(e,t){i[e]=t}),e.children("ul").children().each(function(){i.children||(i.children=[]),i.children.push(t.buildJsonDS(l(this)))}),i},attachRel:function(t,e){var i=this;return t.relationship=e+(t.children&&0<t.children.length?1:0),t.children&&t.children.forEach(function(e){(t.isHybrid||t.isVertical)&&(e.isVertical=!0),i.attachRel(e,"1"+(1<t.children.length?1:0))}),t},loopChart:function(e,t){t=null!==t&&t!==d&&t;var i=this,e=e.find(".node:first"),n={id:e[0].id};return t&&l.each(e.data("nodeData"),function(e,t){n[e]=t}),e.siblings(".nodes").children().each(function(){n.children||(n.children=[]),n.children.push(i.loopChart(l(this),t))}),n},getHierarchy:function(e){var t;return e=null!==e&&e!==d&&e,void 0===this.$chart?"Error: orgchart does not exist":this.$chart.find(".node").length?(t=!0,this.$chart.find(".node").each(function(){if(!this.id)return t=!1}),t?this.loopChart(this.$chart,e):"Error: All nodes of orghcart to be exported must have data-id attribute!"):"Error: nodes do not exist"},getNodeState:function(e,t){var i={},n=!!e.closest("vertical").length;if("parent"===(t=t||"self")){if(n?(i=e.closest("ul").parents("ul")).length||(i=e.closest(".nodes")).length||(i=e.closest(".vertical").siblings(":first")):i=e.closest(".nodes").siblings(".node"),i.length)return i.is(".hidden")||!i.is(".hidden")&&i.closest(".nodes").is(".hidden")||!i.is(".hidden")&&i.closest(".vertical").is(".hidden")?{exist:!0,visible:!1}:{exist:!0,visible:!0}}else if("children"===t){if((i=n?e.parent().children("ul"):e.siblings(".nodes")).length)return i.is(".hidden")?{exist:!0,visible:!1}:{exist:!0,visible:!0}}else if("siblings"===t){if((i=n?e.closest("ul"):e.parent().siblings()).length&&(!n||1<i.children("li").length))return i.is(".hidden")||i.parent().is(".hidden")||n&&i.closest(".vertical").is(".hidden")?{exist:!0,visible:!1}:{exist:!0,visible:!0}}else if((i=e).length)return i.closest(".nodes").length&&i.closest(".nodes").is(".hidden")||i.closest(".hierarchy").length&&i.closest(".hierarchy").is(".hidden")||i.closest(".vertical").length&&(i.closest(".nodes").is(".hidden")||i.closest(".vertical").is(".hidden"))?{exist:!0,visible:!1}:{exist:!0,visible:!0};return{exist:!1,visible:!1}},getParent:function(e){return this.getRelatedNodes(e,"parent")},getChildren:function(e){return this.getRelatedNodes(e,"children")},getSiblings:function(e){return this.getRelatedNodes(e,"siblings")},getRelatedNodes:function(e,t){return e&&e instanceof l&&e.is(".node")?"parent"===t?e.closest(".nodes").siblings(".node"):"children"===t?e.siblings(".nodes").children(".hierarchy").find(".node:first"):"siblings"===t?e.closest(".hierarchy").siblings().find(".node:first"):l():l()},hideParentEnd:function(e){l(e.target).removeClass("sliding"),e.data.parent.addClass("hidden")},hideParent:function(e){var t=e.closest(".nodes").siblings(".node");t.find(".spinner").length&&e.closest(".orgchart").data("inAjax",!1),this.getNodeState(e,"siblings").visible&&this.hideSiblings(e),e.parent().addClass("isAncestorsCollapsed"),this.getNodeState(t).visible&&t.addClass("sliding slide-down").one("transitionend",{parent:t},this.hideParentEnd),this.getNodeState(t,"parent").visible&&this.hideParent(t)},showParentEnd:function(e){var t=e.data.node;l(e.target).removeClass("sliding"),this.isInAction(t)&&this.switchVerticalArrow(t.children(".topEdge"))},showParent:function(e){var t=e.closest(".nodes").siblings(".node").removeClass("hidden");e.closest(".hierarchy").removeClass("isAncestorsCollapsed"),this.repaint(t[0]),t.addClass("sliding").removeClass("slide-down").one("transitionend",{node:e},this.showParentEnd.bind(this))},stopAjax:function(e){e.find(".spinner").length&&e.closest(".orgchart").data("inAjax",!1)},isVisibleNode:function(e,t){return this.getNodeState(l(t)).visible},hideChildrenEnd:function(e){var t=e.data.node;e.data.animatedNodes.removeClass("sliding"),e.data.animatedNodes.closest(".nodes").addClass("hidden"),this.isInAction(t)&&this.switchVerticalArrow(t.children(".bottomEdge"))},hideChildren:function(e){e.closest(".hierarchy").addClass("isChildrenCollapsed");var t=e.siblings(".nodes"),i=(this.stopAjax(t),t.find(".node").filter(this.isVisibleNode.bind(this)));t.is(".vertical")||i.closest(".hierarchy").addClass("isCollapsedDescendant"),(t.is(".vertical")||t.find(".vertical").length)&&i.find(this.options.icons.expanded).removeClass(this.options.icons.expanded).addClass(this.options.icons.collapsed),this.repaint(i.get(0)),i.addClass("sliding slide-up").eq(0).one("transitionend",{animatedNodes:i,lowerLevel:t,node:e},this.hideChildrenEnd.bind(this))},showChildrenEnd:function(e){var t=e.data.node;e.data.animatedNodes.removeClass("sliding"),this.isInAction(t)&&this.switchVerticalArrow(t.children(".bottomEdge"))},showChildren:function(e){e.closest(".hierarchy").removeClass("isChildrenCollapsed");var t=e.siblings(".nodes"),i=t.is(".vertical"),t=(i?t.removeClass("hidden").find(".node"):t.removeClass("hidden").children(".hierarchy").find(".node:first")).filter(this.isVisibleNode.bind(this));i||(t.filter(":not(:only-child)").closest(".hierarchy").addClass("isChildrenCollapsed"),t.closest(".hierarchy").removeClass("isCollapsedDescendant")),this.repaint(t.get(0)),t.addClass("sliding").removeClass("slide-up").eq(0).one("transitionend",{node:e,animatedNodes:t},this.showChildrenEnd.bind(this))},hideSiblingsEnd:function(e){var t=e.data.node,i=e.data.nodeContainer,n=e.data.direction,n=n?"left"===n?i.prevAll(":not(.hidden)"):i.nextAll(":not(.hidden)"):i.siblings();e.data.animatedNodes.removeClass("sliding"),n.find(".node:gt(0)").filter(this.isVisibleNode.bind(this)).removeClass("slide-left slide-right").addClass("slide-up"),n.find(".nodes, .vertical").addClass("hidden").end().addClass("hidden"),this.isInAction(t)&&this.switchHorizontalArrow(t)},hideSiblings:function(e,t){var i=e.closest(".hierarchy").addClass("isSiblingsCollapsed"),n=(i.siblings().find(".spinner").length&&e.closest(".orgchart").data("inAjax",!1),t?"left"===t?i.addClass("left-sibs").prevAll(".isSiblingsCollapsed").removeClass("isSiblingsCollapsed left-sibs").end().prevAll().addClass("isCollapsedSibling isChildrenCollapsed").find(".node").filter(this.isVisibleNode.bind(this)).addClass("sliding slide-right"):i.addClass("right-sibs").nextAll(".isSiblingsCollapsed").removeClass("isSiblingsCollapsed right-sibs").end().nextAll().addClass("isCollapsedSibling isChildrenCollapsed").find(".node").filter(this.isVisibleNode.bind(this)).addClass("sliding slide-left"):(i.prevAll().find(".node").filter(this.isVisibleNode.bind(this)).addClass("sliding slide-right"),i.nextAll().find(".node").filter(this.isVisibleNode.bind(this)).addClass("sliding slide-left"),i.siblings().addClass("isCollapsedSibling isChildrenCollapsed")),i.siblings().find(".sliding"));n.eq(0).one("transitionend",{node:e,nodeContainer:i,direction:t,animatedNodes:n},this.hideSiblingsEnd.bind(this))},showSiblingsEnd:function(e){var t=e.data.node;e.data.visibleNodes.removeClass("sliding"),this.isInAction(t)&&(this.switchHorizontalArrow(t),t.children(".topEdge").removeClass(this.options.icons.expandToUp).addClass(this.options.icons.collapseToDown))},showRelatedParentEnd:function(e){l(e.target).removeClass("sliding")},showSiblings:function(e,t){var i=l(),n=e.closest(".hierarchy"),i=(t?"left"===t?n.prevAll():n.nextAll():e.closest(".hierarchy").siblings()).removeClass("hidden"),s=e.closest(".nodes").siblings(".node"),n=(t?(n.removeClass(t+"-sibs"),n.is("[class*=-sibs]")||n.removeClass("isSiblingsCollapsed"),i.removeClass("isCollapsedSibling "+t+"-sibs")):(e.closest(".hierarchy").removeClass("isSiblingsCollapsed"),i.removeClass("isCollapsedSibling")),this.getNodeState(e,"parent").visible||(e.closest(".hierarchy").removeClass("isAncestorsCollapsed"),s.removeClass("hidden"),this.repaint(s[0]),s.addClass("sliding").removeClass("slide-down").one("transitionend",this.showRelatedParentEnd)),i.find(".node").filter(this.isVisibleNode.bind(this)));this.repaint(n.get(0)),n.addClass("sliding").removeClass("slide-left slide-right"),n.eq(0).one("transitionend",{node:e,visibleNodes:n},this.showSiblingsEnd.bind(this))},startLoading:function(e){var t=this.$chart;return(void 0===t.data("inAjax")||!0!==t.data("inAjax"))&&(e.addClass("hidden"),e.parent().append(`<i class="${this.options.icons.theme} ${this.options.icons.spinner} spinner"></i>`).children().not(".spinner").css("opacity",.2),t.data("inAjax",!0),l(".oc-export-btn").prop("disabled",!0),!0)},endLoading:function(e){var t=e.parent();e.removeClass("hidden"),t.find(".spinner").remove(),t.children().removeAttr("style"),this.$chart.data("inAjax",!1),l(".oc-export-btn").prop("disabled",!1)},isInAction:function(t){return[this.options.icons.expandToUp,this.options.icons.collapseToDown,this.options.icons.collapseToLeft,this.options.icons.expandToRight].some(e=>-1<t.children(".edge").attr("class").indexOf(e))},switchVerticalArrow:function(e){e.toggleClass(this.options.icons.expandToUp+" "+this.options.icons.collapseToDown)},switchHorizontalArrow:function(e){var t,i=this.options;i.toggleSiblingsResp&&(void 0===i.ajaxURL||e.closest(".nodes").data("siblingsLoaded"))?((t=e.parent().prev()).length&&(t.is(".hidden")?e.children(".leftEdge").addClass(i.icons.collapseToLeft).removeClass(i.icons.expandToRight):e.children(".leftEdge").addClass(i.icons.expandToRight).removeClass(i.icons.collapseToLeft)),(t=e.parent().next()).length&&(t.is(".hidden")?e.children(".rightEdge").addClass(i.icons.expandToRight).removeClass(i.icons.collapseToLeft):e.children(".rightEdge").addClass(i.icons.collapseToLeft).removeClass(i.icons.expandToRight))):(t=!!(t=e.parent().siblings()).length&&!t.is(".hidden"),e.children(".leftEdge").toggleClass(i.icons.expandToRight,t).toggleClass(i.icons.collapseToLeft,!t),e.children(".rightEdge").toggleClass(i.icons.collapseToLeft,t).toggleClass(i.icons.expandToRight,!t))},repaint:function(e){e&&(e.style.offsetWidth=e.offsetWidth)},nodeEnterLeaveHandler:function(e){var t,i,n,s=l(e.delegateTarget),o=!1;s.closest(".nodes.vertical").length?(t=s.children(".toggleBtn"),"mouseenter"===e.type?s.children(".toggleBtn").length&&(o=this.getNodeState(s,"children").visible,t.toggleClass(this.options.icons.collapsed,!o).toggleClass(this.options.icons.expanded,o)):t.removeClass(this.options.icons.collapsed+" "+this.options.icons.expanded)):(t=s.children(".topEdge"),s.children(".rightEdge"),i=s.children(".bottomEdge"),n=s.children(".leftEdge"),"mouseenter"===e.type?(t.length&&(o=this.getNodeState(s,"parent").visible,t.toggleClass(this.options.icons.expandToUp,!o).toggleClass(this.options.icons.collapseToDown,o)),i.length&&(o=this.getNodeState(s,"children").visible,i.toggleClass(this.options.icons.collapseToDown,!o).toggleClass(this.options.icons.expandToUp,o)),n.length&&this.switchHorizontalArrow(s)):s.children(".edge").removeClass(`${this.options.icons.expandToUp} ${this.options.icons.collapseToDown} ${this.options.icons.collapseToLeft} `+this.options.icons.expandToRight))},nodeClickHandler:function(e){this.$chart.find(".focused").removeClass("focused"),l(e.delegateTarget).addClass("focused")},loadNodes:function(t,e,i){var n=this;this.options;l.ajax({url:e,dataType:"json"}).done(function(e){n.$chart.data("inAjax")&&("parent"===t?l.isEmptyObject(e)||n.addParent(i.parent(),e):"children"===t?e.children.length&&n.addChildren(i.parent(),e[t]):n.addSiblings(i.parent(),e.siblings||e),n.triggerLoadEvent(i.parent(),t))}).fail(function(){console.log("Failed to get "+t+" data")}).always(function(){n.endLoading(i)})},HideFirstParentEnd:function(e){var e=e.data.topEdge,t=e.parent();this.isInAction(t)&&(this.switchVerticalArrow(e),this.switchHorizontalArrow(t))},topEdgeClickHandler:function(e){e.stopPropagation();var t,i=l(e.target),e=l(e.delegateTarget),n=this.getNodeState(e,"parent");n.exist?(t=e.closest(".nodes").siblings(".node")).is(".sliding")||(n.visible?(this.hideParent(e),t.one("transitionend",{topEdge:i},this.HideFirstParentEnd.bind(this)),this.triggerHideEvent(e,"parent")):(this.showParent(e),this.triggerShowEvent(e,"parent"))):this.startLoading(i)&&(n=this.options,t=l.isFunction(n.ajaxURL.parent)?n.ajaxURL.parent(e.data("nodeData")):n.ajaxURL.parent+e[0].id,this.loadNodes("parent",t,i))},bottomEdgeClickHandler:function(e){e.stopPropagation();var t=l(e.target),e=l(e.delegateTarget),i=this.getNodeState(e,"children");i.exist?e.siblings(".nodes").children().children(".node").is(".sliding")||(i.visible?(this.hideChildren(e),this.triggerHideEvent(e,"children")):(this.showChildren(e),this.triggerShowEvent(e,"children"))):this.startLoading(t)&&(i=this.options,i=l.isFunction(i.ajaxURL.children)?i.ajaxURL.children(e.data("nodeData")):i.ajaxURL.children+e[0].id,this.loadNodes("children",i,t))},hEdgeClickHandler:function(e){e.stopPropagation();var t,i,n=l(e.target),e=l(e.delegateTarget),s=this.options,o=this.getNodeState(e,"siblings");o.exist?e.closest(".hierarchy").siblings().find(".sliding").length||(s.toggleSiblingsResp?(t=e.closest(".hierarchy").prev(),i=e.closest(".hierarchy").next(),n.is(".leftEdge")?t.is(".hidden")?(this.showSiblings(e,"left"),this.triggerShowEvent(e,"siblings")):(this.hideSiblings(e,"left"),this.triggerHideEvent(e,"siblings")):i.is(".hidden")?(this.showSiblings(e,"right"),this.triggerShowEvent(e,"siblings")):(this.hideSiblings(e,"right"),this.triggerHideEvent(e,"siblings"))):o.visible?(this.hideSiblings(e),this.triggerHideEvent(e,"siblings")):(this.showSiblings(e),this.triggerShowEvent(e,"siblings"))):this.startLoading(n)&&(t=e[0].id,i=this.getNodeState(e,"parent").exist?l.isFunction(s.ajaxURL.siblings)?s.ajaxURL.siblings(e.data("nodeData")):s.ajaxURL.siblings+t:l.isFunction(s.ajaxURL.families)?s.ajaxURL.families(e.data("nodeData")):s.ajaxURL.families+t,this.loadNodes("siblings",i,n))},expandVNodesEnd:function(e){e.data.vNodes.removeClass("sliding")},collapseVNodesEnd:function(e){e.data.vNodes.removeClass("sliding").closest("ul").addClass("hidden")},toggleVNodes:function(e){var e=l(e.target),t=e.parent().next(),i=t.find(".node"),n=t.children().children(".node");n.is(".sliding")||(e.toggleClass(this.options.icons.collapsed+" "+this.options.icons.expanded),i.eq(0).is(".slide-up")?(t.removeClass("hidden"),this.repaint(n.get(0)),n.addClass("sliding").removeClass("slide-up").eq(0).one("transitionend",{vNodes:n},this.expandVNodesEnd)):(i.addClass("sliding slide-up").eq(0).one("transitionend",{vNodes:i},this.collapseVNodesEnd),i.find(".toggleBtn").removeClass(this.options.icons.collapsed+" "+this.options.icons.expanded)))},createGhostNode:function(e){var t,i,n=l(e.target),s=this.options,e=e.originalEvent,o=/firefox/.test(h.navigator.userAgent.toLowerCase());if(c.querySelector(".ghost-node"))t=n.closest(".orgchart").children(".ghost-node").get(0),i=l(t).children().get(0);else{if(!(t=c.createElementNS("http://www.w3.org/2000/svg","svg")).classList)return;t.classList.add("ghost-node"),i=c.createElementNS("http://www.w3.org/2000/svg","rect"),t.appendChild(i),n.closest(".orgchart").append(t)}var a=n.closest(".orgchart").css("transform").split(","),d="t2b"===s.direction||"b2t"===s.direction,a=Math.abs(h.parseFloat(d?a[0].slice(a[0].indexOf("(")+1):a[1])),d=(t.setAttribute("width",d?n.outerWidth(!1):n.outerHeight(!1)),t.setAttribute("height",d?n.outerHeight(!1):n.outerWidth(!1)),i.setAttribute("x",5*a),i.setAttribute("y",5*a),i.setAttribute("width",120*a),i.setAttribute("height",40*a),i.setAttribute("rx",4*a),i.setAttribute("ry",4*a),i.setAttribute("stroke-width",+a),e.offsetX*a),r=e.offsetY*a;"l2r"===s.direction?(d=e.offsetY*a,r=e.offsetX*a):"r2l"===s.direction?(d=n.outerWidth(!1)-e.offsetY*a,r=e.offsetX*a):"b2t"===s.direction&&(d=n.outerWidth(!1)-e.offsetX*a,r=n.outerHeight(!1)-e.offsetY*a),o?(i.setAttribute("fill","rgb(255, 255, 255)"),i.setAttribute("stroke","rgb(191, 0, 0)"),(s=c.createElement("img")).src="data:image/svg+xml;utf8,"+(new XMLSerializer).serializeToString(t),e.dataTransfer.setDragImage(s,d,r)):e.dataTransfer.setDragImage&&e.dataTransfer.setDragImage(t,d,r)},getUpperLevel:function(e){return e.is(".node")?e.parents(".hierarchy").length:0},getLowerLevel:function(e){return e.is(".node")?e.closest(".hierarchy").find(".nodes").length+1:0},getLevelOrderNodes:function(e){if(!e)return[];var t=[],i=[];for(t.push(e);t.length;){for(var n=[],s=0;s<t.length;s++){var o=t.shift(),a=this.getChildren(o);a.length&&t.push(a.toArray().flat()),n.push(l(o))}i.push(n)}return i},filterAllowedDropNodes:function(i){var n=this.options,s=i.closest("[draggable]").hasClass("node"),o=i.closest(".nodes").siblings(".node"),a=i.closest(".hierarchy").find(".node");this.$chart.data("dragged",i).find(".node").each(function(e,t){s&&-1!==a.index(t)||n.dropCriteria&&!n.dropCriteria(i,o,l(t))||l(t).addClass("allowedDrop")})},dragstartHandler:function(e){e.originalEvent.dataTransfer.setData("text/html","hack for firefox"),"none"!==this.$chart.css("transform")&&this.createGhostNode(e),this.filterAllowedDropNodes(l(e.target))},dragoverHandler:function(e){l(e.delegateTarget).is(".allowedDrop")?e.preventDefault():e.originalEvent.dataTransfer.dropEffect="none"},dragendHandler:function(e){this.$chart.find(".allowedDrop").removeClass("allowedDrop")},dropHandler:async function(e){var t,i,n,s,o,e=l(e.delegateTarget),a=this.$chart.data("dragged");a.hasClass("node")?e.hasClass("allowedDrop")&&(t=a.closest(".nodes").siblings(".node"),i=l.Event("nodedrop.orgchart"),this.$chart.trigger(i,{draggedNode:a,dragZone:t,dropZone:e}),i.isDefaultPrevented()||(i=this.$chart.data("options").data,o=(s=new JSONDigger(i,this.$chart.data("options").nodeId,"children")).findOneNode({isHybrid:!0}),1<this.$chart.data("options").verticalLevel||o?(o=s.findNodeById(a.data("nodeData").id),n=Object.assign({},o),s.removeNode(o.id),(o=s.findNodeById(e.data("nodeData").id)).children?o.children.push(n):o.children=[n],this.init({data:i})):(e.siblings(".nodes").length?(s=`<i class="edge horizontalEdge rightEdge ${this.options.icons.theme}"></i><i class="edge horizontalEdge leftEdge ${this.options.icons.theme}"></i>`,a.find(".horizontalEdge").length||a.append(s),e.siblings(".nodes").append(a.closest(".hierarchy")),1===(o=a.closest(".hierarchy").siblings().find(".node:first")).length&&o.append(s)):(e.append(`<i class="edge verticalEdge bottomEdge ${this.options.icons.theme}"></i>`).after('<ul class="nodes"></ul>').siblings(".nodes").append(a.find(".horizontalEdge").remove().end().closest(".hierarchy")),e.children(".title").length&&e.children(".title").prepend(`<i class="${this.options.icons.theme} ${this.$chart.data("options").icons.parentNode} parentNodeSymbol"></i>`)),1===t.siblings(".nodes").children(".hierarchy").length?t.siblings(".nodes").children(".hierarchy").find(".node:first").find(".horizontalEdge").remove():0===t.siblings(".nodes").children(".hierarchy").length&&t.find(".bottomEdge, .parentNodeSymbol").remove().end().siblings(".nodes").remove()))):this.$chart.triggerHandler({type:"otherdropped.orgchart",draggedItem:a,dropZone:e})},touchstartHandler:function(e){this.touchHandled||e.touches&&1<e.touches.length||(this.touchHandled=!0,this.touchMoved=!1,e.preventDefault())},touchmoveHandler:function(e){var t;!this.touchHandled||e.touches&&1<e.touches.length||(e.preventDefault(),this.touchMoved||(this.filterAllowedDropNodes(l(e.currentTarget)),this.touchDragImage=this.createDragImage(e,this.$chart.data("dragged")[0])),this.touchMoved=!0,this.moveDragImage(e,this.touchDragImage),0<(e=l(c.elementFromPoint(e.touches[0].clientX,e.touches[0].clientY)).closest("div.node")).length&&(t=e[0],e.is(".allowedDrop"))?this.touchTargetNode=t:this.touchTargetNode=null)},touchendHandler:function(e){var t,i;this.touchHandled&&(this.destroyDragImage(),this.touchMoved?(this.touchTargetNode&&(t={delegateTarget:this.touchTargetNode},this.dropHandler(t),this.touchTargetNode=null),this.dragendHandler(e)):(t=e.changedTouches[0],(i=c.createEvent("MouseEvents")).initMouseEvent("click",!0,!0,h,1,t.screenX,t.screenY,t.clientX,t.clientY,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,0,null),e.target.dispatchEvent(i)),this.touchHandled=!1)},createDragImage:function(e,t){var i=t.cloneNode(!0),t=(this.copyStyle(t,i),i.style.top=i.style.left="-9999px",t.getBoundingClientRect()),e=this.getTouchPoint(e);return this.touchDragImageOffset={x:e.x-t.left,y:e.y-t.top},i.style.opacity="0.5",c.body.appendChild(i),i},destroyDragImage:function(){this.touchDragImage&&this.touchDragImage.parentElement&&this.touchDragImage.parentElement.removeChild(this.touchDragImage),this.touchDragImageOffset=null,this.touchDragImage=null},copyStyle:function(e,t){["id","class","style","draggable"].forEach(function(e){t.removeAttribute(e)}),e instanceof HTMLCanvasElement&&((n=t).width=(i=e).width,n.height=i.height,n.getContext("2d").drawImage(i,0,0));for(var i,n,s=getComputedStyle(e),o=0;o<s.length;o++){var a=s[o];a.indexOf("transition")<0&&(t.style[a]=s[a])}t.style.pointerEvents="none";for(o=0;o<e.children.length;o++)this.copyStyle(e.children[o],t.children[o])},getTouchPoint:function(e){return{x:(e=e&&e.touches?e.touches[0]:e).clientX,y:e.clientY}},moveDragImage:function(i,n){var s;i&&n&&(s=this,requestAnimationFrame(function(){var e=s.getTouchPoint(i),t=n.style;t.position="absolute",t.pointerEvents="none",t.zIndex="999999",s.touchDragImageOffset&&(t.left=Math.round(e.x-s.touchDragImageOffset.x)+"px",t.top=Math.round(e.y-s.touchDragImageOffset.y)+"px")}))},bindDragDrop:function(e){e.on("dragstart",this.dragstartHandler.bind(this)).on("dragover",this.dragoverHandler.bind(this)).on("dragend",this.dragendHandler.bind(this)).on("drop",this.dropHandler.bind(this)).on("touchstart",this.touchstartHandler.bind(this)).on("touchmove",this.touchmoveHandler.bind(this)).on("touchend",this.touchendHandler.bind(this))},createNode:function(i){var n=this.options,e=i.level,t=(i.children&&i[n.nodeId]&&l.each(i.children,function(e,t){t.parentId=i[n.nodeId]}),l("<div"+(n.draggable?' draggable="true"':"")+(i[n.nodeId]?' id="'+i[n.nodeId]+'"':"")+(i.parentId?' data-parent="'+i.parentId+'"':"")+">").addClass("node "+(i.className||"")+(e>n.visibleLevel?" slide-up":""))),s=(n.nodeTemplate?t.append(n.nodeTemplate(i)):t.append('<div class="title">'+i[n.nodeTitle]+"</div>").append(void 0!==n.nodeContent?'<div class="content">'+(i[n.nodeContent]||"")+"</div>":""),l.extend({},i)),s=(delete s.children,t.data("nodeData",s),i.relationship||"");return n.verticalLevel&&e>=n.verticalLevel||i.isVertical?Number(s.substr(2,1))&&t.append(`<i class="toggleBtn ${n.icons.theme}"></i>`).children(".title").prepend(`<i class="${n.icons.theme} ${n.icons.parentNode} parentNodeSymbol"></i>`):(i.isHybrid||(Number(s.substr(0,1))&&t.append(`<i class="edge verticalEdge topEdge ${n.icons.theme}"></i>`),Number(s.substr(1,1))&&t.append(`<i class="edge horizontalEdge rightEdge ${n.icons.theme}"></i><i class="edge horizontalEdge leftEdge ${n.icons.theme}"></i>`)),Number(s.substr(2,1))&&t.append(`<i class="edge verticalEdge bottomEdge ${n.icons.theme}"></i>`).children(".title").prepend(`<i class="${n.icons.theme} ${n.icons.parentNode} parentNodeSymbol"></i>`)),t.on("mouseenter mouseleave",this.nodeEnterLeaveHandler.bind(this)),t.on("click",this.nodeClickHandler.bind(this)),t.on("click",".topEdge",this.topEdgeClickHandler.bind(this)),t.on("click",".bottomEdge",this.bottomEdgeClickHandler.bind(this)),t.on("click",".leftEdge, .rightEdge",this.hEdgeClickHandler.bind(this)),t.on("click",".toggleBtn",this.toggleVNodes.bind(this)),n.draggable&&(this.bindDragDrop(t),this.touchHandled=!1,this.touchMoved=!1,this.touchTargetNode=null),n.createNode&&n.createNode(t,i),t},buildHierarchy:function(e,t){var i,n,s=this,o=this.options,a=0,a=t.level||(t.level=e.parentsUntil(".orgchart",".nodes").length);2<Object.keys(t).length&&e.append(this.createNode(t)),t.children&&t.children.length&&(i=a+1>o.visibleLevel||t.collapsed!==d&&t.collapsed,o.verticalLevel&&a+1>=o.verticalLevel||t.isHybrid?(n=l('<ul class="nodes">'),i&&o.verticalLevel&&a+1>=o.verticalLevel&&n.addClass("hidden"),(o.verticalLevel&&a+1===o.verticalLevel||t.isHybrid)&&!e.closest(".vertical").length?e.append(n.addClass("vertical")):e.append(n)):(n=l('<ul class="nodes'+(i?" hidden":"")+'">'),2!==Object.keys(t).length&&i&&e.addClass("isChildrenCollapsed"),e.append(n)),l.each(t.children,function(){var e=l('<li class="hierarchy">');n.append(e),this.level=a+1,s.buildHierarchy(e,this)}))},buildChildNode:function(e,t){this.buildHierarchy(e,{children:t})},addChildren:function(e,t){this.buildChildNode(e.closest(".hierarchy"),t),e.find(".parentNodeSymbol").length||e.children(".title").prepend(`<i class="${this.options.icons.theme} ${this.options.icons.parentNode} parentNodeSymbol"></i>`),e.closest(".nodes.vertical").length?e.children(".toggleBtn").length||e.append(`<i class="toggleBtn ${this.options.icons.theme}"></i>`):e.children(".bottomEdge").length||e.append(`<i class="edge verticalEdge bottomEdge ${this.options.icons.theme}"></i>`),this.isInAction(e)&&this.switchVerticalArrow(e.children(".bottomEdge"))},buildParentNode:function(e,t){t.relationship=t.relationship||"001";t=l('<ul class="nodes"><li class="hierarchy"></li></ul>').find(".hierarchy").append(this.createNode(t)).end();this.$chart.prepend(t).find(".hierarchy:first").append(e.closest("ul").addClass("nodes"))},addParent:function(e,t){this.buildParentNode(e,t),e.children(".topEdge").length||e.children(".title").after(`<i class="edge verticalEdge topEdge ${this.options.icons.theme}"></i>`),this.isInAction(e)&&this.switchVerticalArrow(e.children(".topEdge"))},buildSiblingNode:function(e,t){var i,n=(l.isArray(t)?t:t.children).length,s=e.parent().is(".nodes")?e.siblings().length+1:1,n=s+n,n=1<n?Math.floor(n/2-1):0;e.closest(".nodes").parent().is(".hierarchy")?(this.buildChildNode(e.parent().closest(".hierarchy"),t),i=e.parent().closest(".hierarchy").children(".nodes:last").children(".hierarchy"),1<s?i.eq(0).before(e.siblings().addBack().unwrap()):i.eq(n).after(e.unwrap())):(this.buildHierarchy(e.parent().prepend(l('<li class="hierarchy">')).children(".hierarchy:first"),t),e.prevAll(".hierarchy").children(".nodes").children().eq(n).after(e))},addSiblings:function(e,t){this.buildSiblingNode(e.closest(".hierarchy"),t),e.closest(".nodes").data("siblingsLoaded",!0),e.children(".leftEdge").length||e.children(".topEdge").after(`<i class="edge horizontalEdge rightEdge ${this.options.icons.theme}"></i><i class="edge horizontalEdge leftEdge ${this.options.icons.theme}"></i>`),this.isInAction(e)&&(this.switchHorizontalArrow(e),e.children(".topEdge").removeClass(this.options.icons.expandToUp).addClass(this.options.icons.collapseToDown))},removeNodes:function(e){var t=e.closest(".hierarchy").parent();t.parent().is(".hierarchy")?this.getNodeState(e,"siblings").exist?(e.closest(".hierarchy").remove(),1===t.children().length&&t.find(".node:first .horizontalEdge").remove()):t.siblings(".node").find(".bottomEdge").remove().end().end().remove():t.closest(".orgchart").remove()},hideDropZones:function(){this.$chart.find(".allowedDrop").removeClass("allowedDrop")},showDropZones:function(e){this.$chart.find(".node").each(function(e,t){l(t).addClass("allowedDrop")}),this.$chart.data("dragged",l(e))},processExternalDrop:function(e,t){t&&this.$chart.data("dragged",l(t)),e.closest(".node").triggerHandler({type:"drop"})},exportPDF:function(e,t){var i={},n=Math.floor(e.width),s=Math.floor(e.height);h.jsPDF||(h.jsPDF=h.jspdf.jsPDF),(i=s<n?new jsPDF({orientation:"landscape",unit:"px",format:[n,s]}):new jsPDF({orientation:"portrait",unit:"px",format:[s,n]})).addImage(e.toDataURL(),"png",0,0),i.save(t+".pdf")},exportPNG:function(e,t){var i="WebkitAppearance"in c.documentElement.style,n=!!h.sidebar,s="Microsoft Internet Explorer"===navigator.appName||"Netscape"===navigator.appName&&-1<navigator.appVersion.indexOf("Edge"),o=this.$chartContainer;!i&&!n||s?h.navigator.msSaveBlob(e.msToBlob(),t+".png"):(i=".download-btn"+(""!==this.options.chartClass?"."+this.options.chartClass:""),o.find(i).length||o.append('<a class="download-btn'+(""!==this.options.chartClass?" "+this.options.chartClass:"")+'" download="'+t+'.png"></a>'),o.find(i).attr("href",e.toDataURL())[0].click())},export:function(t,i){var n=this;if(t=void 0!==t?t:this.options.exportFilename,i=void 0!==i?i:this.options.exportFileextension,l(this).children(".spinner").length)return!1;var s=this.$chartContainer,e=s.find(".mask"),e=(e.length?e.removeClass("hidden"):s.append(`<div class="mask"><i class="${this.options.icons.theme} ${this.options.icons.spinner} spinner"></i></div>`),s.addClass("canvasContainer").find('.orgchart:not(".hidden")').get(0)),o="l2r"===n.options.direction||"r2l"===n.options.direction;html2canvas(e,{width:o?e.clientHeight:e.clientWidth,height:o?e.clientWidth:e.clientHeight,onclone:function(e){l(e).find(".canvasContainer").css("overflow","visible").find('.orgchart:not(".hidden"):first').css("transform","")}}).then(function(e){s.find(".mask").addClass("hidden"),"pdf"===i.toLowerCase()?n.exportPDF(e,t):n.exportPNG(e,t),s.removeClass("canvasContainer")},function(){s.removeClass("canvasContainer")})}},l.fn.orgchart=function(e){return new t(this,e).init()}});
  //# sourceMappingURL=jquery.orgchart.min.js.map
  
  
  /***/ }),
  
  /***/ "./node_modules/select2/dist/js/select2.js":
  /*!*************************************************!*\
    !*** ./node_modules/select2/dist/js/select2.js ***!
    \*************************************************/
  /***/ ((module, exports, __webpack_require__) => {
  
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
   * Select2 4.1.0-rc.0
   * https://select2.github.io
   *
   * Released under the MIT license
   * https://github.com/select2/select2/blob/master/LICENSE.md
   */
  ;(function (factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
      __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
      (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  } (function (jQuery) {
    // This is needed so we can catch the AMD loader configuration and use it
    // The inner file should be wrapped (by `banner.start.js`) in a function that
    // returns the AMD loader references.
    var S2 =(function () {
    // Restore the Select2 AMD loader so it can be used
    // Needed mostly in the language files, where the loader is not inserted
    if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
      var S2 = jQuery.fn.select2.amd;
    }
  var S2;(function () { if (!S2 || !S2.requirejs) {
  if (!S2) { S2 = {}; } else { require = S2; }
  /**
   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
   * Released under MIT license, http://github.com/requirejs/almond/LICENSE
   */
  //Going sloppy to avoid 'use strict' string cost, but strict practices should
  //be followed.
  /*global setTimeout: false */
  
  var requirejs, require, define;
  (function (undef) {
      var main, req, makeMap, handlers,
          defined = {},
          waiting = {},
          config = {},
          defining = {},
          hasOwn = Object.prototype.hasOwnProperty,
          aps = [].slice,
          jsSuffixRegExp = /\.js$/;
  
      function hasProp(obj, prop) {
          return hasOwn.call(obj, prop);
      }
  
      /**
       * Given a relative module name, like ./something, normalize it to
       * a real name that can be mapped to a path.
       * @param {String} name the relative name
       * @param {String} baseName a real name that the name arg is relative
       * to.
       * @returns {String} normalized name
       */
      function normalize(name, baseName) {
          var nameParts, nameSegment, mapValue, foundMap, lastIndex,
              foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
              baseParts = baseName && baseName.split("/"),
              map = config.map,
              starMap = (map && map['*']) || {};
  
          //Adjust any relative paths.
          if (name) {
              name = name.split('/');
              lastIndex = name.length - 1;
  
              // If wanting node ID compatibility, strip .js from end
              // of IDs. Have to do this here, and not in nameToUrl
              // because node allows either .js or non .js to map
              // to same file.
              if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                  name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
              }
  
              // Starts with a '.' so need the baseName
              if (name[0].charAt(0) === '.' && baseParts) {
                  //Convert baseName to array, and lop off the last part,
                  //so that . matches that 'directory' and not name of the baseName's
                  //module. For instance, baseName of 'one/two/three', maps to
                  //'one/two/three.js', but we want the directory, 'one/two' for
                  //this normalization.
                  normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                  name = normalizedBaseParts.concat(name);
              }
  
              //start trimDots
              for (i = 0; i < name.length; i++) {
                  part = name[i];
                  if (part === '.') {
                      name.splice(i, 1);
                      i -= 1;
                  } else if (part === '..') {
                      // If at the start, or previous value is still ..,
                      // keep them so that when converted to a path it may
                      // still work when converted to a path, even though
                      // as an ID it is less than ideal. In larger point
                      // releases, may be better to just kick out an error.
                      if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                          continue;
                      } else if (i > 0) {
                          name.splice(i - 1, 2);
                          i -= 2;
                      }
                  }
              }
              //end trimDots
  
              name = name.join('/');
          }
  
          //Apply map config if available.
          if ((baseParts || starMap) && map) {
              nameParts = name.split('/');
  
              for (i = nameParts.length; i > 0; i -= 1) {
                  nameSegment = nameParts.slice(0, i).join("/");
  
                  if (baseParts) {
                      //Find the longest baseName segment match in the config.
                      //So, do joins on the biggest to smallest lengths of baseParts.
                      for (j = baseParts.length; j > 0; j -= 1) {
                          mapValue = map[baseParts.slice(0, j).join('/')];
  
                          //baseName segment has  config, find if it has one for
                          //this name.
                          if (mapValue) {
                              mapValue = mapValue[nameSegment];
                              if (mapValue) {
                                  //Match, update name to the new value.
                                  foundMap = mapValue;
                                  foundI = i;
                                  break;
                              }
                          }
                      }
                  }
  
                  if (foundMap) {
                      break;
                  }
  
                  //Check for a star map match, but just hold on to it,
                  //if there is a shorter segment match later in a matching
                  //config, then favor over this star map.
                  if (!foundStarMap && starMap && starMap[nameSegment]) {
                      foundStarMap = starMap[nameSegment];
                      starI = i;
                  }
              }
  
              if (!foundMap && foundStarMap) {
                  foundMap = foundStarMap;
                  foundI = starI;
              }
  
              if (foundMap) {
                  nameParts.splice(0, foundI, foundMap);
                  name = nameParts.join('/');
              }
          }
  
          return name;
      }
  
      function makeRequire(relName, forceSync) {
          return function () {
              //A version of a require function that passes a moduleName
              //value for items that may need to
              //look up paths relative to the moduleName
              var args = aps.call(arguments, 0);
  
              //If first arg is not require('string'), and there is only
              //one arg, it is the array form without a callback. Insert
              //a null so that the following concat is correct.
              if (typeof args[0] !== 'string' && args.length === 1) {
                  args.push(null);
              }
              return req.apply(undef, args.concat([relName, forceSync]));
          };
      }
  
      function makeNormalize(relName) {
          return function (name) {
              return normalize(name, relName);
          };
      }
  
      function makeLoad(depName) {
          return function (value) {
              defined[depName] = value;
          };
      }
  
      function callDep(name) {
          if (hasProp(waiting, name)) {
              var args = waiting[name];
              delete waiting[name];
              defining[name] = true;
              main.apply(undef, args);
          }
  
          if (!hasProp(defined, name) && !hasProp(defining, name)) {
              throw new Error('No ' + name);
          }
          return defined[name];
      }
  
      //Turns a plugin!resource to [plugin, resource]
      //with the plugin being undefined if the name
      //did not have a plugin prefix.
      function splitPrefix(name) {
          var prefix,
              index = name ? name.indexOf('!') : -1;
          if (index > -1) {
              prefix = name.substring(0, index);
              name = name.substring(index + 1, name.length);
          }
          return [prefix, name];
      }
  
      //Creates a parts array for a relName where first part is plugin ID,
      //second part is resource ID. Assumes relName has already been normalized.
      function makeRelParts(relName) {
          return relName ? splitPrefix(relName) : [];
      }
  
      /**
       * Makes a name map, normalizing the name, and using a plugin
       * for normalization if necessary. Grabs a ref to plugin
       * too, as an optimization.
       */
      makeMap = function (name, relParts) {
          var plugin,
              parts = splitPrefix(name),
              prefix = parts[0],
              relResourceName = relParts[1];
  
          name = parts[1];
  
          if (prefix) {
              prefix = normalize(prefix, relResourceName);
              plugin = callDep(prefix);
          }
  
          //Normalize according
          if (prefix) {
              if (plugin && plugin.normalize) {
                  name = plugin.normalize(name, makeNormalize(relResourceName));
              } else {
                  name = normalize(name, relResourceName);
              }
          } else {
              name = normalize(name, relResourceName);
              parts = splitPrefix(name);
              prefix = parts[0];
              name = parts[1];
              if (prefix) {
                  plugin = callDep(prefix);
              }
          }
  
          //Using ridiculous property names for space reasons
          return {
              f: prefix ? prefix + '!' + name : name, //fullName
              n: name,
              pr: prefix,
              p: plugin
          };
      };
  
      function makeConfig(name) {
          return function () {
              return (config && config.config && config.config[name]) || {};
          };
      }
  
      handlers = {
          require: function (name) {
              return makeRequire(name);
          },
          exports: function (name) {
              var e = defined[name];
              if (typeof e !== 'undefined') {
                  return e;
              } else {
                  return (defined[name] = {});
              }
          },
          module: function (name) {
              return {
                  id: name,
                  uri: '',
                  exports: defined[name],
                  config: makeConfig(name)
              };
          }
      };
  
      main = function (name, deps, callback, relName) {
          var cjsModule, depName, ret, map, i, relParts,
              args = [],
              callbackType = typeof callback,
              usingExports;
  
          //Use name if no relName
          relName = relName || name;
          relParts = makeRelParts(relName);
  
          //Call the callback to define the module, if necessary.
          if (callbackType === 'undefined' || callbackType === 'function') {
              //Pull out the defined dependencies and pass the ordered
              //values to the callback.
              //Default to [require, exports, module] if no deps
              deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
              for (i = 0; i < deps.length; i += 1) {
                  map = makeMap(deps[i], relParts);
                  depName = map.f;
  
                  //Fast path CommonJS standard dependencies.
                  if (depName === "require") {
                      args[i] = handlers.require(name);
                  } else if (depName === "exports") {
                      //CommonJS module spec 1.1
                      args[i] = handlers.exports(name);
                      usingExports = true;
                  } else if (depName === "module") {
                      //CommonJS module spec 1.1
                      cjsModule = args[i] = handlers.module(name);
                  } else if (hasProp(defined, depName) ||
                             hasProp(waiting, depName) ||
                             hasProp(defining, depName)) {
                      args[i] = callDep(depName);
                  } else if (map.p) {
                      map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                      args[i] = defined[depName];
                  } else {
                      throw new Error(name + ' missing ' + depName);
                  }
              }
  
              ret = callback ? callback.apply(defined[name], args) : undefined;
  
              if (name) {
                  //If setting exports via "module" is in play,
                  //favor that over return value and exports. After that,
                  //favor a non-undefined return value over exports use.
                  if (cjsModule && cjsModule.exports !== undef &&
                          cjsModule.exports !== defined[name]) {
                      defined[name] = cjsModule.exports;
                  } else if (ret !== undef || !usingExports) {
                      //Use the return value from the function.
                      defined[name] = ret;
                  }
              }
          } else if (name) {
              //May just be an object definition for the module. Only
              //worry about defining if have a module name.
              defined[name] = callback;
          }
      };
  
      requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
          if (typeof deps === "string") {
              if (handlers[deps]) {
                  //callback in this case is really relName
                  return handlers[deps](callback);
              }
              //Just return the module wanted. In this scenario, the
              //deps arg is the module name, and second arg (if passed)
              //is just the relName.
              //Normalize module name, if it contains . or ..
              return callDep(makeMap(deps, makeRelParts(callback)).f);
          } else if (!deps.splice) {
              //deps is a config object, not an array.
              config = deps;
              if (config.deps) {
                  req(config.deps, config.callback);
              }
              if (!callback) {
                  return;
              }
  
              if (callback.splice) {
                  //callback is an array, which means it is a dependency list.
                  //Adjust args if there are dependencies
                  deps = callback;
                  callback = relName;
                  relName = null;
              } else {
                  deps = undef;
              }
          }
  
          //Support require(['a'])
          callback = callback || function () {};
  
          //If relName is a function, it is an errback handler,
          //so remove it.
          if (typeof relName === 'function') {
              relName = forceSync;
              forceSync = alt;
          }
  
          //Simulate async callback;
          if (forceSync) {
              main(undef, deps, callback, relName);
          } else {
              //Using a non-zero value because of concern for what old browsers
              //do, and latest browsers "upgrade" to 4 if lower value is used:
              //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
              //If want a value immediately, use require('id') instead -- something
              //that works in almond on the global level, but not guaranteed and
              //unlikely to work in other AMD implementations.
              setTimeout(function () {
                  main(undef, deps, callback, relName);
              }, 4);
          }
  
          return req;
      };
  
      /**
       * Just drops the config on the floor, but returns req in case
       * the config return value is used.
       */
      req.config = function (cfg) {
          return req(cfg);
      };
  
      /**
       * Expose module registry for debugging and tooling
       */
      requirejs._defined = defined;
  
      define = function (name, deps, callback) {
          if (typeof name !== 'string') {
              throw new Error('See almond README: incorrect module build, no module name');
          }
  
          //This module may not have dependencies
          if (!deps.splice) {
              //deps is not an array, so probably means
              //an object literal or factory function for
              //the value. Adjust args.
              callback = deps;
              deps = [];
          }
  
          if (!hasProp(defined, name) && !hasProp(waiting, name)) {
              waiting[name] = [name, deps, callback];
          }
      };
  
      define.amd = {
          jQuery: true
      };
  }());
  
  S2.requirejs = requirejs;S2.require = require;S2.define = define;
  }
  }());
  S2.define("almond", function(){});
  
  /* global jQuery:false, $:false */
  S2.define('jquery',[],function () {
    var _$ = jQuery || $;
  
    if (_$ == null && console && console.error) {
      console.error(
        'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
        'found. Make sure that you are including jQuery before Select2 on your ' +
        'web page.'
      );
    }
  
    return _$;
  });
  
  S2.define('select2/utils',[
    'jquery'
  ], function ($) {
    var Utils = {};
  
    Utils.Extend = function (ChildClass, SuperClass) {
      var __hasProp = {}.hasOwnProperty;
  
      function BaseConstructor () {
        this.constructor = ChildClass;
      }
  
      for (var key in SuperClass) {
        if (__hasProp.call(SuperClass, key)) {
          ChildClass[key] = SuperClass[key];
        }
      }
  
      BaseConstructor.prototype = SuperClass.prototype;
      ChildClass.prototype = new BaseConstructor();
      ChildClass.__super__ = SuperClass.prototype;
  
      return ChildClass;
    };
  
    function getMethods (theClass) {
      var proto = theClass.prototype;
  
      var methods = [];
  
      for (var methodName in proto) {
        var m = proto[methodName];
  
        if (typeof m !== 'function') {
          continue;
        }
  
        if (methodName === 'constructor') {
          continue;
        }
  
        methods.push(methodName);
      }
  
      return methods;
    }
  
    Utils.Decorate = function (SuperClass, DecoratorClass) {
      var decoratedMethods = getMethods(DecoratorClass);
      var superMethods = getMethods(SuperClass);
  
      function DecoratedClass () {
        var unshift = Array.prototype.unshift;
  
        var argCount = DecoratorClass.prototype.constructor.length;
  
        var calledConstructor = SuperClass.prototype.constructor;
  
        if (argCount > 0) {
          unshift.call(arguments, SuperClass.prototype.constructor);
  
          calledConstructor = DecoratorClass.prototype.constructor;
        }
  
        calledConstructor.apply(this, arguments);
      }
  
      DecoratorClass.displayName = SuperClass.displayName;
  
      function ctr () {
        this.constructor = DecoratedClass;
      }
  
      DecoratedClass.prototype = new ctr();
  
      for (var m = 0; m < superMethods.length; m++) {
        var superMethod = superMethods[m];
  
        DecoratedClass.prototype[superMethod] =
          SuperClass.prototype[superMethod];
      }
  
      var calledMethod = function (methodName) {
        // Stub out the original method if it's not decorating an actual method
        var originalMethod = function () {};
  
        if (methodName in DecoratedClass.prototype) {
          originalMethod = DecoratedClass.prototype[methodName];
        }
  
        var decoratedMethod = DecoratorClass.prototype[methodName];
  
        return function () {
          var unshift = Array.prototype.unshift;
  
          unshift.call(arguments, originalMethod);
  
          return decoratedMethod.apply(this, arguments);
        };
      };
  
      for (var d = 0; d < decoratedMethods.length; d++) {
        var decoratedMethod = decoratedMethods[d];
  
        DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
      }
  
      return DecoratedClass;
    };
  
    var Observable = function () {
      this.listeners = {};
    };
  
    Observable.prototype.on = function (event, callback) {
      this.listeners = this.listeners || {};
  
      if (event in this.listeners) {
        this.listeners[event].push(callback);
      } else {
        this.listeners[event] = [callback];
      }
    };
  
    Observable.prototype.trigger = function (event) {
      var slice = Array.prototype.slice;
      var params = slice.call(arguments, 1);
  
      this.listeners = this.listeners || {};
  
      // Params should always come in as an array
      if (params == null) {
        params = [];
      }
  
      // If there are no arguments to the event, use a temporary object
      if (params.length === 0) {
        params.push({});
      }
  
      // Set the `_type` of the first object to the event
      params[0]._type = event;
  
      if (event in this.listeners) {
        this.invoke(this.listeners[event], slice.call(arguments, 1));
      }
  
      if ('*' in this.listeners) {
        this.invoke(this.listeners['*'], arguments);
      }
    };
  
    Observable.prototype.invoke = function (listeners, params) {
      for (var i = 0, len = listeners.length; i < len; i++) {
        listeners[i].apply(this, params);
      }
    };
  
    Utils.Observable = Observable;
  
    Utils.generateChars = function (length) {
      var chars = '';
  
      for (var i = 0; i < length; i++) {
        var randomChar = Math.floor(Math.random() * 36);
        chars += randomChar.toString(36);
      }
  
      return chars;
    };
  
    Utils.bind = function (func, context) {
      return function () {
        func.apply(context, arguments);
      };
    };
  
    Utils._convertData = function (data) {
      for (var originalKey in data) {
        var keys = originalKey.split('-');
  
        var dataLevel = data;
  
        if (keys.length === 1) {
          continue;
        }
  
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k];
  
          // Lowercase the first letter
          // By default, dash-separated becomes camelCase
          key = key.substring(0, 1).toLowerCase() + key.substring(1);
  
          if (!(key in dataLevel)) {
            dataLevel[key] = {};
          }
  
          if (k == keys.length - 1) {
            dataLevel[key] = data[originalKey];
          }
  
          dataLevel = dataLevel[key];
        }
  
        delete data[originalKey];
      }
  
      return data;
    };
  
    Utils.hasScroll = function (index, el) {
      // Adapted from the function created by @ShadowScripter
      // and adapted by @BillBarry on the Stack Exchange Code Review website.
      // The original code can be found at
      // http://codereview.stackexchange.com/q/13338
      // and was designed to be used with the Sizzle selector engine.
  
      var $el = $(el);
      var overflowX = el.style.overflowX;
      var overflowY = el.style.overflowY;
  
      //Check both x and y declarations
      if (overflowX === overflowY &&
          (overflowY === 'hidden' || overflowY === 'visible')) {
        return false;
      }
  
      if (overflowX === 'scroll' || overflowY === 'scroll') {
        return true;
      }
  
      return ($el.innerHeight() < el.scrollHeight ||
        $el.innerWidth() < el.scrollWidth);
    };
  
    Utils.escapeMarkup = function (markup) {
      var replaceMap = {
        '\\': '&#92;',
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;',
        '/': '&#47;'
      };
  
      // Do not try to escape the markup if it's not a string
      if (typeof markup !== 'string') {
        return markup;
      }
  
      return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
        return replaceMap[match];
      });
    };
  
    // Cache objects in Utils.__cache instead of $.data (see #4346)
    Utils.__cache = {};
  
    var id = 0;
    Utils.GetUniqueElementId = function (element) {
      // Get a unique element Id. If element has no id,
      // creates a new unique number, stores it in the id
      // attribute and returns the new id with a prefix.
      // If an id already exists, it simply returns it with a prefix.
  
      var select2Id = element.getAttribute('data-select2-id');
  
      if (select2Id != null) {
        return select2Id;
      }
  
      // If element has id, use it.
      if (element.id) {
        select2Id = 'select2-data-' + element.id;
      } else {
        select2Id = 'select2-data-' + (++id).toString() +
          '-' + Utils.generateChars(4);
      }
  
      element.setAttribute('data-select2-id', select2Id);
  
      return select2Id;
    };
  
    Utils.StoreData = function (element, name, value) {
      // Stores an item in the cache for a specified element.
      // name is the cache key.
      var id = Utils.GetUniqueElementId(element);
      if (!Utils.__cache[id]) {
        Utils.__cache[id] = {};
      }
  
      Utils.__cache[id][name] = value;
    };
  
    Utils.GetData = function (element, name) {
      // Retrieves a value from the cache by its key (name)
      // name is optional. If no name specified, return
      // all cache items for the specified element.
      // and for a specified element.
      var id = Utils.GetUniqueElementId(element);
      if (name) {
        if (Utils.__cache[id]) {
          if (Utils.__cache[id][name] != null) {
            return Utils.__cache[id][name];
          }
          return $(element).data(name); // Fallback to HTML5 data attribs.
        }
        return $(element).data(name); // Fallback to HTML5 data attribs.
      } else {
        return Utils.__cache[id];
      }
    };
  
    Utils.RemoveData = function (element) {
      // Removes all cached items for a specified element.
      var id = Utils.GetUniqueElementId(element);
      if (Utils.__cache[id] != null) {
        delete Utils.__cache[id];
      }
  
      element.removeAttribute('data-select2-id');
    };
  
    Utils.copyNonInternalCssClasses = function (dest, src) {
      var classes;
  
      var destinationClasses = dest.getAttribute('class').trim().split(/\s+/);
  
      destinationClasses = destinationClasses.filter(function (clazz) {
        // Save all Select2 classes
        return clazz.indexOf('select2-') === 0;
      });
  
      var sourceClasses = src.getAttribute('class').trim().split(/\s+/);
  
      sourceClasses = sourceClasses.filter(function (clazz) {
        // Only copy non-Select2 classes
        return clazz.indexOf('select2-') !== 0;
      });
  
      var replacements = destinationClasses.concat(sourceClasses);
  
      dest.setAttribute('class', replacements.join(' '));
    };
  
    return Utils;
  });
  
  S2.define('select2/results',[
    'jquery',
    './utils'
  ], function ($, Utils) {
    function Results ($element, options, dataAdapter) {
      this.$element = $element;
      this.data = dataAdapter;
      this.options = options;
  
      Results.__super__.constructor.call(this);
    }
  
    Utils.Extend(Results, Utils.Observable);
  
    Results.prototype.render = function () {
      var $results = $(
        '<ul class="select2-results__options" role="listbox"></ul>'
      );
  
      if (this.options.get('multiple')) {
        $results.attr('aria-multiselectable', 'true');
      }
  
      this.$results = $results;
  
      return $results;
    };
  
    Results.prototype.clear = function () {
      this.$results.empty();
    };
  
    Results.prototype.displayMessage = function (params) {
      var escapeMarkup = this.options.get('escapeMarkup');
  
      this.clear();
      this.hideLoading();
  
      var $message = $(
        '<li role="alert" aria-live="assertive"' +
        ' class="select2-results__option"></li>'
      );
  
      var message = this.options.get('translations').get(params.message);
  
      $message.append(
        escapeMarkup(
          message(params.args)
        )
      );
  
      $message[0].className += ' select2-results__message';
  
      this.$results.append($message);
    };
  
    Results.prototype.hideMessages = function () {
      this.$results.find('.select2-results__message').remove();
    };
  
    Results.prototype.append = function (data) {
      this.hideLoading();
  
      var $options = [];
  
      if (data.results == null || data.results.length === 0) {
        if (this.$results.children().length === 0) {
          this.trigger('results:message', {
            message: 'noResults'
          });
        }
  
        return;
      }
  
      data.results = this.sort(data.results);
  
      for (var d = 0; d < data.results.length; d++) {
        var item = data.results[d];
  
        var $option = this.option(item);
  
        $options.push($option);
      }
  
      this.$results.append($options);
    };
  
    Results.prototype.position = function ($results, $dropdown) {
      var $resultsContainer = $dropdown.find('.select2-results');
      $resultsContainer.append($results);
    };
  
    Results.prototype.sort = function (data) {
      var sorter = this.options.get('sorter');
  
      return sorter(data);
    };
  
    Results.prototype.highlightFirstItem = function () {
      var $options = this.$results
        .find('.select2-results__option--selectable');
  
      var $selected = $options.filter('.select2-results__option--selected');
  
      // Check if there are any selected options
      if ($selected.length > 0) {
        // If there are selected options, highlight the first
        $selected.first().trigger('mouseenter');
      } else {
        // If there are no selected options, highlight the first option
        // in the dropdown
        $options.first().trigger('mouseenter');
      }
  
      this.ensureHighlightVisible();
    };
  
    Results.prototype.setClasses = function () {
      var self = this;
  
      this.data.current(function (selected) {
        var selectedIds = selected.map(function (s) {
          return s.id.toString();
        });
  
        var $options = self.$results
          .find('.select2-results__option--selectable');
  
        $options.each(function () {
          var $option = $(this);
  
          var item = Utils.GetData(this, 'data');
  
          // id needs to be converted to a string when comparing
          var id = '' + item.id;
  
          if ((item.element != null && item.element.selected) ||
              (item.element == null && selectedIds.indexOf(id) > -1)) {
            this.classList.add('select2-results__option--selected');
            $option.attr('aria-selected', 'true');
          } else {
            this.classList.remove('select2-results__option--selected');
            $option.attr('aria-selected', 'false');
          }
        });
  
      });
    };
  
    Results.prototype.showLoading = function (params) {
      this.hideLoading();
  
      var loadingMore = this.options.get('translations').get('searching');
  
      var loading = {
        disabled: true,
        loading: true,
        text: loadingMore(params)
      };
      var $loading = this.option(loading);
      $loading.className += ' loading-results';
  
      this.$results.prepend($loading);
    };
  
    Results.prototype.hideLoading = function () {
      this.$results.find('.loading-results').remove();
    };
  
    Results.prototype.option = function (data) {
      var option = document.createElement('li');
      option.classList.add('select2-results__option');
      option.classList.add('select2-results__option--selectable');
  
      var attrs = {
        'role': 'option'
      };
  
      var matches = window.Element.prototype.matches ||
        window.Element.prototype.msMatchesSelector ||
        window.Element.prototype.webkitMatchesSelector;
  
      if ((data.element != null && matches.call(data.element, ':disabled')) ||
          (data.element == null && data.disabled)) {
        attrs['aria-disabled'] = 'true';
  
        option.classList.remove('select2-results__option--selectable');
        option.classList.add('select2-results__option--disabled');
      }
  
      if (data.id == null) {
        option.classList.remove('select2-results__option--selectable');
      }
  
      if (data._resultId != null) {
        option.id = data._resultId;
      }
  
      if (data.title) {
        option.title = data.title;
      }
  
      if (data.children) {
        attrs.role = 'group';
        attrs['aria-label'] = data.text;
  
        option.classList.remove('select2-results__option--selectable');
        option.classList.add('select2-results__option--group');
      }
  
      for (var attr in attrs) {
        var val = attrs[attr];
  
        option.setAttribute(attr, val);
      }
  
      if (data.children) {
        var $option = $(option);
  
        var label = document.createElement('strong');
        label.className = 'select2-results__group';
  
        this.template(data, label);
  
        var $children = [];
  
        for (var c = 0; c < data.children.length; c++) {
          var child = data.children[c];
  
          var $child = this.option(child);
  
          $children.push($child);
        }
  
        var $childrenContainer = $('<ul></ul>', {
          'class': 'select2-results__options select2-results__options--nested',
          'role': 'none'
        });
  
        $childrenContainer.append($children);
  
        $option.append(label);
        $option.append($childrenContainer);
      } else {
        this.template(data, option);
      }
  
      Utils.StoreData(option, 'data', data);
  
      return option;
    };
  
    Results.prototype.bind = function (container, $container) {
      var self = this;
  
      var id = container.id + '-results';
  
      this.$results.attr('id', id);
  
      container.on('results:all', function (params) {
        self.clear();
        self.append(params.data);
  
        if (container.isOpen()) {
          self.setClasses();
          self.highlightFirstItem();
        }
      });
  
      container.on('results:append', function (params) {
        self.append(params.data);
  
        if (container.isOpen()) {
          self.setClasses();
        }
      });
  
      container.on('query', function (params) {
        self.hideMessages();
        self.showLoading(params);
      });
  
      container.on('select', function () {
        if (!container.isOpen()) {
          return;
        }
  
        self.setClasses();
  
        if (self.options.get('scrollAfterSelect')) {
          self.highlightFirstItem();
        }
      });
  
      container.on('unselect', function () {
        if (!container.isOpen()) {
          return;
        }
  
        self.setClasses();
  
        if (self.options.get('scrollAfterSelect')) {
          self.highlightFirstItem();
        }
      });
  
      container.on('open', function () {
        // When the dropdown is open, aria-expended="true"
        self.$results.attr('aria-expanded', 'true');
        self.$results.attr('aria-hidden', 'false');
  
        self.setClasses();
        self.ensureHighlightVisible();
      });
  
      container.on('close', function () {
        // When the dropdown is closed, aria-expended="false"
        self.$results.attr('aria-expanded', 'false');
        self.$results.attr('aria-hidden', 'true');
        self.$results.removeAttr('aria-activedescendant');
      });
  
      container.on('results:toggle', function () {
        var $highlighted = self.getHighlightedResults();
  
        if ($highlighted.length === 0) {
          return;
        }
  
        $highlighted.trigger('mouseup');
      });
  
      container.on('results:select', function () {
        var $highlighted = self.getHighlightedResults();
  
        if ($highlighted.length === 0) {
          return;
        }
  
        var data = Utils.GetData($highlighted[0], 'data');
  
        if ($highlighted.hasClass('select2-results__option--selected')) {
          self.trigger('close', {});
        } else {
          self.trigger('select', {
            data: data
          });
        }
      });
  
      container.on('results:previous', function () {
        var $highlighted = self.getHighlightedResults();
  
        var $options = self.$results.find('.select2-results__option--selectable');
  
        var currentIndex = $options.index($highlighted);
  
        // If we are already at the top, don't move further
        // If no options, currentIndex will be -1
        if (currentIndex <= 0) {
          return;
        }
  
        var nextIndex = currentIndex - 1;
  
        // If none are highlighted, highlight the first
        if ($highlighted.length === 0) {
          nextIndex = 0;
        }
  
        var $next = $options.eq(nextIndex);
  
        $next.trigger('mouseenter');
  
        var currentOffset = self.$results.offset().top;
        var nextTop = $next.offset().top;
        var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
  
        if (nextIndex === 0) {
          self.$results.scrollTop(0);
        } else if (nextTop - currentOffset < 0) {
          self.$results.scrollTop(nextOffset);
        }
      });
  
      container.on('results:next', function () {
        var $highlighted = self.getHighlightedResults();
  
        var $options = self.$results.find('.select2-results__option--selectable');
  
        var currentIndex = $options.index($highlighted);
  
        var nextIndex = currentIndex + 1;
  
        // If we are at the last option, stay there
        if (nextIndex >= $options.length) {
          return;
        }
  
        var $next = $options.eq(nextIndex);
  
        $next.trigger('mouseenter');
  
        var currentOffset = self.$results.offset().top +
          self.$results.outerHeight(false);
        var nextBottom = $next.offset().top + $next.outerHeight(false);
        var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
  
        if (nextIndex === 0) {
          self.$results.scrollTop(0);
        } else if (nextBottom > currentOffset) {
          self.$results.scrollTop(nextOffset);
        }
      });
  
      container.on('results:focus', function (params) {
        params.element[0].classList.add('select2-results__option--highlighted');
        params.element[0].setAttribute('aria-selected', 'true');
      });
  
      container.on('results:message', function (params) {
        self.displayMessage(params);
      });
  
      if ($.fn.mousewheel) {
        this.$results.on('mousewheel', function (e) {
          var top = self.$results.scrollTop();
  
          var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
  
          var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
          var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
  
          if (isAtTop) {
            self.$results.scrollTop(0);
  
            e.preventDefault();
            e.stopPropagation();
          } else if (isAtBottom) {
            self.$results.scrollTop(
              self.$results.get(0).scrollHeight - self.$results.height()
            );
  
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }
  
      this.$results.on('mouseup', '.select2-results__option--selectable',
        function (evt) {
        var $this = $(this);
  
        var data = Utils.GetData(this, 'data');
  
        if ($this.hasClass('select2-results__option--selected')) {
          if (self.options.get('multiple')) {
            self.trigger('unselect', {
              originalEvent: evt,
              data: data
            });
          } else {
            self.trigger('close', {});
          }
  
          return;
        }
  
        self.trigger('select', {
          originalEvent: evt,
          data: data
        });
      });
  
      this.$results.on('mouseenter', '.select2-results__option--selectable',
        function (evt) {
        var data = Utils.GetData(this, 'data');
  
        self.getHighlightedResults()
            .removeClass('select2-results__option--highlighted')
            .attr('aria-selected', 'false');
  
        self.trigger('results:focus', {
          data: data,
          element: $(this)
        });
      });
    };
  
    Results.prototype.getHighlightedResults = function () {
      var $highlighted = this.$results
      .find('.select2-results__option--highlighted');
  
      return $highlighted;
    };
  
    Results.prototype.destroy = function () {
      this.$results.remove();
    };
  
    Results.prototype.ensureHighlightVisible = function () {
      var $highlighted = this.getHighlightedResults();
  
      if ($highlighted.length === 0) {
        return;
      }
  
      var $options = this.$results.find('.select2-results__option--selectable');
  
      var currentIndex = $options.index($highlighted);
  
      var currentOffset = this.$results.offset().top;
      var nextTop = $highlighted.offset().top;
      var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
  
      var offsetDelta = nextTop - currentOffset;
      nextOffset -= $highlighted.outerHeight(false) * 2;
  
      if (currentIndex <= 2) {
        this.$results.scrollTop(0);
      } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
        this.$results.scrollTop(nextOffset);
      }
    };
  
    Results.prototype.template = function (result, container) {
      var template = this.options.get('templateResult');
      var escapeMarkup = this.options.get('escapeMarkup');
  
      var content = template(result, container);
  
      if (content == null) {
        container.style.display = 'none';
      } else if (typeof content === 'string') {
        container.innerHTML = escapeMarkup(content);
      } else {
        $(container).append(content);
      }
    };
  
    return Results;
  });
  
  S2.define('select2/keys',[
  
  ], function () {
    var KEYS = {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      ESC: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      DELETE: 46
    };
  
    return KEYS;
  });
  
  S2.define('select2/selection/base',[
    'jquery',
    '../utils',
    '../keys'
  ], function ($, Utils, KEYS) {
    function BaseSelection ($element, options) {
      this.$element = $element;
      this.options = options;
  
      BaseSelection.__super__.constructor.call(this);
    }
  
    Utils.Extend(BaseSelection, Utils.Observable);
  
    BaseSelection.prototype.render = function () {
      var $selection = $(
        '<span class="select2-selection" role="combobox" ' +
        ' aria-haspopup="true" aria-expanded="false">' +
        '</span>'
      );
  
      this._tabindex = 0;
  
      if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
        this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
      } else if (this.$element.attr('tabindex') != null) {
        this._tabindex = this.$element.attr('tabindex');
      }
  
      $selection.attr('title', this.$element.attr('title'));
      $selection.attr('tabindex', this._tabindex);
      $selection.attr('aria-disabled', 'false');
  
      this.$selection = $selection;
  
      return $selection;
    };
  
    BaseSelection.prototype.bind = function (container, $container) {
      var self = this;
  
      var resultsId = container.id + '-results';
  
      this.container = container;
  
      this.$selection.on('focus', function (evt) {
        self.trigger('focus', evt);
      });
  
      this.$selection.on('blur', function (evt) {
        self._handleBlur(evt);
      });
  
      this.$selection.on('keydown', function (evt) {
        self.trigger('keypress', evt);
  
        if (evt.which === KEYS.SPACE) {
          evt.preventDefault();
        }
      });
  
      container.on('results:focus', function (params) {
        self.$selection.attr('aria-activedescendant', params.data._resultId);
      });
  
      container.on('selection:update', function (params) {
        self.update(params.data);
      });
  
      container.on('open', function () {
        // When the dropdown is open, aria-expanded="true"
        self.$selection.attr('aria-expanded', 'true');
        self.$selection.attr('aria-owns', resultsId);
  
        self._attachCloseHandler(container);
      });
  
      container.on('close', function () {
        // When the dropdown is closed, aria-expanded="false"
        self.$selection.attr('aria-expanded', 'false');
        self.$selection.removeAttr('aria-activedescendant');
        self.$selection.removeAttr('aria-owns');
  
        self.$selection.trigger('focus');
  
        self._detachCloseHandler(container);
      });
  
      container.on('enable', function () {
        self.$selection.attr('tabindex', self._tabindex);
        self.$selection.attr('aria-disabled', 'false');
      });
  
      container.on('disable', function () {
        self.$selection.attr('tabindex', '-1');
        self.$selection.attr('aria-disabled', 'true');
      });
    };
  
    BaseSelection.prototype._handleBlur = function (evt) {
      var self = this;
  
      // This needs to be delayed as the active element is the body when the tab
      // key is pressed, possibly along with others.
      window.setTimeout(function () {
        // Don't trigger `blur` if the focus is still in the selection
        if (
          (document.activeElement == self.$selection[0]) ||
          ($.contains(self.$selection[0], document.activeElement))
        ) {
          return;
        }
  
        self.trigger('blur', evt);
      }, 1);
    };
  
    BaseSelection.prototype._attachCloseHandler = function (container) {
  
      $(document.body).on('mousedown.select2.' + container.id, function (e) {
        var $target = $(e.target);
  
        var $select = $target.closest('.select2');
  
        var $all = $('.select2.select2-container--open');
  
        $all.each(function () {
          if (this == $select[0]) {
            return;
          }
  
          var $element = Utils.GetData(this, 'element');
  
          $element.select2('close');
        });
      });
    };
  
    BaseSelection.prototype._detachCloseHandler = function (container) {
      $(document.body).off('mousedown.select2.' + container.id);
    };
  
    BaseSelection.prototype.position = function ($selection, $container) {
      var $selectionContainer = $container.find('.selection');
      $selectionContainer.append($selection);
    };
  
    BaseSelection.prototype.destroy = function () {
      this._detachCloseHandler(this.container);
    };
  
    BaseSelection.prototype.update = function (data) {
      throw new Error('The `update` method must be defined in child classes.');
    };
  
    /**
     * Helper method to abstract the "enabled" (not "disabled") state of this
     * object.
     *
     * @return {true} if the instance is not disabled.
     * @return {false} if the instance is disabled.
     */
    BaseSelection.prototype.isEnabled = function () {
      return !this.isDisabled();
    };
  
    /**
     * Helper method to abstract the "disabled" state of this object.
     *
     * @return {true} if the disabled option is true.
     * @return {false} if the disabled option is false.
     */
    BaseSelection.prototype.isDisabled = function () {
      return this.options.get('disabled');
    };
  
    return BaseSelection;
  });
  
  S2.define('select2/selection/single',[
    'jquery',
    './base',
    '../utils',
    '../keys'
  ], function ($, BaseSelection, Utils, KEYS) {
    function SingleSelection () {
      SingleSelection.__super__.constructor.apply(this, arguments);
    }
  
    Utils.Extend(SingleSelection, BaseSelection);
  
    SingleSelection.prototype.render = function () {
      var $selection = SingleSelection.__super__.render.call(this);
  
      $selection[0].classList.add('select2-selection--single');
  
      $selection.html(
        '<span class="select2-selection__rendered"></span>' +
        '<span class="select2-selection__arrow" role="presentation">' +
          '<b role="presentation"></b>' +
        '</span>'
      );
  
      return $selection;
    };
  
    SingleSelection.prototype.bind = function (container, $container) {
      var self = this;
  
      SingleSelection.__super__.bind.apply(this, arguments);
  
      var id = container.id + '-container';
  
      this.$selection.find('.select2-selection__rendered')
        .attr('id', id)
        .attr('role', 'textbox')
        .attr('aria-readonly', 'true');
      this.$selection.attr('aria-labelledby', id);
      this.$selection.attr('aria-controls', id);
  
      this.$selection.on('mousedown', function (evt) {
        // Only respond to left clicks
        if (evt.which !== 1) {
          return;
        }
  
        self.trigger('toggle', {
          originalEvent: evt
        });
      });
  
      this.$selection.on('focus', function (evt) {
        // User focuses on the container
      });
  
      this.$selection.on('blur', function (evt) {
        // User exits the container
      });
  
      container.on('focus', function (evt) {
        if (!container.isOpen()) {
          self.$selection.trigger('focus');
        }
      });
    };
  
    SingleSelection.prototype.clear = function () {
      var $rendered = this.$selection.find('.select2-selection__rendered');
      $rendered.empty();
      $rendered.removeAttr('title'); // clear tooltip on empty
    };
  
    SingleSelection.prototype.display = function (data, container) {
      var template = this.options.get('templateSelection');
      var escapeMarkup = this.options.get('escapeMarkup');
  
      return escapeMarkup(template(data, container));
    };
  
    SingleSelection.prototype.selectionContainer = function () {
      return $('<span></span>');
    };
  
    SingleSelection.prototype.update = function (data) {
      if (data.length === 0) {
        this.clear();
        return;
      }
  
      var selection = data[0];
  
      var $rendered = this.$selection.find('.select2-selection__rendered');
      var formatted = this.display(selection, $rendered);
  
      $rendered.empty().append(formatted);
  
      var title = selection.title || selection.text;
  
      if (title) {
        $rendered.attr('title', title);
      } else {
        $rendered.removeAttr('title');
      }
    };
  
    return SingleSelection;
  });
  
  S2.define('select2/selection/multiple',[
    'jquery',
    './base',
    '../utils'
  ], function ($, BaseSelection, Utils) {
    function MultipleSelection ($element, options) {
      MultipleSelection.__super__.constructor.apply(this, arguments);
    }
  
    Utils.Extend(MultipleSelection, BaseSelection);
  
    MultipleSelection.prototype.render = function () {
      var $selection = MultipleSelection.__super__.render.call(this);
  
      $selection[0].classList.add('select2-selection--multiple');
  
      $selection.html(
        '<ul class="select2-selection__rendered"></ul>'
      );
  
      return $selection;
    };
  
    MultipleSelection.prototype.bind = function (container, $container) {
      var self = this;
  
      MultipleSelection.__super__.bind.apply(this, arguments);
  
      var id = container.id + '-container';
      this.$selection.find('.select2-selection__rendered').attr('id', id);
  
      this.$selection.on('click', function (evt) {
        self.trigger('toggle', {
          originalEvent: evt
        });
      });
  
      this.$selection.on(
        'click',
        '.select2-selection__choice__remove',
        function (evt) {
          // Ignore the event if it is disabled
          if (self.isDisabled()) {
            return;
          }
  
          var $remove = $(this);
          var $selection = $remove.parent();
  
          var data = Utils.GetData($selection[0], 'data');
  
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        }
      );
  
      this.$selection.on(
        'keydown',
        '.select2-selection__choice__remove',
        function (evt) {
          // Ignore the event if it is disabled
          if (self.isDisabled()) {
            return;
          }
  
          evt.stopPropagation();
        }
      );
    };
  
    MultipleSelection.prototype.clear = function () {
      var $rendered = this.$selection.find('.select2-selection__rendered');
      $rendered.empty();
      $rendered.removeAttr('title');
    };
  
    MultipleSelection.prototype.display = function (data, container) {
      var template = this.options.get('templateSelection');
      var escapeMarkup = this.options.get('escapeMarkup');
  
      return escapeMarkup(template(data, container));
    };
  
    MultipleSelection.prototype.selectionContainer = function () {
      var $container = $(
        '<li class="select2-selection__choice">' +
          '<button type="button" class="select2-selection__choice__remove" ' +
          'tabindex="-1">' +
            '<span aria-hidden="true">&times;</span>' +
          '</button>' +
          '<span class="select2-selection__choice__display"></span>' +
        '</li>'
      );
  
      return $container;
    };
  
    MultipleSelection.prototype.update = function (data) {
      this.clear();
  
      if (data.length === 0) {
        return;
      }
  
      var $selections = [];
  
      var selectionIdPrefix = this.$selection.find('.select2-selection__rendered')
        .attr('id') + '-choice-';
  
      for (var d = 0; d < data.length; d++) {
        var selection = data[d];
  
        var $selection = this.selectionContainer();
        var formatted = this.display(selection, $selection);
  
        var selectionId = selectionIdPrefix + Utils.generateChars(4) + '-';
  
        if (selection.id) {
          selectionId += selection.id;
        } else {
          selectionId += Utils.generateChars(4);
        }
  
        $selection.find('.select2-selection__choice__display')
          .append(formatted)
          .attr('id', selectionId);
  
        var title = selection.title || selection.text;
  
        if (title) {
          $selection.attr('title', title);
        }
  
        var removeItem = this.options.get('translations').get('removeItem');
  
        var $remove = $selection.find('.select2-selection__choice__remove');
  
        $remove.attr('title', removeItem());
        $remove.attr('aria-label', removeItem());
        $remove.attr('aria-describedby', selectionId);
  
        Utils.StoreData($selection[0], 'data', selection);
  
        $selections.push($selection);
      }
  
      var $rendered = this.$selection.find('.select2-selection__rendered');
  
      $rendered.append($selections);
    };
  
    return MultipleSelection;
  });
  
  S2.define('select2/selection/placeholder',[
  
  ], function () {
    function Placeholder (decorated, $element, options) {
      this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
  
      decorated.call(this, $element, options);
    }
  
    Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
      if (typeof placeholder === 'string') {
        placeholder = {
          id: '',
          text: placeholder
        };
      }
  
      return placeholder;
    };
  
    Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
      var $placeholder = this.selectionContainer();
  
      $placeholder.html(this.display(placeholder));
      $placeholder[0].classList.add('select2-selection__placeholder');
      $placeholder[0].classList.remove('select2-selection__choice');
  
      var placeholderTitle = placeholder.title ||
        placeholder.text ||
        $placeholder.text();
  
      this.$selection.find('.select2-selection__rendered').attr(
        'title',
        placeholderTitle
      );
  
      return $placeholder;
    };
  
    Placeholder.prototype.update = function (decorated, data) {
      var singlePlaceholder = (
        data.length == 1 && data[0].id != this.placeholder.id
      );
      var multipleSelections = data.length > 1;
  
      if (multipleSelections || singlePlaceholder) {
        return decorated.call(this, data);
      }
  
      this.clear();
  
      var $placeholder = this.createPlaceholder(this.placeholder);
  
      this.$selection.find('.select2-selection__rendered').append($placeholder);
    };
  
    return Placeholder;
  });
  
  S2.define('select2/selection/allowClear',[
    'jquery',
    '../keys',
    '../utils'
  ], function ($, KEYS, Utils) {
    function AllowClear () { }
  
    AllowClear.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      decorated.call(this, container, $container);
  
      if (this.placeholder == null) {
        if (this.options.get('debug') && window.console && console.error) {
          console.error(
            'Select2: The `allowClear` option should be used in combination ' +
            'with the `placeholder` option.'
          );
        }
      }
  
      this.$selection.on('mousedown', '.select2-selection__clear',
        function (evt) {
          self._handleClear(evt);
      });
  
      container.on('keypress', function (evt) {
        self._handleKeyboardClear(evt, container);
      });
    };
  
    AllowClear.prototype._handleClear = function (_, evt) {
      // Ignore the event if it is disabled
      if (this.isDisabled()) {
        return;
      }
  
      var $clear = this.$selection.find('.select2-selection__clear');
  
      // Ignore the event if nothing has been selected
      if ($clear.length === 0) {
        return;
      }
  
      evt.stopPropagation();
  
      var data = Utils.GetData($clear[0], 'data');
  
      var previousVal = this.$element.val();
      this.$element.val(this.placeholder.id);
  
      var unselectData = {
        data: data
      };
      this.trigger('clear', unselectData);
      if (unselectData.prevented) {
        this.$element.val(previousVal);
        return;
      }
  
      for (var d = 0; d < data.length; d++) {
        unselectData = {
          data: data[d]
        };
  
        // Trigger the `unselect` event, so people can prevent it from being
        // cleared.
        this.trigger('unselect', unselectData);
  
        // If the event was prevented, don't clear it out.
        if (unselectData.prevented) {
          this.$element.val(previousVal);
          return;
        }
      }
  
      this.$element.trigger('input').trigger('change');
  
      this.trigger('toggle', {});
    };
  
    AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
      if (container.isOpen()) {
        return;
      }
  
      if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
        this._handleClear(evt);
      }
    };
  
    AllowClear.prototype.update = function (decorated, data) {
      decorated.call(this, data);
  
      this.$selection.find('.select2-selection__clear').remove();
      this.$selection[0].classList.remove('select2-selection--clearable');
  
      if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
          data.length === 0) {
        return;
      }
  
      var selectionId = this.$selection.find('.select2-selection__rendered')
        .attr('id');
  
      var removeAll = this.options.get('translations').get('removeAllItems');
  
      var $remove = $(
        '<button type="button" class="select2-selection__clear" tabindex="-1">' +
          '<span aria-hidden="true">&times;</span>' +
        '</button>'
      );
      $remove.attr('title', removeAll());
      $remove.attr('aria-label', removeAll());
      $remove.attr('aria-describedby', selectionId);
      Utils.StoreData($remove[0], 'data', data);
  
      this.$selection.prepend($remove);
      this.$selection[0].classList.add('select2-selection--clearable');
    };
  
    return AllowClear;
  });
  
  S2.define('select2/selection/search',[
    'jquery',
    '../utils',
    '../keys'
  ], function ($, Utils, KEYS) {
    function Search (decorated, $element, options) {
      decorated.call(this, $element, options);
    }
  
    Search.prototype.render = function (decorated) {
      var searchLabel = this.options.get('translations').get('search');
      var $search = $(
        '<span class="select2-search select2-search--inline">' +
          '<textarea class="select2-search__field"'+
          ' type="search" tabindex="-1"' +
          ' autocorrect="off" autocapitalize="none"' +
          ' spellcheck="false" role="searchbox" aria-autocomplete="list" >' +
          '</textarea>' +
        '</span>'
      );
  
      this.$searchContainer = $search;
      this.$search = $search.find('textarea');
  
      this.$search.prop('autocomplete', this.options.get('autocomplete'));
      this.$search.attr('aria-label', searchLabel());
  
      var $rendered = decorated.call(this);
  
      this._transferTabIndex();
      $rendered.append(this.$searchContainer);
  
      return $rendered;
    };
  
    Search.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      var resultsId = container.id + '-results';
      var selectionId = container.id + '-container';
  
      decorated.call(this, container, $container);
  
      self.$search.attr('aria-describedby', selectionId);
  
      container.on('open', function () {
        self.$search.attr('aria-controls', resultsId);
        self.$search.trigger('focus');
      });
  
      container.on('close', function () {
        self.$search.val('');
        self.resizeSearch();
        self.$search.removeAttr('aria-controls');
        self.$search.removeAttr('aria-activedescendant');
        self.$search.trigger('focus');
      });
  
      container.on('enable', function () {
        self.$search.prop('disabled', false);
  
        self._transferTabIndex();
      });
  
      container.on('disable', function () {
        self.$search.prop('disabled', true);
      });
  
      container.on('focus', function (evt) {
        self.$search.trigger('focus');
      });
  
      container.on('results:focus', function (params) {
        if (params.data._resultId) {
          self.$search.attr('aria-activedescendant', params.data._resultId);
        } else {
          self.$search.removeAttr('aria-activedescendant');
        }
      });
  
      this.$selection.on('focusin', '.select2-search--inline', function (evt) {
        self.trigger('focus', evt);
      });
  
      this.$selection.on('focusout', '.select2-search--inline', function (evt) {
        self._handleBlur(evt);
      });
  
      this.$selection.on('keydown', '.select2-search--inline', function (evt) {
        evt.stopPropagation();
  
        self.trigger('keypress', evt);
  
        self._keyUpPrevented = evt.isDefaultPrevented();
  
        var key = evt.which;
  
        if (key === KEYS.BACKSPACE && self.$search.val() === '') {
          var $previousChoice = self.$selection
            .find('.select2-selection__choice').last();
  
          if ($previousChoice.length > 0) {
            var item = Utils.GetData($previousChoice[0], 'data');
  
            self.searchRemoveChoice(item);
  
            evt.preventDefault();
          }
        }
      });
  
      this.$selection.on('click', '.select2-search--inline', function (evt) {
        if (self.$search.val()) {
          evt.stopPropagation();
        }
      });
  
      // Try to detect the IE version should the `documentMode` property that
      // is stored on the document. This is only implemented in IE and is
      // slightly cleaner than doing a user agent check.
      // This property is not available in Edge, but Edge also doesn't have
      // this bug.
      var msie = document.documentMode;
      var disableInputEvents = msie && msie <= 11;
  
      // Workaround for browsers which do not support the `input` event
      // This will prevent double-triggering of events for browsers which support
      // both the `keyup` and `input` events.
      this.$selection.on(
        'input.searchcheck',
        '.select2-search--inline',
        function (evt) {
          // IE will trigger the `input` event when a placeholder is used on a
          // search box. To get around this issue, we are forced to ignore all
          // `input` events in IE and keep using `keyup`.
          if (disableInputEvents) {
            self.$selection.off('input.search input.searchcheck');
            return;
          }
  
          // Unbind the duplicated `keyup` event
          self.$selection.off('keyup.search');
        }
      );
  
      this.$selection.on(
        'keyup.search input.search',
        '.select2-search--inline',
        function (evt) {
          // IE will trigger the `input` event when a placeholder is used on a
          // search box. To get around this issue, we are forced to ignore all
          // `input` events in IE and keep using `keyup`.
          if (disableInputEvents && evt.type === 'input') {
            self.$selection.off('input.search input.searchcheck');
            return;
          }
  
          var key = evt.which;
  
          // We can freely ignore events from modifier keys
          if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
            return;
          }
  
          // Tabbing will be handled during the `keydown` phase
          if (key == KEYS.TAB) {
            return;
          }
  
          self.handleSearch(evt);
        }
      );
    };
  
    /**
     * This method will transfer the tabindex attribute from the rendered
     * selection to the search box. This allows for the search box to be used as
     * the primary focus instead of the selection container.
     *
     * @private
     */
    Search.prototype._transferTabIndex = function (decorated) {
      this.$search.attr('tabindex', this.$selection.attr('tabindex'));
      this.$selection.attr('tabindex', '-1');
    };
  
    Search.prototype.createPlaceholder = function (decorated, placeholder) {
      this.$search.attr('placeholder', placeholder.text);
    };
  
    Search.prototype.update = function (decorated, data) {
      var searchHadFocus = this.$search[0] == document.activeElement;
  
      this.$search.attr('placeholder', '');
  
      decorated.call(this, data);
  
      this.resizeSearch();
      if (searchHadFocus) {
        this.$search.trigger('focus');
      }
    };
  
    Search.prototype.handleSearch = function () {
      this.resizeSearch();
  
      if (!this._keyUpPrevented) {
        var input = this.$search.val();
  
        this.trigger('query', {
          term: input
        });
      }
  
      this._keyUpPrevented = false;
    };
  
    Search.prototype.searchRemoveChoice = function (decorated, item) {
      this.trigger('unselect', {
        data: item
      });
  
      this.$search.val(item.text);
      this.handleSearch();
    };
  
    Search.prototype.resizeSearch = function () {
      this.$search.css('width', '25px');
  
      var width = '100%';
  
      if (this.$search.attr('placeholder') === '') {
        var minimumWidth = this.$search.val().length + 1;
  
        width = (minimumWidth * 0.75) + 'em';
      }
  
      this.$search.css('width', width);
    };
  
    return Search;
  });
  
  S2.define('select2/selection/selectionCss',[
    '../utils'
  ], function (Utils) {
    function SelectionCSS () { }
  
    SelectionCSS.prototype.render = function (decorated) {
      var $selection = decorated.call(this);
  
      var selectionCssClass = this.options.get('selectionCssClass') || '';
  
      if (selectionCssClass.indexOf(':all:') !== -1) {
        selectionCssClass = selectionCssClass.replace(':all:', '');
  
        Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
      }
  
      $selection.addClass(selectionCssClass);
  
      return $selection;
    };
  
    return SelectionCSS;
  });
  
  S2.define('select2/selection/eventRelay',[
    'jquery'
  ], function ($) {
    function EventRelay () { }
  
    EventRelay.prototype.bind = function (decorated, container, $container) {
      var self = this;
      var relayEvents = [
        'open', 'opening',
        'close', 'closing',
        'select', 'selecting',
        'unselect', 'unselecting',
        'clear', 'clearing'
      ];
  
      var preventableEvents = [
        'opening', 'closing', 'selecting', 'unselecting', 'clearing'
      ];
  
      decorated.call(this, container, $container);
  
      container.on('*', function (name, params) {
        // Ignore events that should not be relayed
        if (relayEvents.indexOf(name) === -1) {
          return;
        }
  
        // The parameters should always be an object
        params = params || {};
  
        // Generate the jQuery event for the Select2 event
        var evt = $.Event('select2:' + name, {
          params: params
        });
  
        self.$element.trigger(evt);
  
        // Only handle preventable events if it was one
        if (preventableEvents.indexOf(name) === -1) {
          return;
        }
  
        params.prevented = evt.isDefaultPrevented();
      });
    };
  
    return EventRelay;
  });
  
  S2.define('select2/translation',[
    'jquery',
    'require'
  ], function ($, require) {
    function Translation (dict) {
      this.dict = dict || {};
    }
  
    Translation.prototype.all = function () {
      return this.dict;
    };
  
    Translation.prototype.get = function (key) {
      return this.dict[key];
    };
  
    Translation.prototype.extend = function (translation) {
      this.dict = $.extend({}, translation.all(), this.dict);
    };
  
    // Static functions
  
    Translation._cache = {};
  
    Translation.loadPath = function (path) {
      if (!(path in Translation._cache)) {
        var translations = require(path);
  
        Translation._cache[path] = translations;
      }
  
      return new Translation(Translation._cache[path]);
    };
  
    return Translation;
  });
  
  S2.define('select2/diacritics',[
  
  ], function () {
    var diacritics = {
      '\u24B6': 'A',
      '\uFF21': 'A',
      '\u00C0': 'A',
      '\u00C1': 'A',
      '\u00C2': 'A',
      '\u1EA6': 'A',
      '\u1EA4': 'A',
      '\u1EAA': 'A',
      '\u1EA8': 'A',
      '\u00C3': 'A',
      '\u0100': 'A',
      '\u0102': 'A',
      '\u1EB0': 'A',
      '\u1EAE': 'A',
      '\u1EB4': 'A',
      '\u1EB2': 'A',
      '\u0226': 'A',
      '\u01E0': 'A',
      '\u00C4': 'A',
      '\u01DE': 'A',
      '\u1EA2': 'A',
      '\u00C5': 'A',
      '\u01FA': 'A',
      '\u01CD': 'A',
      '\u0200': 'A',
      '\u0202': 'A',
      '\u1EA0': 'A',
      '\u1EAC': 'A',
      '\u1EB6': 'A',
      '\u1E00': 'A',
      '\u0104': 'A',
      '\u023A': 'A',
      '\u2C6F': 'A',
      '\uA732': 'AA',
      '\u00C6': 'AE',
      '\u01FC': 'AE',
      '\u01E2': 'AE',
      '\uA734': 'AO',
      '\uA736': 'AU',
      '\uA738': 'AV',
      '\uA73A': 'AV',
      '\uA73C': 'AY',
      '\u24B7': 'B',
      '\uFF22': 'B',
      '\u1E02': 'B',
      '\u1E04': 'B',
      '\u1E06': 'B',
      '\u0243': 'B',
      '\u0182': 'B',
      '\u0181': 'B',
      '\u24B8': 'C',
      '\uFF23': 'C',
      '\u0106': 'C',
      '\u0108': 'C',
      '\u010A': 'C',
      '\u010C': 'C',
      '\u00C7': 'C',
      '\u1E08': 'C',
      '\u0187': 'C',
      '\u023B': 'C',
      '\uA73E': 'C',
      '\u24B9': 'D',
      '\uFF24': 'D',
      '\u1E0A': 'D',
      '\u010E': 'D',
      '\u1E0C': 'D',
      '\u1E10': 'D',
      '\u1E12': 'D',
      '\u1E0E': 'D',
      '\u0110': 'D',
      '\u018B': 'D',
      '\u018A': 'D',
      '\u0189': 'D',
      '\uA779': 'D',
      '\u01F1': 'DZ',
      '\u01C4': 'DZ',
      '\u01F2': 'Dz',
      '\u01C5': 'Dz',
      '\u24BA': 'E',
      '\uFF25': 'E',
      '\u00C8': 'E',
      '\u00C9': 'E',
      '\u00CA': 'E',
      '\u1EC0': 'E',
      '\u1EBE': 'E',
      '\u1EC4': 'E',
      '\u1EC2': 'E',
      '\u1EBC': 'E',
      '\u0112': 'E',
      '\u1E14': 'E',
      '\u1E16': 'E',
      '\u0114': 'E',
      '\u0116': 'E',
      '\u00CB': 'E',
      '\u1EBA': 'E',
      '\u011A': 'E',
      '\u0204': 'E',
      '\u0206': 'E',
      '\u1EB8': 'E',
      '\u1EC6': 'E',
      '\u0228': 'E',
      '\u1E1C': 'E',
      '\u0118': 'E',
      '\u1E18': 'E',
      '\u1E1A': 'E',
      '\u0190': 'E',
      '\u018E': 'E',
      '\u24BB': 'F',
      '\uFF26': 'F',
      '\u1E1E': 'F',
      '\u0191': 'F',
      '\uA77B': 'F',
      '\u24BC': 'G',
      '\uFF27': 'G',
      '\u01F4': 'G',
      '\u011C': 'G',
      '\u1E20': 'G',
      '\u011E': 'G',
      '\u0120': 'G',
      '\u01E6': 'G',
      '\u0122': 'G',
      '\u01E4': 'G',
      '\u0193': 'G',
      '\uA7A0': 'G',
      '\uA77D': 'G',
      '\uA77E': 'G',
      '\u24BD': 'H',
      '\uFF28': 'H',
      '\u0124': 'H',
      '\u1E22': 'H',
      '\u1E26': 'H',
      '\u021E': 'H',
      '\u1E24': 'H',
      '\u1E28': 'H',
      '\u1E2A': 'H',
      '\u0126': 'H',
      '\u2C67': 'H',
      '\u2C75': 'H',
      '\uA78D': 'H',
      '\u24BE': 'I',
      '\uFF29': 'I',
      '\u00CC': 'I',
      '\u00CD': 'I',
      '\u00CE': 'I',
      '\u0128': 'I',
      '\u012A': 'I',
      '\u012C': 'I',
      '\u0130': 'I',
      '\u00CF': 'I',
      '\u1E2E': 'I',
      '\u1EC8': 'I',
      '\u01CF': 'I',
      '\u0208': 'I',
      '\u020A': 'I',
      '\u1ECA': 'I',
      '\u012E': 'I',
      '\u1E2C': 'I',
      '\u0197': 'I',
      '\u24BF': 'J',
      '\uFF2A': 'J',
      '\u0134': 'J',
      '\u0248': 'J',
      '\u24C0': 'K',
      '\uFF2B': 'K',
      '\u1E30': 'K',
      '\u01E8': 'K',
      '\u1E32': 'K',
      '\u0136': 'K',
      '\u1E34': 'K',
      '\u0198': 'K',
      '\u2C69': 'K',
      '\uA740': 'K',
      '\uA742': 'K',
      '\uA744': 'K',
      '\uA7A2': 'K',
      '\u24C1': 'L',
      '\uFF2C': 'L',
      '\u013F': 'L',
      '\u0139': 'L',
      '\u013D': 'L',
      '\u1E36': 'L',
      '\u1E38': 'L',
      '\u013B': 'L',
      '\u1E3C': 'L',
      '\u1E3A': 'L',
      '\u0141': 'L',
      '\u023D': 'L',
      '\u2C62': 'L',
      '\u2C60': 'L',
      '\uA748': 'L',
      '\uA746': 'L',
      '\uA780': 'L',
      '\u01C7': 'LJ',
      '\u01C8': 'Lj',
      '\u24C2': 'M',
      '\uFF2D': 'M',
      '\u1E3E': 'M',
      '\u1E40': 'M',
      '\u1E42': 'M',
      '\u2C6E': 'M',
      '\u019C': 'M',
      '\u24C3': 'N',
      '\uFF2E': 'N',
      '\u01F8': 'N',
      '\u0143': 'N',
      '\u00D1': 'N',
      '\u1E44': 'N',
      '\u0147': 'N',
      '\u1E46': 'N',
      '\u0145': 'N',
      '\u1E4A': 'N',
      '\u1E48': 'N',
      '\u0220': 'N',
      '\u019D': 'N',
      '\uA790': 'N',
      '\uA7A4': 'N',
      '\u01CA': 'NJ',
      '\u01CB': 'Nj',
      '\u24C4': 'O',
      '\uFF2F': 'O',
      '\u00D2': 'O',
      '\u00D3': 'O',
      '\u00D4': 'O',
      '\u1ED2': 'O',
      '\u1ED0': 'O',
      '\u1ED6': 'O',
      '\u1ED4': 'O',
      '\u00D5': 'O',
      '\u1E4C': 'O',
      '\u022C': 'O',
      '\u1E4E': 'O',
      '\u014C': 'O',
      '\u1E50': 'O',
      '\u1E52': 'O',
      '\u014E': 'O',
      '\u022E': 'O',
      '\u0230': 'O',
      '\u00D6': 'O',
      '\u022A': 'O',
      '\u1ECE': 'O',
      '\u0150': 'O',
      '\u01D1': 'O',
      '\u020C': 'O',
      '\u020E': 'O',
      '\u01A0': 'O',
      '\u1EDC': 'O',
      '\u1EDA': 'O',
      '\u1EE0': 'O',
      '\u1EDE': 'O',
      '\u1EE2': 'O',
      '\u1ECC': 'O',
      '\u1ED8': 'O',
      '\u01EA': 'O',
      '\u01EC': 'O',
      '\u00D8': 'O',
      '\u01FE': 'O',
      '\u0186': 'O',
      '\u019F': 'O',
      '\uA74A': 'O',
      '\uA74C': 'O',
      '\u0152': 'OE',
      '\u01A2': 'OI',
      '\uA74E': 'OO',
      '\u0222': 'OU',
      '\u24C5': 'P',
      '\uFF30': 'P',
      '\u1E54': 'P',
      '\u1E56': 'P',
      '\u01A4': 'P',
      '\u2C63': 'P',
      '\uA750': 'P',
      '\uA752': 'P',
      '\uA754': 'P',
      '\u24C6': 'Q',
      '\uFF31': 'Q',
      '\uA756': 'Q',
      '\uA758': 'Q',
      '\u024A': 'Q',
      '\u24C7': 'R',
      '\uFF32': 'R',
      '\u0154': 'R',
      '\u1E58': 'R',
      '\u0158': 'R',
      '\u0210': 'R',
      '\u0212': 'R',
      '\u1E5A': 'R',
      '\u1E5C': 'R',
      '\u0156': 'R',
      '\u1E5E': 'R',
      '\u024C': 'R',
      '\u2C64': 'R',
      '\uA75A': 'R',
      '\uA7A6': 'R',
      '\uA782': 'R',
      '\u24C8': 'S',
      '\uFF33': 'S',
      '\u1E9E': 'S',
      '\u015A': 'S',
      '\u1E64': 'S',
      '\u015C': 'S',
      '\u1E60': 'S',
      '\u0160': 'S',
      '\u1E66': 'S',
      '\u1E62': 'S',
      '\u1E68': 'S',
      '\u0218': 'S',
      '\u015E': 'S',
      '\u2C7E': 'S',
      '\uA7A8': 'S',
      '\uA784': 'S',
      '\u24C9': 'T',
      '\uFF34': 'T',
      '\u1E6A': 'T',
      '\u0164': 'T',
      '\u1E6C': 'T',
      '\u021A': 'T',
      '\u0162': 'T',
      '\u1E70': 'T',
      '\u1E6E': 'T',
      '\u0166': 'T',
      '\u01AC': 'T',
      '\u01AE': 'T',
      '\u023E': 'T',
      '\uA786': 'T',
      '\uA728': 'TZ',
      '\u24CA': 'U',
      '\uFF35': 'U',
      '\u00D9': 'U',
      '\u00DA': 'U',
      '\u00DB': 'U',
      '\u0168': 'U',
      '\u1E78': 'U',
      '\u016A': 'U',
      '\u1E7A': 'U',
      '\u016C': 'U',
      '\u00DC': 'U',
      '\u01DB': 'U',
      '\u01D7': 'U',
      '\u01D5': 'U',
      '\u01D9': 'U',
      '\u1EE6': 'U',
      '\u016E': 'U',
      '\u0170': 'U',
      '\u01D3': 'U',
      '\u0214': 'U',
      '\u0216': 'U',
      '\u01AF': 'U',
      '\u1EEA': 'U',
      '\u1EE8': 'U',
      '\u1EEE': 'U',
      '\u1EEC': 'U',
      '\u1EF0': 'U',
      '\u1EE4': 'U',
      '\u1E72': 'U',
      '\u0172': 'U',
      '\u1E76': 'U',
      '\u1E74': 'U',
      '\u0244': 'U',
      '\u24CB': 'V',
      '\uFF36': 'V',
      '\u1E7C': 'V',
      '\u1E7E': 'V',
      '\u01B2': 'V',
      '\uA75E': 'V',
      '\u0245': 'V',
      '\uA760': 'VY',
      '\u24CC': 'W',
      '\uFF37': 'W',
      '\u1E80': 'W',
      '\u1E82': 'W',
      '\u0174': 'W',
      '\u1E86': 'W',
      '\u1E84': 'W',
      '\u1E88': 'W',
      '\u2C72': 'W',
      '\u24CD': 'X',
      '\uFF38': 'X',
      '\u1E8A': 'X',
      '\u1E8C': 'X',
      '\u24CE': 'Y',
      '\uFF39': 'Y',
      '\u1EF2': 'Y',
      '\u00DD': 'Y',
      '\u0176': 'Y',
      '\u1EF8': 'Y',
      '\u0232': 'Y',
      '\u1E8E': 'Y',
      '\u0178': 'Y',
      '\u1EF6': 'Y',
      '\u1EF4': 'Y',
      '\u01B3': 'Y',
      '\u024E': 'Y',
      '\u1EFE': 'Y',
      '\u24CF': 'Z',
      '\uFF3A': 'Z',
      '\u0179': 'Z',
      '\u1E90': 'Z',
      '\u017B': 'Z',
      '\u017D': 'Z',
      '\u1E92': 'Z',
      '\u1E94': 'Z',
      '\u01B5': 'Z',
      '\u0224': 'Z',
      '\u2C7F': 'Z',
      '\u2C6B': 'Z',
      '\uA762': 'Z',
      '\u24D0': 'a',
      '\uFF41': 'a',
      '\u1E9A': 'a',
      '\u00E0': 'a',
      '\u00E1': 'a',
      '\u00E2': 'a',
      '\u1EA7': 'a',
      '\u1EA5': 'a',
      '\u1EAB': 'a',
      '\u1EA9': 'a',
      '\u00E3': 'a',
      '\u0101': 'a',
      '\u0103': 'a',
      '\u1EB1': 'a',
      '\u1EAF': 'a',
      '\u1EB5': 'a',
      '\u1EB3': 'a',
      '\u0227': 'a',
      '\u01E1': 'a',
      '\u00E4': 'a',
      '\u01DF': 'a',
      '\u1EA3': 'a',
      '\u00E5': 'a',
      '\u01FB': 'a',
      '\u01CE': 'a',
      '\u0201': 'a',
      '\u0203': 'a',
      '\u1EA1': 'a',
      '\u1EAD': 'a',
      '\u1EB7': 'a',
      '\u1E01': 'a',
      '\u0105': 'a',
      '\u2C65': 'a',
      '\u0250': 'a',
      '\uA733': 'aa',
      '\u00E6': 'ae',
      '\u01FD': 'ae',
      '\u01E3': 'ae',
      '\uA735': 'ao',
      '\uA737': 'au',
      '\uA739': 'av',
      '\uA73B': 'av',
      '\uA73D': 'ay',
      '\u24D1': 'b',
      '\uFF42': 'b',
      '\u1E03': 'b',
      '\u1E05': 'b',
      '\u1E07': 'b',
      '\u0180': 'b',
      '\u0183': 'b',
      '\u0253': 'b',
      '\u24D2': 'c',
      '\uFF43': 'c',
      '\u0107': 'c',
      '\u0109': 'c',
      '\u010B': 'c',
      '\u010D': 'c',
      '\u00E7': 'c',
      '\u1E09': 'c',
      '\u0188': 'c',
      '\u023C': 'c',
      '\uA73F': 'c',
      '\u2184': 'c',
      '\u24D3': 'd',
      '\uFF44': 'd',
      '\u1E0B': 'd',
      '\u010F': 'd',
      '\u1E0D': 'd',
      '\u1E11': 'd',
      '\u1E13': 'd',
      '\u1E0F': 'd',
      '\u0111': 'd',
      '\u018C': 'd',
      '\u0256': 'd',
      '\u0257': 'd',
      '\uA77A': 'd',
      '\u01F3': 'dz',
      '\u01C6': 'dz',
      '\u24D4': 'e',
      '\uFF45': 'e',
      '\u00E8': 'e',
      '\u00E9': 'e',
      '\u00EA': 'e',
      '\u1EC1': 'e',
      '\u1EBF': 'e',
      '\u1EC5': 'e',
      '\u1EC3': 'e',
      '\u1EBD': 'e',
      '\u0113': 'e',
      '\u1E15': 'e',
      '\u1E17': 'e',
      '\u0115': 'e',
      '\u0117': 'e',
      '\u00EB': 'e',
      '\u1EBB': 'e',
      '\u011B': 'e',
      '\u0205': 'e',
      '\u0207': 'e',
      '\u1EB9': 'e',
      '\u1EC7': 'e',
      '\u0229': 'e',
      '\u1E1D': 'e',
      '\u0119': 'e',
      '\u1E19': 'e',
      '\u1E1B': 'e',
      '\u0247': 'e',
      '\u025B': 'e',
      '\u01DD': 'e',
      '\u24D5': 'f',
      '\uFF46': 'f',
      '\u1E1F': 'f',
      '\u0192': 'f',
      '\uA77C': 'f',
      '\u24D6': 'g',
      '\uFF47': 'g',
      '\u01F5': 'g',
      '\u011D': 'g',
      '\u1E21': 'g',
      '\u011F': 'g',
      '\u0121': 'g',
      '\u01E7': 'g',
      '\u0123': 'g',
      '\u01E5': 'g',
      '\u0260': 'g',
      '\uA7A1': 'g',
      '\u1D79': 'g',
      '\uA77F': 'g',
      '\u24D7': 'h',
      '\uFF48': 'h',
      '\u0125': 'h',
      '\u1E23': 'h',
      '\u1E27': 'h',
      '\u021F': 'h',
      '\u1E25': 'h',
      '\u1E29': 'h',
      '\u1E2B': 'h',
      '\u1E96': 'h',
      '\u0127': 'h',
      '\u2C68': 'h',
      '\u2C76': 'h',
      '\u0265': 'h',
      '\u0195': 'hv',
      '\u24D8': 'i',
      '\uFF49': 'i',
      '\u00EC': 'i',
      '\u00ED': 'i',
      '\u00EE': 'i',
      '\u0129': 'i',
      '\u012B': 'i',
      '\u012D': 'i',
      '\u00EF': 'i',
      '\u1E2F': 'i',
      '\u1EC9': 'i',
      '\u01D0': 'i',
      '\u0209': 'i',
      '\u020B': 'i',
      '\u1ECB': 'i',
      '\u012F': 'i',
      '\u1E2D': 'i',
      '\u0268': 'i',
      '\u0131': 'i',
      '\u24D9': 'j',
      '\uFF4A': 'j',
      '\u0135': 'j',
      '\u01F0': 'j',
      '\u0249': 'j',
      '\u24DA': 'k',
      '\uFF4B': 'k',
      '\u1E31': 'k',
      '\u01E9': 'k',
      '\u1E33': 'k',
      '\u0137': 'k',
      '\u1E35': 'k',
      '\u0199': 'k',
      '\u2C6A': 'k',
      '\uA741': 'k',
      '\uA743': 'k',
      '\uA745': 'k',
      '\uA7A3': 'k',
      '\u24DB': 'l',
      '\uFF4C': 'l',
      '\u0140': 'l',
      '\u013A': 'l',
      '\u013E': 'l',
      '\u1E37': 'l',
      '\u1E39': 'l',
      '\u013C': 'l',
      '\u1E3D': 'l',
      '\u1E3B': 'l',
      '\u017F': 'l',
      '\u0142': 'l',
      '\u019A': 'l',
      '\u026B': 'l',
      '\u2C61': 'l',
      '\uA749': 'l',
      '\uA781': 'l',
      '\uA747': 'l',
      '\u01C9': 'lj',
      '\u24DC': 'm',
      '\uFF4D': 'm',
      '\u1E3F': 'm',
      '\u1E41': 'm',
      '\u1E43': 'm',
      '\u0271': 'm',
      '\u026F': 'm',
      '\u24DD': 'n',
      '\uFF4E': 'n',
      '\u01F9': 'n',
      '\u0144': 'n',
      '\u00F1': 'n',
      '\u1E45': 'n',
      '\u0148': 'n',
      '\u1E47': 'n',
      '\u0146': 'n',
      '\u1E4B': 'n',
      '\u1E49': 'n',
      '\u019E': 'n',
      '\u0272': 'n',
      '\u0149': 'n',
      '\uA791': 'n',
      '\uA7A5': 'n',
      '\u01CC': 'nj',
      '\u24DE': 'o',
      '\uFF4F': 'o',
      '\u00F2': 'o',
      '\u00F3': 'o',
      '\u00F4': 'o',
      '\u1ED3': 'o',
      '\u1ED1': 'o',
      '\u1ED7': 'o',
      '\u1ED5': 'o',
      '\u00F5': 'o',
      '\u1E4D': 'o',
      '\u022D': 'o',
      '\u1E4F': 'o',
      '\u014D': 'o',
      '\u1E51': 'o',
      '\u1E53': 'o',
      '\u014F': 'o',
      '\u022F': 'o',
      '\u0231': 'o',
      '\u00F6': 'o',
      '\u022B': 'o',
      '\u1ECF': 'o',
      '\u0151': 'o',
      '\u01D2': 'o',
      '\u020D': 'o',
      '\u020F': 'o',
      '\u01A1': 'o',
      '\u1EDD': 'o',
      '\u1EDB': 'o',
      '\u1EE1': 'o',
      '\u1EDF': 'o',
      '\u1EE3': 'o',
      '\u1ECD': 'o',
      '\u1ED9': 'o',
      '\u01EB': 'o',
      '\u01ED': 'o',
      '\u00F8': 'o',
      '\u01FF': 'o',
      '\u0254': 'o',
      '\uA74B': 'o',
      '\uA74D': 'o',
      '\u0275': 'o',
      '\u0153': 'oe',
      '\u01A3': 'oi',
      '\u0223': 'ou',
      '\uA74F': 'oo',
      '\u24DF': 'p',
      '\uFF50': 'p',
      '\u1E55': 'p',
      '\u1E57': 'p',
      '\u01A5': 'p',
      '\u1D7D': 'p',
      '\uA751': 'p',
      '\uA753': 'p',
      '\uA755': 'p',
      '\u24E0': 'q',
      '\uFF51': 'q',
      '\u024B': 'q',
      '\uA757': 'q',
      '\uA759': 'q',
      '\u24E1': 'r',
      '\uFF52': 'r',
      '\u0155': 'r',
      '\u1E59': 'r',
      '\u0159': 'r',
      '\u0211': 'r',
      '\u0213': 'r',
      '\u1E5B': 'r',
      '\u1E5D': 'r',
      '\u0157': 'r',
      '\u1E5F': 'r',
      '\u024D': 'r',
      '\u027D': 'r',
      '\uA75B': 'r',
      '\uA7A7': 'r',
      '\uA783': 'r',
      '\u24E2': 's',
      '\uFF53': 's',
      '\u00DF': 's',
      '\u015B': 's',
      '\u1E65': 's',
      '\u015D': 's',
      '\u1E61': 's',
      '\u0161': 's',
      '\u1E67': 's',
      '\u1E63': 's',
      '\u1E69': 's',
      '\u0219': 's',
      '\u015F': 's',
      '\u023F': 's',
      '\uA7A9': 's',
      '\uA785': 's',
      '\u1E9B': 's',
      '\u24E3': 't',
      '\uFF54': 't',
      '\u1E6B': 't',
      '\u1E97': 't',
      '\u0165': 't',
      '\u1E6D': 't',
      '\u021B': 't',
      '\u0163': 't',
      '\u1E71': 't',
      '\u1E6F': 't',
      '\u0167': 't',
      '\u01AD': 't',
      '\u0288': 't',
      '\u2C66': 't',
      '\uA787': 't',
      '\uA729': 'tz',
      '\u24E4': 'u',
      '\uFF55': 'u',
      '\u00F9': 'u',
      '\u00FA': 'u',
      '\u00FB': 'u',
      '\u0169': 'u',
      '\u1E79': 'u',
      '\u016B': 'u',
      '\u1E7B': 'u',
      '\u016D': 'u',
      '\u00FC': 'u',
      '\u01DC': 'u',
      '\u01D8': 'u',
      '\u01D6': 'u',
      '\u01DA': 'u',
      '\u1EE7': 'u',
      '\u016F': 'u',
      '\u0171': 'u',
      '\u01D4': 'u',
      '\u0215': 'u',
      '\u0217': 'u',
      '\u01B0': 'u',
      '\u1EEB': 'u',
      '\u1EE9': 'u',
      '\u1EEF': 'u',
      '\u1EED': 'u',
      '\u1EF1': 'u',
      '\u1EE5': 'u',
      '\u1E73': 'u',
      '\u0173': 'u',
      '\u1E77': 'u',
      '\u1E75': 'u',
      '\u0289': 'u',
      '\u24E5': 'v',
      '\uFF56': 'v',
      '\u1E7D': 'v',
      '\u1E7F': 'v',
      '\u028B': 'v',
      '\uA75F': 'v',
      '\u028C': 'v',
      '\uA761': 'vy',
      '\u24E6': 'w',
      '\uFF57': 'w',
      '\u1E81': 'w',
      '\u1E83': 'w',
      '\u0175': 'w',
      '\u1E87': 'w',
      '\u1E85': 'w',
      '\u1E98': 'w',
      '\u1E89': 'w',
      '\u2C73': 'w',
      '\u24E7': 'x',
      '\uFF58': 'x',
      '\u1E8B': 'x',
      '\u1E8D': 'x',
      '\u24E8': 'y',
      '\uFF59': 'y',
      '\u1EF3': 'y',
      '\u00FD': 'y',
      '\u0177': 'y',
      '\u1EF9': 'y',
      '\u0233': 'y',
      '\u1E8F': 'y',
      '\u00FF': 'y',
      '\u1EF7': 'y',
      '\u1E99': 'y',
      '\u1EF5': 'y',
      '\u01B4': 'y',
      '\u024F': 'y',
      '\u1EFF': 'y',
      '\u24E9': 'z',
      '\uFF5A': 'z',
      '\u017A': 'z',
      '\u1E91': 'z',
      '\u017C': 'z',
      '\u017E': 'z',
      '\u1E93': 'z',
      '\u1E95': 'z',
      '\u01B6': 'z',
      '\u0225': 'z',
      '\u0240': 'z',
      '\u2C6C': 'z',
      '\uA763': 'z',
      '\u0386': '\u0391',
      '\u0388': '\u0395',
      '\u0389': '\u0397',
      '\u038A': '\u0399',
      '\u03AA': '\u0399',
      '\u038C': '\u039F',
      '\u038E': '\u03A5',
      '\u03AB': '\u03A5',
      '\u038F': '\u03A9',
      '\u03AC': '\u03B1',
      '\u03AD': '\u03B5',
      '\u03AE': '\u03B7',
      '\u03AF': '\u03B9',
      '\u03CA': '\u03B9',
      '\u0390': '\u03B9',
      '\u03CC': '\u03BF',
      '\u03CD': '\u03C5',
      '\u03CB': '\u03C5',
      '\u03B0': '\u03C5',
      '\u03CE': '\u03C9',
      '\u03C2': '\u03C3',
      '\u2019': '\''
    };
  
    return diacritics;
  });
  
  S2.define('select2/data/base',[
    '../utils'
  ], function (Utils) {
    function BaseAdapter ($element, options) {
      BaseAdapter.__super__.constructor.call(this);
    }
  
    Utils.Extend(BaseAdapter, Utils.Observable);
  
    BaseAdapter.prototype.current = function (callback) {
      throw new Error('The `current` method must be defined in child classes.');
    };
  
    BaseAdapter.prototype.query = function (params, callback) {
      throw new Error('The `query` method must be defined in child classes.');
    };
  
    BaseAdapter.prototype.bind = function (container, $container) {
      // Can be implemented in subclasses
    };
  
    BaseAdapter.prototype.destroy = function () {
      // Can be implemented in subclasses
    };
  
    BaseAdapter.prototype.generateResultId = function (container, data) {
      var id = container.id + '-result-';
  
      id += Utils.generateChars(4);
  
      if (data.id != null) {
        id += '-' + data.id.toString();
      } else {
        id += '-' + Utils.generateChars(4);
      }
      return id;
    };
  
    return BaseAdapter;
  });
  
  S2.define('select2/data/select',[
    './base',
    '../utils',
    'jquery'
  ], function (BaseAdapter, Utils, $) {
    function SelectAdapter ($element, options) {
      this.$element = $element;
      this.options = options;
  
      SelectAdapter.__super__.constructor.call(this);
    }
  
    Utils.Extend(SelectAdapter, BaseAdapter);
  
    SelectAdapter.prototype.current = function (callback) {
      var self = this;
  
      var data = Array.prototype.map.call(
        this.$element[0].querySelectorAll(':checked'),
        function (selectedElement) {
          return self.item($(selectedElement));
        }
      );
  
      callback(data);
    };
  
    SelectAdapter.prototype.select = function (data) {
      var self = this;
  
      data.selected = true;
  
      // If data.element is a DOM node, use it instead
      if (
        data.element != null && data.element.tagName.toLowerCase() === 'option'
      ) {
        data.element.selected = true;
  
        this.$element.trigger('input').trigger('change');
  
        return;
      }
  
      if (this.$element.prop('multiple')) {
        this.current(function (currentData) {
          var val = [];
  
          data = [data];
          data.push.apply(data, currentData);
  
          for (var d = 0; d < data.length; d++) {
            var id = data[d].id;
  
            if (val.indexOf(id) === -1) {
              val.push(id);
            }
          }
  
          self.$element.val(val);
          self.$element.trigger('input').trigger('change');
        });
      } else {
        var val = data.id;
  
        this.$element.val(val);
        this.$element.trigger('input').trigger('change');
      }
    };
  
    SelectAdapter.prototype.unselect = function (data) {
      var self = this;
  
      if (!this.$element.prop('multiple')) {
        return;
      }
  
      data.selected = false;
  
      if (
        data.element != null &&
        data.element.tagName.toLowerCase() === 'option'
      ) {
        data.element.selected = false;
  
        this.$element.trigger('input').trigger('change');
  
        return;
      }
  
      this.current(function (currentData) {
        var val = [];
  
        for (var d = 0; d < currentData.length; d++) {
          var id = currentData[d].id;
  
          if (id !== data.id && val.indexOf(id) === -1) {
            val.push(id);
          }
        }
  
        self.$element.val(val);
  
        self.$element.trigger('input').trigger('change');
      });
    };
  
    SelectAdapter.prototype.bind = function (container, $container) {
      var self = this;
  
      this.container = container;
  
      container.on('select', function (params) {
        self.select(params.data);
      });
  
      container.on('unselect', function (params) {
        self.unselect(params.data);
      });
    };
  
    SelectAdapter.prototype.destroy = function () {
      // Remove anything added to child elements
      this.$element.find('*').each(function () {
        // Remove any custom data set by Select2
        Utils.RemoveData(this);
      });
    };
  
    SelectAdapter.prototype.query = function (params, callback) {
      var data = [];
      var self = this;
  
      var $options = this.$element.children();
  
      $options.each(function () {
        if (
          this.tagName.toLowerCase() !== 'option' &&
          this.tagName.toLowerCase() !== 'optgroup'
        ) {
          return;
        }
  
        var $option = $(this);
  
        var option = self.item($option);
  
        var matches = self.matches(params, option);
  
        if (matches !== null) {
          data.push(matches);
        }
      });
  
      callback({
        results: data
      });
    };
  
    SelectAdapter.prototype.addOptions = function ($options) {
      this.$element.append($options);
    };
  
    SelectAdapter.prototype.option = function (data) {
      var option;
  
      if (data.children) {
        option = document.createElement('optgroup');
        option.label = data.text;
      } else {
        option = document.createElement('option');
  
        if (option.textContent !== undefined) {
          option.textContent = data.text;
        } else {
          option.innerText = data.text;
        }
      }
  
      if (data.id !== undefined) {
        option.value = data.id;
      }
  
      if (data.disabled) {
        option.disabled = true;
      }
  
      if (data.selected) {
        option.selected = true;
      }
  
      if (data.title) {
        option.title = data.title;
      }
  
      var normalizedData = this._normalizeItem(data);
      normalizedData.element = option;
  
      // Override the option's data with the combined data
      Utils.StoreData(option, 'data', normalizedData);
  
      return $(option);
    };
  
    SelectAdapter.prototype.item = function ($option) {
      var data = {};
  
      data = Utils.GetData($option[0], 'data');
  
      if (data != null) {
        return data;
      }
  
      var option = $option[0];
  
      if (option.tagName.toLowerCase() === 'option') {
        data = {
          id: $option.val(),
          text: $option.text(),
          disabled: $option.prop('disabled'),
          selected: $option.prop('selected'),
          title: $option.prop('title')
        };
      } else if (option.tagName.toLowerCase() === 'optgroup') {
        data = {
          text: $option.prop('label'),
          children: [],
          title: $option.prop('title')
        };
  
        var $children = $option.children('option');
        var children = [];
  
        for (var c = 0; c < $children.length; c++) {
          var $child = $($children[c]);
  
          var child = this.item($child);
  
          children.push(child);
        }
  
        data.children = children;
      }
  
      data = this._normalizeItem(data);
      data.element = $option[0];
  
      Utils.StoreData($option[0], 'data', data);
  
      return data;
    };
  
    SelectAdapter.prototype._normalizeItem = function (item) {
      if (item !== Object(item)) {
        item = {
          id: item,
          text: item
        };
      }
  
      item = $.extend({}, {
        text: ''
      }, item);
  
      var defaults = {
        selected: false,
        disabled: false
      };
  
      if (item.id != null) {
        item.id = item.id.toString();
      }
  
      if (item.text != null) {
        item.text = item.text.toString();
      }
  
      if (item._resultId == null && item.id && this.container != null) {
        item._resultId = this.generateResultId(this.container, item);
      }
  
      return $.extend({}, defaults, item);
    };
  
    SelectAdapter.prototype.matches = function (params, data) {
      var matcher = this.options.get('matcher');
  
      return matcher(params, data);
    };
  
    return SelectAdapter;
  });
  
  S2.define('select2/data/array',[
    './select',
    '../utils',
    'jquery'
  ], function (SelectAdapter, Utils, $) {
    function ArrayAdapter ($element, options) {
      this._dataToConvert = options.get('data') || [];
  
      ArrayAdapter.__super__.constructor.call(this, $element, options);
    }
  
    Utils.Extend(ArrayAdapter, SelectAdapter);
  
    ArrayAdapter.prototype.bind = function (container, $container) {
      ArrayAdapter.__super__.bind.call(this, container, $container);
  
      this.addOptions(this.convertToOptions(this._dataToConvert));
    };
  
    ArrayAdapter.prototype.select = function (data) {
      var $option = this.$element.find('option').filter(function (i, elm) {
        return elm.value == data.id.toString();
      });
  
      if ($option.length === 0) {
        $option = this.option(data);
  
        this.addOptions($option);
      }
  
      ArrayAdapter.__super__.select.call(this, data);
    };
  
    ArrayAdapter.prototype.convertToOptions = function (data) {
      var self = this;
  
      var $existing = this.$element.find('option');
      var existingIds = $existing.map(function () {
        return self.item($(this)).id;
      }).get();
  
      var $options = [];
  
      // Filter out all items except for the one passed in the argument
      function onlyItem (item) {
        return function () {
          return $(this).val() == item.id;
        };
      }
  
      for (var d = 0; d < data.length; d++) {
        var item = this._normalizeItem(data[d]);
  
        // Skip items which were pre-loaded, only merge the data
        if (existingIds.indexOf(item.id) >= 0) {
          var $existingOption = $existing.filter(onlyItem(item));
  
          var existingData = this.item($existingOption);
          var newData = $.extend(true, {}, item, existingData);
  
          var $newOption = this.option(newData);
  
          $existingOption.replaceWith($newOption);
  
          continue;
        }
  
        var $option = this.option(item);
  
        if (item.children) {
          var $children = this.convertToOptions(item.children);
  
          $option.append($children);
        }
  
        $options.push($option);
      }
  
      return $options;
    };
  
    return ArrayAdapter;
  });
  
  S2.define('select2/data/ajax',[
    './array',
    '../utils',
    'jquery'
  ], function (ArrayAdapter, Utils, $) {
    function AjaxAdapter ($element, options) {
      this.ajaxOptions = this._applyDefaults(options.get('ajax'));
  
      if (this.ajaxOptions.processResults != null) {
        this.processResults = this.ajaxOptions.processResults;
      }
  
      AjaxAdapter.__super__.constructor.call(this, $element, options);
    }
  
    Utils.Extend(AjaxAdapter, ArrayAdapter);
  
    AjaxAdapter.prototype._applyDefaults = function (options) {
      var defaults = {
        data: function (params) {
          return $.extend({}, params, {
            q: params.term
          });
        },
        transport: function (params, success, failure) {
          var $request = $.ajax(params);
  
          $request.then(success);
          $request.fail(failure);
  
          return $request;
        }
      };
  
      return $.extend({}, defaults, options, true);
    };
  
    AjaxAdapter.prototype.processResults = function (results) {
      return results;
    };
  
    AjaxAdapter.prototype.query = function (params, callback) {
      var matches = [];
      var self = this;
  
      if (this._request != null) {
        // JSONP requests cannot always be aborted
        if (typeof this._request.abort === 'function') {
          this._request.abort();
        }
  
        this._request = null;
      }
  
      var options = $.extend({
        type: 'GET'
      }, this.ajaxOptions);
  
      if (typeof options.url === 'function') {
        options.url = options.url.call(this.$element, params);
      }
  
      if (typeof options.data === 'function') {
        options.data = options.data.call(this.$element, params);
      }
  
      function request () {
        var $request = options.transport(options, function (data) {
          var results = self.processResults(data, params);
  
          if (self.options.get('debug') && window.console && console.error) {
            // Check to make sure that the response included a `results` key.
            if (!results || !results.results || !Array.isArray(results.results)) {
              console.error(
                'Select2: The AJAX results did not return an array in the ' +
                '`results` key of the response.'
              );
            }
          }
  
          callback(results);
        }, function () {
          // Attempt to detect if a request was aborted
          // Only works if the transport exposes a status property
          if ('status' in $request &&
              ($request.status === 0 || $request.status === '0')) {
            return;
          }
  
          self.trigger('results:message', {
            message: 'errorLoading'
          });
        });
  
        self._request = $request;
      }
  
      if (this.ajaxOptions.delay && params.term != null) {
        if (this._queryTimeout) {
          window.clearTimeout(this._queryTimeout);
        }
  
        this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
      } else {
        request();
      }
    };
  
    return AjaxAdapter;
  });
  
  S2.define('select2/data/tags',[
    'jquery'
  ], function ($) {
    function Tags (decorated, $element, options) {
      var tags = options.get('tags');
  
      var createTag = options.get('createTag');
  
      if (createTag !== undefined) {
        this.createTag = createTag;
      }
  
      var insertTag = options.get('insertTag');
  
      if (insertTag !== undefined) {
          this.insertTag = insertTag;
      }
  
      decorated.call(this, $element, options);
  
      if (Array.isArray(tags)) {
        for (var t = 0; t < tags.length; t++) {
          var tag = tags[t];
          var item = this._normalizeItem(tag);
  
          var $option = this.option(item);
  
          this.$element.append($option);
        }
      }
    }
  
    Tags.prototype.query = function (decorated, params, callback) {
      var self = this;
  
      this._removeOldTags();
  
      if (params.term == null || params.page != null) {
        decorated.call(this, params, callback);
        return;
      }
  
      function wrapper (obj, child) {
        var data = obj.results;
  
        for (var i = 0; i < data.length; i++) {
          var option = data[i];
  
          var checkChildren = (
            option.children != null &&
            !wrapper({
              results: option.children
            }, true)
          );
  
          var optionText = (option.text || '').toUpperCase();
          var paramsTerm = (params.term || '').toUpperCase();
  
          var checkText = optionText === paramsTerm;
  
          if (checkText || checkChildren) {
            if (child) {
              return false;
            }
  
            obj.data = data;
            callback(obj);
  
            return;
          }
        }
  
        if (child) {
          return true;
        }
  
        var tag = self.createTag(params);
  
        if (tag != null) {
          var $option = self.option(tag);
          $option.attr('data-select2-tag', 'true');
  
          self.addOptions([$option]);
  
          self.insertTag(data, tag);
        }
  
        obj.results = data;
  
        callback(obj);
      }
  
      decorated.call(this, params, wrapper);
    };
  
    Tags.prototype.createTag = function (decorated, params) {
      if (params.term == null) {
        return null;
      }
  
      var term = params.term.trim();
  
      if (term === '') {
        return null;
      }
  
      return {
        id: term,
        text: term
      };
    };
  
    Tags.prototype.insertTag = function (_, data, tag) {
      data.unshift(tag);
    };
  
    Tags.prototype._removeOldTags = function (_) {
      var $options = this.$element.find('option[data-select2-tag]');
  
      $options.each(function () {
        if (this.selected) {
          return;
        }
  
        $(this).remove();
      });
    };
  
    return Tags;
  });
  
  S2.define('select2/data/tokenizer',[
    'jquery'
  ], function ($) {
    function Tokenizer (decorated, $element, options) {
      var tokenizer = options.get('tokenizer');
  
      if (tokenizer !== undefined) {
        this.tokenizer = tokenizer;
      }
  
      decorated.call(this, $element, options);
    }
  
    Tokenizer.prototype.bind = function (decorated, container, $container) {
      decorated.call(this, container, $container);
  
      this.$search =  container.dropdown.$search || container.selection.$search ||
        $container.find('.select2-search__field');
    };
  
    Tokenizer.prototype.query = function (decorated, params, callback) {
      var self = this;
  
      function createAndSelect (data) {
        // Normalize the data object so we can use it for checks
        var item = self._normalizeItem(data);
  
        // Check if the data object already exists as a tag
        // Select it if it doesn't
        var $existingOptions = self.$element.find('option').filter(function () {
          return $(this).val() === item.id;
        });
  
        // If an existing option wasn't found for it, create the option
        if (!$existingOptions.length) {
          var $option = self.option(item);
          $option.attr('data-select2-tag', true);
  
          self._removeOldTags();
          self.addOptions([$option]);
        }
  
        // Select the item, now that we know there is an option for it
        select(item);
      }
  
      function select (data) {
        self.trigger('select', {
          data: data
        });
      }
  
      params.term = params.term || '';
  
      var tokenData = this.tokenizer(params, this.options, createAndSelect);
  
      if (tokenData.term !== params.term) {
        // Replace the search term if we have the search box
        if (this.$search.length) {
          this.$search.val(tokenData.term);
          this.$search.trigger('focus');
        }
  
        params.term = tokenData.term;
      }
  
      decorated.call(this, params, callback);
    };
  
    Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
      var separators = options.get('tokenSeparators') || [];
      var term = params.term;
      var i = 0;
  
      var createTag = this.createTag || function (params) {
        return {
          id: params.term,
          text: params.term
        };
      };
  
      while (i < term.length) {
        var termChar = term[i];
  
        if (separators.indexOf(termChar) === -1) {
          i++;
  
          continue;
        }
  
        var part = term.substr(0, i);
        var partParams = $.extend({}, params, {
          term: part
        });
  
        var data = createTag(partParams);
  
        if (data == null) {
          i++;
          continue;
        }
  
        callback(data);
  
        // Reset the term to not include the tokenized portion
        term = term.substr(i + 1) || '';
        i = 0;
      }
  
      return {
        term: term
      };
    };
  
    return Tokenizer;
  });
  
  S2.define('select2/data/minimumInputLength',[
  
  ], function () {
    function MinimumInputLength (decorated, $e, options) {
      this.minimumInputLength = options.get('minimumInputLength');
  
      decorated.call(this, $e, options);
    }
  
    MinimumInputLength.prototype.query = function (decorated, params, callback) {
      params.term = params.term || '';
  
      if (params.term.length < this.minimumInputLength) {
        this.trigger('results:message', {
          message: 'inputTooShort',
          args: {
            minimum: this.minimumInputLength,
            input: params.term,
            params: params
          }
        });
  
        return;
      }
  
      decorated.call(this, params, callback);
    };
  
    return MinimumInputLength;
  });
  
  S2.define('select2/data/maximumInputLength',[
  
  ], function () {
    function MaximumInputLength (decorated, $e, options) {
      this.maximumInputLength = options.get('maximumInputLength');
  
      decorated.call(this, $e, options);
    }
  
    MaximumInputLength.prototype.query = function (decorated, params, callback) {
      params.term = params.term || '';
  
      if (this.maximumInputLength > 0 &&
          params.term.length > this.maximumInputLength) {
        this.trigger('results:message', {
          message: 'inputTooLong',
          args: {
            maximum: this.maximumInputLength,
            input: params.term,
            params: params
          }
        });
  
        return;
      }
  
      decorated.call(this, params, callback);
    };
  
    return MaximumInputLength;
  });
  
  S2.define('select2/data/maximumSelectionLength',[
  
  ], function (){
    function MaximumSelectionLength (decorated, $e, options) {
      this.maximumSelectionLength = options.get('maximumSelectionLength');
  
      decorated.call(this, $e, options);
    }
  
    MaximumSelectionLength.prototype.bind =
      function (decorated, container, $container) {
        var self = this;
  
        decorated.call(this, container, $container);
  
        container.on('select', function () {
          self._checkIfMaximumSelected();
        });
    };
  
    MaximumSelectionLength.prototype.query =
      function (decorated, params, callback) {
        var self = this;
  
        this._checkIfMaximumSelected(function () {
          decorated.call(self, params, callback);
        });
    };
  
    MaximumSelectionLength.prototype._checkIfMaximumSelected =
      function (_, successCallback) {
        var self = this;
  
        this.current(function (currentData) {
          var count = currentData != null ? currentData.length : 0;
          if (self.maximumSelectionLength > 0 &&
            count >= self.maximumSelectionLength) {
            self.trigger('results:message', {
              message: 'maximumSelected',
              args: {
                maximum: self.maximumSelectionLength
              }
            });
            return;
          }
  
          if (successCallback) {
            successCallback();
          }
        });
    };
  
    return MaximumSelectionLength;
  });
  
  S2.define('select2/dropdown',[
    'jquery',
    './utils'
  ], function ($, Utils) {
    function Dropdown ($element, options) {
      this.$element = $element;
      this.options = options;
  
      Dropdown.__super__.constructor.call(this);
    }
  
    Utils.Extend(Dropdown, Utils.Observable);
  
    Dropdown.prototype.render = function () {
      var $dropdown = $(
        '<span class="select2-dropdown">' +
          '<span class="select2-results"></span>' +
        '</span>'
      );
  
      $dropdown.attr('dir', this.options.get('dir'));
  
      this.$dropdown = $dropdown;
  
      return $dropdown;
    };
  
    Dropdown.prototype.bind = function () {
      // Should be implemented in subclasses
    };
  
    Dropdown.prototype.position = function ($dropdown, $container) {
      // Should be implemented in subclasses
    };
  
    Dropdown.prototype.destroy = function () {
      // Remove the dropdown from the DOM
      this.$dropdown.remove();
    };
  
    return Dropdown;
  });
  
  S2.define('select2/dropdown/search',[
    'jquery'
  ], function ($) {
    function Search () { }
  
    Search.prototype.render = function (decorated) {
      var $rendered = decorated.call(this);
      var searchLabel = this.options.get('translations').get('search');
  
      var $search = $(
        '<span class="select2-search select2-search--dropdown">' +
          '<input class="select2-search__field" type="search" tabindex="-1"' +
          ' autocorrect="off" autocapitalize="none"' +
          ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' +
        '</span>'
      );
  
      this.$searchContainer = $search;
      this.$search = $search.find('input');
  
      this.$search.prop('autocomplete', this.options.get('autocomplete'));
      this.$search.attr('aria-label', searchLabel());
  
      $rendered.prepend($search);
  
      return $rendered;
    };
  
    Search.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      var resultsId = container.id + '-results';
  
      decorated.call(this, container, $container);
  
      this.$search.on('keydown', function (evt) {
        self.trigger('keypress', evt);
  
        self._keyUpPrevented = evt.isDefaultPrevented();
      });
  
      // Workaround for browsers which do not support the `input` event
      // This will prevent double-triggering of events for browsers which support
      // both the `keyup` and `input` events.
      this.$search.on('input', function (evt) {
        // Unbind the duplicated `keyup` event
        $(this).off('keyup');
      });
  
      this.$search.on('keyup input', function (evt) {
        self.handleSearch(evt);
      });
  
      container.on('open', function () {
        self.$search.attr('tabindex', 0);
        self.$search.attr('aria-controls', resultsId);
  
        self.$search.trigger('focus');
  
        window.setTimeout(function () {
          self.$search.trigger('focus');
        }, 0);
      });
  
      container.on('close', function () {
        self.$search.attr('tabindex', -1);
        self.$search.removeAttr('aria-controls');
        self.$search.removeAttr('aria-activedescendant');
  
        self.$search.val('');
        self.$search.trigger('blur');
      });
  
      container.on('focus', function () {
        if (!container.isOpen()) {
          self.$search.trigger('focus');
        }
      });
  
      container.on('results:all', function (params) {
        if (params.query.term == null || params.query.term === '') {
          var showSearch = self.showSearch(params);
  
          if (showSearch) {
            self.$searchContainer[0].classList.remove('select2-search--hide');
          } else {
            self.$searchContainer[0].classList.add('select2-search--hide');
          }
        }
      });
  
      container.on('results:focus', function (params) {
        if (params.data._resultId) {
          self.$search.attr('aria-activedescendant', params.data._resultId);
        } else {
          self.$search.removeAttr('aria-activedescendant');
        }
      });
    };
  
    Search.prototype.handleSearch = function (evt) {
      if (!this._keyUpPrevented) {
        var input = this.$search.val();
  
        this.trigger('query', {
          term: input
        });
      }
  
      this._keyUpPrevented = false;
    };
  
    Search.prototype.showSearch = function (_, params) {
      return true;
    };
  
    return Search;
  });
  
  S2.define('select2/dropdown/hidePlaceholder',[
  
  ], function () {
    function HidePlaceholder (decorated, $element, options, dataAdapter) {
      this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
  
      decorated.call(this, $element, options, dataAdapter);
    }
  
    HidePlaceholder.prototype.append = function (decorated, data) {
      data.results = this.removePlaceholder(data.results);
  
      decorated.call(this, data);
    };
  
    HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
      if (typeof placeholder === 'string') {
        placeholder = {
          id: '',
          text: placeholder
        };
      }
  
      return placeholder;
    };
  
    HidePlaceholder.prototype.removePlaceholder = function (_, data) {
      var modifiedData = data.slice(0);
  
      for (var d = data.length - 1; d >= 0; d--) {
        var item = data[d];
  
        if (this.placeholder.id === item.id) {
          modifiedData.splice(d, 1);
        }
      }
  
      return modifiedData;
    };
  
    return HidePlaceholder;
  });
  
  S2.define('select2/dropdown/infiniteScroll',[
    'jquery'
  ], function ($) {
    function InfiniteScroll (decorated, $element, options, dataAdapter) {
      this.lastParams = {};
  
      decorated.call(this, $element, options, dataAdapter);
  
      this.$loadingMore = this.createLoadingMore();
      this.loading = false;
    }
  
    InfiniteScroll.prototype.append = function (decorated, data) {
      this.$loadingMore.remove();
      this.loading = false;
  
      decorated.call(this, data);
  
      if (this.showLoadingMore(data)) {
        this.$results.append(this.$loadingMore);
        this.loadMoreIfNeeded();
      }
    };
  
    InfiniteScroll.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      decorated.call(this, container, $container);
  
      container.on('query', function (params) {
        self.lastParams = params;
        self.loading = true;
      });
  
      container.on('query:append', function (params) {
        self.lastParams = params;
        self.loading = true;
      });
  
      this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));
    };
  
    InfiniteScroll.prototype.loadMoreIfNeeded = function () {
      var isLoadMoreVisible = $.contains(
        document.documentElement,
        this.$loadingMore[0]
      );
  
      if (this.loading || !isLoadMoreVisible) {
        return;
      }
  
      var currentOffset = this.$results.offset().top +
        this.$results.outerHeight(false);
      var loadingMoreOffset = this.$loadingMore.offset().top +
        this.$loadingMore.outerHeight(false);
  
      if (currentOffset + 50 >= loadingMoreOffset) {
        this.loadMore();
      }
    };
  
    InfiniteScroll.prototype.loadMore = function () {
      this.loading = true;
  
      var params = $.extend({}, {page: 1}, this.lastParams);
  
      params.page++;
  
      this.trigger('query:append', params);
    };
  
    InfiniteScroll.prototype.showLoadingMore = function (_, data) {
      return data.pagination && data.pagination.more;
    };
  
    InfiniteScroll.prototype.createLoadingMore = function () {
      var $option = $(
        '<li ' +
        'class="select2-results__option select2-results__option--load-more"' +
        'role="option" aria-disabled="true"></li>'
      );
  
      var message = this.options.get('translations').get('loadingMore');
  
      $option.html(message(this.lastParams));
  
      return $option;
    };
  
    return InfiniteScroll;
  });
  
  S2.define('select2/dropdown/attachBody',[
    'jquery',
    '../utils'
  ], function ($, Utils) {
    function AttachBody (decorated, $element, options) {
      this.$dropdownParent = $(options.get('dropdownParent') || document.body);
  
      decorated.call(this, $element, options);
    }
  
    AttachBody.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      decorated.call(this, container, $container);
  
      container.on('open', function () {
        self._showDropdown();
        self._attachPositioningHandler(container);
  
        // Must bind after the results handlers to ensure correct sizing
        self._bindContainerResultHandlers(container);
      });
  
      container.on('close', function () {
        self._hideDropdown();
        self._detachPositioningHandler(container);
      });
  
      this.$dropdownContainer.on('mousedown', function (evt) {
        evt.stopPropagation();
      });
    };
  
    AttachBody.prototype.destroy = function (decorated) {
      decorated.call(this);
  
      this.$dropdownContainer.remove();
    };
  
    AttachBody.prototype.position = function (decorated, $dropdown, $container) {
      // Clone all of the container classes
      $dropdown.attr('class', $container.attr('class'));
  
      $dropdown[0].classList.remove('select2');
      $dropdown[0].classList.add('select2-container--open');
  
      $dropdown.css({
        position: 'absolute',
        top: -999999
      });
  
      this.$container = $container;
    };
  
    AttachBody.prototype.render = function (decorated) {
      var $container = $('<span></span>');
  
      var $dropdown = decorated.call(this);
      $container.append($dropdown);
  
      this.$dropdownContainer = $container;
  
      return $container;
    };
  
    AttachBody.prototype._hideDropdown = function (decorated) {
      this.$dropdownContainer.detach();
    };
  
    AttachBody.prototype._bindContainerResultHandlers =
        function (decorated, container) {
  
      // These should only be bound once
      if (this._containerResultsHandlersBound) {
        return;
      }
  
      var self = this;
  
      container.on('results:all', function () {
        self._positionDropdown();
        self._resizeDropdown();
      });
  
      container.on('results:append', function () {
        self._positionDropdown();
        self._resizeDropdown();
      });
  
      container.on('results:message', function () {
        self._positionDropdown();
        self._resizeDropdown();
      });
  
      container.on('select', function () {
        self._positionDropdown();
        self._resizeDropdown();
      });
  
      container.on('unselect', function () {
        self._positionDropdown();
        self._resizeDropdown();
      });
  
      this._containerResultsHandlersBound = true;
    };
  
    AttachBody.prototype._attachPositioningHandler =
        function (decorated, container) {
      var self = this;
  
      var scrollEvent = 'scroll.select2.' + container.id;
      var resizeEvent = 'resize.select2.' + container.id;
      var orientationEvent = 'orientationchange.select2.' + container.id;
  
      var $watchers = this.$container.parents().filter(Utils.hasScroll);
      $watchers.each(function () {
        Utils.StoreData(this, 'select2-scroll-position', {
          x: $(this).scrollLeft(),
          y: $(this).scrollTop()
        });
      });
  
      $watchers.on(scrollEvent, function (ev) {
        var position = Utils.GetData(this, 'select2-scroll-position');
        $(this).scrollTop(position.y);
      });
  
      $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
        function (e) {
        self._positionDropdown();
        self._resizeDropdown();
      });
    };
  
    AttachBody.prototype._detachPositioningHandler =
        function (decorated, container) {
      var scrollEvent = 'scroll.select2.' + container.id;
      var resizeEvent = 'resize.select2.' + container.id;
      var orientationEvent = 'orientationchange.select2.' + container.id;
  
      var $watchers = this.$container.parents().filter(Utils.hasScroll);
      $watchers.off(scrollEvent);
  
      $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
    };
  
    AttachBody.prototype._positionDropdown = function () {
      var $window = $(window);
  
      var isCurrentlyAbove = this.$dropdown[0].classList
        .contains('select2-dropdown--above');
      var isCurrentlyBelow = this.$dropdown[0].classList
        .contains('select2-dropdown--below');
  
      var newDirection = null;
  
      var offset = this.$container.offset();
  
      offset.bottom = offset.top + this.$container.outerHeight(false);
  
      var container = {
        height: this.$container.outerHeight(false)
      };
  
      container.top = offset.top;
      container.bottom = offset.top + container.height;
  
      var dropdown = {
        height: this.$dropdown.outerHeight(false)
      };
  
      var viewport = {
        top: $window.scrollTop(),
        bottom: $window.scrollTop() + $window.height()
      };
  
      var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
      var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);
  
      var css = {
        left: offset.left,
        top: container.bottom
      };
  
      // Determine what the parent element is to use for calculating the offset
      var $offsetParent = this.$dropdownParent;
  
      // For statically positioned elements, we need to get the element
      // that is determining the offset
      if ($offsetParent.css('position') === 'static') {
        $offsetParent = $offsetParent.offsetParent();
      }
  
      var parentOffset = {
        top: 0,
        left: 0
      };
  
      if (
        $.contains(document.body, $offsetParent[0]) ||
        $offsetParent[0].isConnected
        ) {
        parentOffset = $offsetParent.offset();
      }
  
      css.top -= parentOffset.top;
      css.left -= parentOffset.left;
  
      if (!isCurrentlyAbove && !isCurrentlyBelow) {
        newDirection = 'below';
      }
  
      if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
        newDirection = 'above';
      } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
        newDirection = 'below';
      }
  
      if (newDirection == 'above' ||
        (isCurrentlyAbove && newDirection !== 'below')) {
        css.top = container.top - parentOffset.top - dropdown.height;
      }
  
      if (newDirection != null) {
        this.$dropdown[0].classList.remove('select2-dropdown--below');
        this.$dropdown[0].classList.remove('select2-dropdown--above');
        this.$dropdown[0].classList.add('select2-dropdown--' + newDirection);
  
        this.$container[0].classList.remove('select2-container--below');
        this.$container[0].classList.remove('select2-container--above');
        this.$container[0].classList.add('select2-container--' + newDirection);
      }
  
      this.$dropdownContainer.css(css);
    };
  
    AttachBody.prototype._resizeDropdown = function () {
      var css = {
        width: this.$container.outerWidth(false) + 'px'
      };
  
      if (this.options.get('dropdownAutoWidth')) {
        css.minWidth = css.width;
        css.position = 'relative';
        css.width = 'auto';
      }
  
      this.$dropdown.css(css);
    };
  
    AttachBody.prototype._showDropdown = function (decorated) {
      this.$dropdownContainer.appendTo(this.$dropdownParent);
  
      this._positionDropdown();
      this._resizeDropdown();
    };
  
    return AttachBody;
  });
  
  S2.define('select2/dropdown/minimumResultsForSearch',[
  
  ], function () {
    function countResults (data) {
      var count = 0;
  
      for (var d = 0; d < data.length; d++) {
        var item = data[d];
  
        if (item.children) {
          count += countResults(item.children);
        } else {
          count++;
        }
      }
  
      return count;
    }
  
    function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
      this.minimumResultsForSearch = options.get('minimumResultsForSearch');
  
      if (this.minimumResultsForSearch < 0) {
        this.minimumResultsForSearch = Infinity;
      }
  
      decorated.call(this, $element, options, dataAdapter);
    }
  
    MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
      if (countResults(params.data.results) < this.minimumResultsForSearch) {
        return false;
      }
  
      return decorated.call(this, params);
    };
  
    return MinimumResultsForSearch;
  });
  
  S2.define('select2/dropdown/selectOnClose',[
    '../utils'
  ], function (Utils) {
    function SelectOnClose () { }
  
    SelectOnClose.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      decorated.call(this, container, $container);
  
      container.on('close', function (params) {
        self._handleSelectOnClose(params);
      });
    };
  
    SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
      if (params && params.originalSelect2Event != null) {
        var event = params.originalSelect2Event;
  
        // Don't select an item if the close event was triggered from a select or
        // unselect event
        if (event._type === 'select' || event._type === 'unselect') {
          return;
        }
      }
  
      var $highlightedResults = this.getHighlightedResults();
  
      // Only select highlighted results
      if ($highlightedResults.length < 1) {
        return;
      }
  
      var data = Utils.GetData($highlightedResults[0], 'data');
  
      // Don't re-select already selected resulte
      if (
        (data.element != null && data.element.selected) ||
        (data.element == null && data.selected)
      ) {
        return;
      }
  
      this.trigger('select', {
          data: data
      });
    };
  
    return SelectOnClose;
  });
  
  S2.define('select2/dropdown/closeOnSelect',[
  
  ], function () {
    function CloseOnSelect () { }
  
    CloseOnSelect.prototype.bind = function (decorated, container, $container) {
      var self = this;
  
      decorated.call(this, container, $container);
  
      container.on('select', function (evt) {
        self._selectTriggered(evt);
      });
  
      container.on('unselect', function (evt) {
        self._selectTriggered(evt);
      });
    };
  
    CloseOnSelect.prototype._selectTriggered = function (_, evt) {
      var originalEvent = evt.originalEvent;
  
      // Don't close if the control key is being held
      if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
        return;
      }
  
      this.trigger('close', {
        originalEvent: originalEvent,
        originalSelect2Event: evt
      });
    };
  
    return CloseOnSelect;
  });
  
  S2.define('select2/dropdown/dropdownCss',[
    '../utils'
  ], function (Utils) {
    function DropdownCSS () { }
  
    DropdownCSS.prototype.render = function (decorated) {
      var $dropdown = decorated.call(this);
  
      var dropdownCssClass = this.options.get('dropdownCssClass') || '';
  
      if (dropdownCssClass.indexOf(':all:') !== -1) {
        dropdownCssClass = dropdownCssClass.replace(':all:', '');
  
        Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
      }
  
      $dropdown.addClass(dropdownCssClass);
  
      return $dropdown;
    };
  
    return DropdownCSS;
  });
  
  S2.define('select2/dropdown/tagsSearchHighlight',[
    '../utils'
  ], function (Utils) {
    function TagsSearchHighlight () { }
  
    TagsSearchHighlight.prototype.highlightFirstItem = function (decorated) {
      var $options = this.$results
      .find(
        '.select2-results__option--selectable' +
        ':not(.select2-results__option--selected)'
      );
  
      if ($options.length > 0) {
        var $firstOption = $options.first();
        var data = Utils.GetData($firstOption[0], 'data');
        var firstElement = data.element;
  
        if (firstElement && firstElement.getAttribute) {
          if (firstElement.getAttribute('data-select2-tag') === 'true') {
            $firstOption.trigger('mouseenter');
  
            return;
          }
        }
      }
  
      decorated.call(this);
    };
  
    return TagsSearchHighlight;
  });
  
  S2.define('select2/i18n/en',[],function () {
    // English
    return {
      errorLoading: function () {
        return 'The results could not be loaded.';
      },
      inputTooLong: function (args) {
        var overChars = args.input.length - args.maximum;
  
        var message = 'Please delete ' + overChars + ' character';
  
        if (overChars != 1) {
          message += 's';
        }
  
        return message;
      },
      inputTooShort: function (args) {
        var remainingChars = args.minimum - args.input.length;
  
        var message = 'Please enter ' + remainingChars + ' or more characters';
  
        return message;
      },
      loadingMore: function () {
        return 'Loading more results';
      },
      maximumSelected: function (args) {
        var message = 'You can only select ' + args.maximum + ' item';
  
        if (args.maximum != 1) {
          message += 's';
        }
  
        return message;
      },
      noResults: function () {
        return 'No results found';
      },
      searching: function () {
        return 'Searching';
      },
      removeAllItems: function () {
        return 'Remove all items';
      },
      removeItem: function () {
        return 'Remove item';
      },
      search: function() {
        return 'Search';
      }
    };
  });
  
  S2.define('select2/defaults',[
    'jquery',
  
    './results',
  
    './selection/single',
    './selection/multiple',
    './selection/placeholder',
    './selection/allowClear',
    './selection/search',
    './selection/selectionCss',
    './selection/eventRelay',
  
    './utils',
    './translation',
    './diacritics',
  
    './data/select',
    './data/array',
    './data/ajax',
    './data/tags',
    './data/tokenizer',
    './data/minimumInputLength',
    './data/maximumInputLength',
    './data/maximumSelectionLength',
  
    './dropdown',
    './dropdown/search',
    './dropdown/hidePlaceholder',
    './dropdown/infiniteScroll',
    './dropdown/attachBody',
    './dropdown/minimumResultsForSearch',
    './dropdown/selectOnClose',
    './dropdown/closeOnSelect',
    './dropdown/dropdownCss',
    './dropdown/tagsSearchHighlight',
  
    './i18n/en'
  ], function ($,
  
               ResultsList,
  
               SingleSelection, MultipleSelection, Placeholder, AllowClear,
               SelectionSearch, SelectionCSS, EventRelay,
  
               Utils, Translation, DIACRITICS,
  
               SelectData, ArrayData, AjaxData, Tags, Tokenizer,
               MinimumInputLength, MaximumInputLength, MaximumSelectionLength,
  
               Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
               AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,
               DropdownCSS, TagsSearchHighlight,
  
               EnglishTranslation) {
    function Defaults () {
      this.reset();
    }
  
    Defaults.prototype.apply = function (options) {
      options = $.extend(true, {}, this.defaults, options);
  
      if (options.dataAdapter == null) {
        if (options.ajax != null) {
          options.dataAdapter = AjaxData;
        } else if (options.data != null) {
          options.dataAdapter = ArrayData;
        } else {
          options.dataAdapter = SelectData;
        }
  
        if (options.minimumInputLength > 0) {
          options.dataAdapter = Utils.Decorate(
            options.dataAdapter,
            MinimumInputLength
          );
        }
  
        if (options.maximumInputLength > 0) {
          options.dataAdapter = Utils.Decorate(
            options.dataAdapter,
            MaximumInputLength
          );
        }
  
        if (options.maximumSelectionLength > 0) {
          options.dataAdapter = Utils.Decorate(
            options.dataAdapter,
            MaximumSelectionLength
          );
        }
  
        if (options.tags) {
          options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
        }
  
        if (options.tokenSeparators != null || options.tokenizer != null) {
          options.dataAdapter = Utils.Decorate(
            options.dataAdapter,
            Tokenizer
          );
        }
      }
  
      if (options.resultsAdapter == null) {
        options.resultsAdapter = ResultsList;
  
        if (options.ajax != null) {
          options.resultsAdapter = Utils.Decorate(
            options.resultsAdapter,
            InfiniteScroll
          );
        }
  
        if (options.placeholder != null) {
          options.resultsAdapter = Utils.Decorate(
            options.resultsAdapter,
            HidePlaceholder
          );
        }
  
        if (options.selectOnClose) {
          options.resultsAdapter = Utils.Decorate(
            options.resultsAdapter,
            SelectOnClose
          );
        }
  
        if (options.tags) {
          options.resultsAdapter = Utils.Decorate(
            options.resultsAdapter,
            TagsSearchHighlight
          );
        }
      }
  
      if (options.dropdownAdapter == null) {
        if (options.multiple) {
          options.dropdownAdapter = Dropdown;
        } else {
          var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
  
          options.dropdownAdapter = SearchableDropdown;
        }
  
        if (options.minimumResultsForSearch !== 0) {
          options.dropdownAdapter = Utils.Decorate(
            options.dropdownAdapter,
            MinimumResultsForSearch
          );
        }
  
        if (options.closeOnSelect) {
          options.dropdownAdapter = Utils.Decorate(
            options.dropdownAdapter,
            CloseOnSelect
          );
        }
  
        if (options.dropdownCssClass != null) {
          options.dropdownAdapter = Utils.Decorate(
            options.dropdownAdapter,
            DropdownCSS
          );
        }
  
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          AttachBody
        );
      }
  
      if (options.selectionAdapter == null) {
        if (options.multiple) {
          options.selectionAdapter = MultipleSelection;
        } else {
          options.selectionAdapter = SingleSelection;
        }
  
        // Add the placeholder mixin if a placeholder was specified
        if (options.placeholder != null) {
          options.selectionAdapter = Utils.Decorate(
            options.selectionAdapter,
            Placeholder
          );
        }
  
        if (options.allowClear) {
          options.selectionAdapter = Utils.Decorate(
            options.selectionAdapter,
            AllowClear
          );
        }
  
        if (options.multiple) {
          options.selectionAdapter = Utils.Decorate(
            options.selectionAdapter,
            SelectionSearch
          );
        }
  
        if (options.selectionCssClass != null) {
          options.selectionAdapter = Utils.Decorate(
            options.selectionAdapter,
            SelectionCSS
          );
        }
  
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          EventRelay
        );
      }
  
      // If the defaults were not previously applied from an element, it is
      // possible for the language option to have not been resolved
      options.language = this._resolveLanguage(options.language);
  
      // Always fall back to English since it will always be complete
      options.language.push('en');
  
      var uniqueLanguages = [];
  
      for (var l = 0; l < options.language.length; l++) {
        var language = options.language[l];
  
        if (uniqueLanguages.indexOf(language) === -1) {
          uniqueLanguages.push(language);
        }
      }
  
      options.language = uniqueLanguages;
  
      options.translations = this._processTranslations(
        options.language,
        options.debug
      );
  
      return options;
    };
  
    Defaults.prototype.reset = function () {
      function stripDiacritics (text) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
          return DIACRITICS[a] || a;
        }
  
        return text.replace(/[^\u0000-\u007E]/g, match);
      }
  
      function matcher (params, data) {
        // Always return the object if there is nothing to compare
        if (params.term == null || params.term.trim() === '') {
          return data;
        }
  
        // Do a recursive check for options with children
        if (data.children && data.children.length > 0) {
          // Clone the data object if there are children
          // This is required as we modify the object to remove any non-matches
          var match = $.extend(true, {}, data);
  
          // Check each child of the option
          for (var c = data.children.length - 1; c >= 0; c--) {
            var child = data.children[c];
  
            var matches = matcher(params, child);
  
            // If there wasn't a match, remove the object in the array
            if (matches == null) {
              match.children.splice(c, 1);
            }
          }
  
          // If any children matched, return the new object
          if (match.children.length > 0) {
            return match;
          }
  
          // If there were no matching children, check just the plain object
          return matcher(params, match);
        }
  
        var original = stripDiacritics(data.text).toUpperCase();
        var term = stripDiacritics(params.term).toUpperCase();
  
        // Check if the text contains the term
        if (original.indexOf(term) > -1) {
          return data;
        }
  
        // If it doesn't contain the term, don't return anything
        return null;
      }
  
      this.defaults = {
        amdLanguageBase: './i18n/',
        autocomplete: 'off',
        closeOnSelect: true,
        debug: false,
        dropdownAutoWidth: false,
        escapeMarkup: Utils.escapeMarkup,
        language: {},
        matcher: matcher,
        minimumInputLength: 0,
        maximumInputLength: 0,
        maximumSelectionLength: 0,
        minimumResultsForSearch: 0,
        selectOnClose: false,
        scrollAfterSelect: false,
        sorter: function (data) {
          return data;
        },
        templateResult: function (result) {
          return result.text;
        },
        templateSelection: function (selection) {
          return selection.text;
        },
        theme: 'default',
        width: 'resolve'
      };
    };
  
    Defaults.prototype.applyFromElement = function (options, $element) {
      var optionLanguage = options.language;
      var defaultLanguage = this.defaults.language;
      var elementLanguage = $element.prop('lang');
      var parentLanguage = $element.closest('[lang]').prop('lang');
  
      var languages = Array.prototype.concat.call(
        this._resolveLanguage(elementLanguage),
        this._resolveLanguage(optionLanguage),
        this._resolveLanguage(defaultLanguage),
        this._resolveLanguage(parentLanguage)
      );
  
      options.language = languages;
  
      return options;
    };
  
    Defaults.prototype._resolveLanguage = function (language) {
      if (!language) {
        return [];
      }
  
      if ($.isEmptyObject(language)) {
        return [];
      }
  
      if ($.isPlainObject(language)) {
        return [language];
      }
  
      var languages;
  
      if (!Array.isArray(language)) {
        languages = [language];
      } else {
        languages = language;
      }
  
      var resolvedLanguages = [];
  
      for (var l = 0; l < languages.length; l++) {
        resolvedLanguages.push(languages[l]);
  
        if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {
          // Extract the region information if it is included
          var languageParts = languages[l].split('-');
          var baseLanguage = languageParts[0];
  
          resolvedLanguages.push(baseLanguage);
        }
      }
  
      return resolvedLanguages;
    };
  
    Defaults.prototype._processTranslations = function (languages, debug) {
      var translations = new Translation();
  
      for (var l = 0; l < languages.length; l++) {
        var languageData = new Translation();
  
        var language = languages[l];
  
        if (typeof language === 'string') {
          try {
            // Try to load it with the original name
            languageData = Translation.loadPath(language);
          } catch (e) {
            try {
              // If we couldn't load it, check if it wasn't the full path
              language = this.defaults.amdLanguageBase + language;
              languageData = Translation.loadPath(language);
            } catch (ex) {
              // The translation could not be loaded at all. Sometimes this is
              // because of a configuration problem, other times this can be
              // because of how Select2 helps load all possible translation files
              if (debug && window.console && console.warn) {
                console.warn(
                  'Select2: The language file for "' + language + '" could ' +
                  'not be automatically loaded. A fallback will be used instead.'
                );
              }
            }
          }
        } else if ($.isPlainObject(language)) {
          languageData = new Translation(language);
        } else {
          languageData = language;
        }
  
        translations.extend(languageData);
      }
  
      return translations;
    };
  
    Defaults.prototype.set = function (key, value) {
      var camelKey = $.camelCase(key);
  
      var data = {};
      data[camelKey] = value;
  
      var convertedData = Utils._convertData(data);
  
      $.extend(true, this.defaults, convertedData);
    };
  
    var defaults = new Defaults();
  
    return defaults;
  });
  
  S2.define('select2/options',[
    'jquery',
    './defaults',
    './utils'
  ], function ($, Defaults, Utils) {
    function Options (options, $element) {
      this.options = options;
  
      if ($element != null) {
        this.fromElement($element);
      }
  
      if ($element != null) {
        this.options = Defaults.applyFromElement(this.options, $element);
      }
  
      this.options = Defaults.apply(this.options);
    }
  
    Options.prototype.fromElement = function ($e) {
      var excludedData = ['select2'];
  
      if (this.options.multiple == null) {
        this.options.multiple = $e.prop('multiple');
      }
  
      if (this.options.disabled == null) {
        this.options.disabled = $e.prop('disabled');
      }
  
      if (this.options.autocomplete == null && $e.prop('autocomplete')) {
        this.options.autocomplete = $e.prop('autocomplete');
      }
  
      if (this.options.dir == null) {
        if ($e.prop('dir')) {
          this.options.dir = $e.prop('dir');
        } else if ($e.closest('[dir]').prop('dir')) {
          this.options.dir = $e.closest('[dir]').prop('dir');
        } else {
          this.options.dir = 'ltr';
        }
      }
  
      $e.prop('disabled', this.options.disabled);
      $e.prop('multiple', this.options.multiple);
  
      if (Utils.GetData($e[0], 'select2Tags')) {
        if (this.options.debug && window.console && console.warn) {
          console.warn(
            'Select2: The `data-select2-tags` attribute has been changed to ' +
            'use the `data-data` and `data-tags="true"` attributes and will be ' +
            'removed in future versions of Select2.'
          );
        }
  
        Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
        Utils.StoreData($e[0], 'tags', true);
      }
  
      if (Utils.GetData($e[0], 'ajaxUrl')) {
        if (this.options.debug && window.console && console.warn) {
          console.warn(
            'Select2: The `data-ajax-url` attribute has been changed to ' +
            '`data-ajax--url` and support for the old attribute will be removed' +
            ' in future versions of Select2.'
          );
        }
  
        $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
        Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
      }
  
      var dataset = {};
  
      function upperCaseLetter(_, letter) {
        return letter.toUpperCase();
      }
  
      // Pre-load all of the attributes which are prefixed with `data-`
      for (var attr = 0; attr < $e[0].attributes.length; attr++) {
        var attributeName = $e[0].attributes[attr].name;
        var prefix = 'data-';
  
        if (attributeName.substr(0, prefix.length) == prefix) {
          // Get the contents of the attribute after `data-`
          var dataName = attributeName.substring(prefix.length);
  
          // Get the data contents from the consistent source
          // This is more than likely the jQuery data helper
          var dataValue = Utils.GetData($e[0], dataName);
  
          // camelCase the attribute name to match the spec
          var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
  
          // Store the data attribute contents into the dataset since
          dataset[camelDataName] = dataValue;
        }
      }
  
      // Prefer the element's `dataset` attribute if it exists
      // jQuery 1.x does not correctly handle data attributes with multiple dashes
      if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
        dataset = $.extend(true, {}, $e[0].dataset, dataset);
      }
  
      // Prefer our internal data cache if it exists
      var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);
  
      data = Utils._convertData(data);
  
      for (var key in data) {
        if (excludedData.indexOf(key) > -1) {
          continue;
        }
  
        if ($.isPlainObject(this.options[key])) {
          $.extend(this.options[key], data[key]);
        } else {
          this.options[key] = data[key];
        }
      }
  
      return this;
    };
  
    Options.prototype.get = function (key) {
      return this.options[key];
    };
  
    Options.prototype.set = function (key, val) {
      this.options[key] = val;
    };
  
    return Options;
  });
  
  S2.define('select2/core',[
    'jquery',
    './options',
    './utils',
    './keys'
  ], function ($, Options, Utils, KEYS) {
    var Select2 = function ($element, options) {
      if (Utils.GetData($element[0], 'select2') != null) {
        Utils.GetData($element[0], 'select2').destroy();
      }
  
      this.$element = $element;
  
      this.id = this._generateId($element);
  
      options = options || {};
  
      this.options = new Options(options, $element);
  
      Select2.__super__.constructor.call(this);
  
      // Set up the tabindex
  
      var tabindex = $element.attr('tabindex') || 0;
      Utils.StoreData($element[0], 'old-tabindex', tabindex);
      $element.attr('tabindex', '-1');
  
      // Set up containers and adapters
  
      var DataAdapter = this.options.get('dataAdapter');
      this.dataAdapter = new DataAdapter($element, this.options);
  
      var $container = this.render();
  
      this._placeContainer($container);
  
      var SelectionAdapter = this.options.get('selectionAdapter');
      this.selection = new SelectionAdapter($element, this.options);
      this.$selection = this.selection.render();
  
      this.selection.position(this.$selection, $container);
  
      var DropdownAdapter = this.options.get('dropdownAdapter');
      this.dropdown = new DropdownAdapter($element, this.options);
      this.$dropdown = this.dropdown.render();
  
      this.dropdown.position(this.$dropdown, $container);
  
      var ResultsAdapter = this.options.get('resultsAdapter');
      this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
      this.$results = this.results.render();
  
      this.results.position(this.$results, this.$dropdown);
  
      // Bind events
  
      var self = this;
  
      // Bind the container to all of the adapters
      this._bindAdapters();
  
      // Register any DOM event handlers
      this._registerDomEvents();
  
      // Register any internal event handlers
      this._registerDataEvents();
      this._registerSelectionEvents();
      this._registerDropdownEvents();
      this._registerResultsEvents();
      this._registerEvents();
  
      // Set the initial state
      this.dataAdapter.current(function (initialData) {
        self.trigger('selection:update', {
          data: initialData
        });
      });
  
      // Hide the original select
      $element[0].classList.add('select2-hidden-accessible');
      $element.attr('aria-hidden', 'true');
  
      // Synchronize any monitored attributes
      this._syncAttributes();
  
      Utils.StoreData($element[0], 'select2', this);
  
      // Ensure backwards compatibility with $element.data('select2').
      $element.data('select2', this);
    };
  
    Utils.Extend(Select2, Utils.Observable);
  
    Select2.prototype._generateId = function ($element) {
      var id = '';
  
      if ($element.attr('id') != null) {
        id = $element.attr('id');
      } else if ($element.attr('name') != null) {
        id = $element.attr('name') + '-' + Utils.generateChars(2);
      } else {
        id = Utils.generateChars(4);
      }
  
      id = id.replace(/(:|\.|\[|\]|,)/g, '');
      id = 'select2-' + id;
  
      return id;
    };
  
    Select2.prototype._placeContainer = function ($container) {
      $container.insertAfter(this.$element);
  
      var width = this._resolveWidth(this.$element, this.options.get('width'));
  
      if (width != null) {
        $container.css('width', width);
      }
    };
  
    Select2.prototype._resolveWidth = function ($element, method) {
      var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
  
      if (method == 'resolve') {
        var styleWidth = this._resolveWidth($element, 'style');
  
        if (styleWidth != null) {
          return styleWidth;
        }
  
        return this._resolveWidth($element, 'element');
      }
  
      if (method == 'element') {
        var elementWidth = $element.outerWidth(false);
  
        if (elementWidth <= 0) {
          return 'auto';
        }
  
        return elementWidth + 'px';
      }
  
      if (method == 'style') {
        var style = $element.attr('style');
  
        if (typeof(style) !== 'string') {
          return null;
        }
  
        var attrs = style.split(';');
  
        for (var i = 0, l = attrs.length; i < l; i = i + 1) {
          var attr = attrs[i].replace(/\s/g, '');
          var matches = attr.match(WIDTH);
  
          if (matches !== null && matches.length >= 1) {
            return matches[1];
          }
        }
  
        return null;
      }
  
      if (method == 'computedstyle') {
        var computedStyle = window.getComputedStyle($element[0]);
  
        return computedStyle.width;
      }
  
      return method;
    };
  
    Select2.prototype._bindAdapters = function () {
      this.dataAdapter.bind(this, this.$container);
      this.selection.bind(this, this.$container);
  
      this.dropdown.bind(this, this.$container);
      this.results.bind(this, this.$container);
    };
  
    Select2.prototype._registerDomEvents = function () {
      var self = this;
  
      this.$element.on('change.select2', function () {
        self.dataAdapter.current(function (data) {
          self.trigger('selection:update', {
            data: data
          });
        });
      });
  
      this.$element.on('focus.select2', function (evt) {
        self.trigger('focus', evt);
      });
  
      this._syncA = Utils.bind(this._syncAttributes, this);
      this._syncS = Utils.bind(this._syncSubtree, this);
  
      this._observer = new window.MutationObserver(function (mutations) {
        self._syncA();
        self._syncS(mutations);
      });
      this._observer.observe(this.$element[0], {
        attributes: true,
        childList: true,
        subtree: false
      });
    };
  
    Select2.prototype._registerDataEvents = function () {
      var self = this;
  
      this.dataAdapter.on('*', function (name, params) {
        self.trigger(name, params);
      });
    };
  
    Select2.prototype._registerSelectionEvents = function () {
      var self = this;
      var nonRelayEvents = ['toggle', 'focus'];
  
      this.selection.on('toggle', function () {
        self.toggleDropdown();
      });
  
      this.selection.on('focus', function (params) {
        self.focus(params);
      });
  
      this.selection.on('*', function (name, params) {
        if (nonRelayEvents.indexOf(name) !== -1) {
          return;
        }
  
        self.trigger(name, params);
      });
    };
  
    Select2.prototype._registerDropdownEvents = function () {
      var self = this;
  
      this.dropdown.on('*', function (name, params) {
        self.trigger(name, params);
      });
    };
  
    Select2.prototype._registerResultsEvents = function () {
      var self = this;
  
      this.results.on('*', function (name, params) {
        self.trigger(name, params);
      });
    };
  
    Select2.prototype._registerEvents = function () {
      var self = this;
  
      this.on('open', function () {
        self.$container[0].classList.add('select2-container--open');
      });
  
      this.on('close', function () {
        self.$container[0].classList.remove('select2-container--open');
      });
  
      this.on('enable', function () {
        self.$container[0].classList.remove('select2-container--disabled');
      });
  
      this.on('disable', function () {
        self.$container[0].classList.add('select2-container--disabled');
      });
  
      this.on('blur', function () {
        self.$container[0].classList.remove('select2-container--focus');
      });
  
      this.on('query', function (params) {
        if (!self.isOpen()) {
          self.trigger('open', {});
        }
  
        this.dataAdapter.query(params, function (data) {
          self.trigger('results:all', {
            data: data,
            query: params
          });
        });
      });
  
      this.on('query:append', function (params) {
        this.dataAdapter.query(params, function (data) {
          self.trigger('results:append', {
            data: data,
            query: params
          });
        });
      });
  
      this.on('keypress', function (evt) {
        var key = evt.which;
  
        if (self.isOpen()) {
          if (key === KEYS.ESC || (key === KEYS.UP && evt.altKey)) {
            self.close(evt);
  
            evt.preventDefault();
          } else if (key === KEYS.ENTER || key === KEYS.TAB) {
            self.trigger('results:select', {});
  
            evt.preventDefault();
          } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
            self.trigger('results:toggle', {});
  
            evt.preventDefault();
          } else if (key === KEYS.UP) {
            self.trigger('results:previous', {});
  
            evt.preventDefault();
          } else if (key === KEYS.DOWN) {
            self.trigger('results:next', {});
  
            evt.preventDefault();
          }
        } else {
          if (key === KEYS.ENTER || key === KEYS.SPACE ||
              (key === KEYS.DOWN && evt.altKey)) {
            self.open();
  
            evt.preventDefault();
          }
        }
      });
    };
  
    Select2.prototype._syncAttributes = function () {
      this.options.set('disabled', this.$element.prop('disabled'));
  
      if (this.isDisabled()) {
        if (this.isOpen()) {
          this.close();
        }
  
        this.trigger('disable', {});
      } else {
        this.trigger('enable', {});
      }
    };
  
    Select2.prototype._isChangeMutation = function (mutations) {
      var self = this;
  
      if (mutations.addedNodes && mutations.addedNodes.length > 0) {
        for (var n = 0; n < mutations.addedNodes.length; n++) {
          var node = mutations.addedNodes[n];
  
          if (node.selected) {
            return true;
          }
        }
      } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
        return true;
      } else if (Array.isArray(mutations)) {
        return mutations.some(function (mutation) {
          return self._isChangeMutation(mutation);
        });
      }
  
      return false;
    };
  
    Select2.prototype._syncSubtree = function (mutations) {
      var changed = this._isChangeMutation(mutations);
      var self = this;
  
      // Only re-pull the data if we think there is a change
      if (changed) {
        this.dataAdapter.current(function (currentData) {
          self.trigger('selection:update', {
            data: currentData
          });
        });
      }
    };
  
    /**
     * Override the trigger method to automatically trigger pre-events when
     * there are events that can be prevented.
     */
    Select2.prototype.trigger = function (name, args) {
      var actualTrigger = Select2.__super__.trigger;
      var preTriggerMap = {
        'open': 'opening',
        'close': 'closing',
        'select': 'selecting',
        'unselect': 'unselecting',
        'clear': 'clearing'
      };
  
      if (args === undefined) {
        args = {};
      }
  
      if (name in preTriggerMap) {
        var preTriggerName = preTriggerMap[name];
        var preTriggerArgs = {
          prevented: false,
          name: name,
          args: args
        };
  
        actualTrigger.call(this, preTriggerName, preTriggerArgs);
  
        if (preTriggerArgs.prevented) {
          args.prevented = true;
  
          return;
        }
      }
  
      actualTrigger.call(this, name, args);
    };
  
    Select2.prototype.toggleDropdown = function () {
      if (this.isDisabled()) {
        return;
      }
  
      if (this.isOpen()) {
        this.close();
      } else {
        this.open();
      }
    };
  
    Select2.prototype.open = function () {
      if (this.isOpen()) {
        return;
      }
  
      if (this.isDisabled()) {
        return;
      }
  
      this.trigger('query', {});
    };
  
    Select2.prototype.close = function (evt) {
      if (!this.isOpen()) {
        return;
      }
  
      this.trigger('close', { originalEvent : evt });
    };
  
    /**
     * Helper method to abstract the "enabled" (not "disabled") state of this
     * object.
     *
     * @return {true} if the instance is not disabled.
     * @return {false} if the instance is disabled.
     */
    Select2.prototype.isEnabled = function () {
      return !this.isDisabled();
    };
  
    /**
     * Helper method to abstract the "disabled" state of this object.
     *
     * @return {true} if the disabled option is true.
     * @return {false} if the disabled option is false.
     */
    Select2.prototype.isDisabled = function () {
      return this.options.get('disabled');
    };
  
    Select2.prototype.isOpen = function () {
      return this.$container[0].classList.contains('select2-container--open');
    };
  
    Select2.prototype.hasFocus = function () {
      return this.$container[0].classList.contains('select2-container--focus');
    };
  
    Select2.prototype.focus = function (data) {
      // No need to re-trigger focus events if we are already focused
      if (this.hasFocus()) {
        return;
      }
  
      this.$container[0].classList.add('select2-container--focus');
      this.trigger('focus', {});
    };
  
    Select2.prototype.enable = function (args) {
      if (this.options.get('debug') && window.console && console.warn) {
        console.warn(
          'Select2: The `select2("enable")` method has been deprecated and will' +
          ' be removed in later Select2 versions. Use $element.prop("disabled")' +
          ' instead.'
        );
      }
  
      if (args == null || args.length === 0) {
        args = [true];
      }
  
      var disabled = !args[0];
  
      this.$element.prop('disabled', disabled);
    };
  
    Select2.prototype.data = function () {
      if (this.options.get('debug') &&
          arguments.length > 0 && window.console && console.warn) {
        console.warn(
          'Select2: Data can no longer be set using `select2("data")`. You ' +
          'should consider setting the value instead using `$element.val()`.'
        );
      }
  
      var data = [];
  
      this.dataAdapter.current(function (currentData) {
        data = currentData;
      });
  
      return data;
    };
  
    Select2.prototype.val = function (args) {
      if (this.options.get('debug') && window.console && console.warn) {
        console.warn(
          'Select2: The `select2("val")` method has been deprecated and will be' +
          ' removed in later Select2 versions. Use $element.val() instead.'
        );
      }
  
      if (args == null || args.length === 0) {
        return this.$element.val();
      }
  
      var newVal = args[0];
  
      if (Array.isArray(newVal)) {
        newVal = newVal.map(function (obj) {
          return obj.toString();
        });
      }
  
      this.$element.val(newVal).trigger('input').trigger('change');
    };
  
    Select2.prototype.destroy = function () {
      Utils.RemoveData(this.$container[0]);
      this.$container.remove();
  
      this._observer.disconnect();
      this._observer = null;
  
      this._syncA = null;
      this._syncS = null;
  
      this.$element.off('.select2');
      this.$element.attr('tabindex',
      Utils.GetData(this.$element[0], 'old-tabindex'));
  
      this.$element[0].classList.remove('select2-hidden-accessible');
      this.$element.attr('aria-hidden', 'false');
      Utils.RemoveData(this.$element[0]);
      this.$element.removeData('select2');
  
      this.dataAdapter.destroy();
      this.selection.destroy();
      this.dropdown.destroy();
      this.results.destroy();
  
      this.dataAdapter = null;
      this.selection = null;
      this.dropdown = null;
      this.results = null;
    };
  
    Select2.prototype.render = function () {
      var $container = $(
        '<span class="select2 select2-container">' +
          '<span class="selection"></span>' +
          '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
        '</span>'
      );
  
      $container.attr('dir', this.options.get('dir'));
  
      this.$container = $container;
  
      this.$container[0].classList
        .add('select2-container--' + this.options.get('theme'));
  
      Utils.StoreData($container[0], 'element', this.$element);
  
      return $container;
    };
  
    return Select2;
  });
  
  S2.define('jquery-mousewheel',[
    'jquery'
  ], function ($) {
    // Used to shim jQuery.mousewheel for non-full builds.
    return $;
  });
  
  S2.define('jquery.select2',[
    'jquery',
    'jquery-mousewheel',
  
    './select2/core',
    './select2/defaults',
    './select2/utils'
  ], function ($, _, Select2, Defaults, Utils) {
    if ($.fn.select2 == null) {
      // All methods that should return the element
      var thisMethods = ['open', 'close', 'destroy'];
  
      $.fn.select2 = function (options) {
        options = options || {};
  
        if (typeof options === 'object') {
          this.each(function () {
            var instanceOptions = $.extend(true, {}, options);
  
            var instance = new Select2($(this), instanceOptions);
          });
  
          return this;
        } else if (typeof options === 'string') {
          var ret;
          var args = Array.prototype.slice.call(arguments, 1);
  
          this.each(function () {
            var instance = Utils.GetData(this, 'select2');
  
            if (instance == null && window.console && console.error) {
              console.error(
                'The select2(\'' + options + '\') method was called on an ' +
                'element that is not using Select2.'
              );
            }
  
            ret = instance[options].apply(instance, args);
          });
  
          // Check if we should be returning `this`
          if (thisMethods.indexOf(options) > -1) {
            return this;
          }
  
          return ret;
        } else {
          throw new Error('Invalid arguments for Select2: ' + options);
        }
      };
    }
  
    if ($.fn.select2.defaults == null) {
      $.fn.select2.defaults = Defaults;
    }
  
    return Select2;
  });
  
    // Return the AMD loader configuration so it can be used outside of this file
    return {
      define: S2.define,
      require: S2.require
    };
  }());
  
    // Autoload the jQuery bindings
    // We know that all of the modules exist above this, so we're safe
    var select2 = S2.require('jquery.select2');
  
    // Hold the AMD module references on the jQuery function that was just loaded
    // This allows Select2 to use the internal loader outside of this file, such
    // as in the language files.
    jQuery.fn.select2.amd = S2;
  
    // Return the Select2 instance for anyone who is importing it.
    return select2;
  }));
  
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/core.css":
  /*!*****************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/core.css ***!
    \*****************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_core_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!../../../postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./core.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/core.css");
  
              
  
  var options = {};
  
  options.insert = "head";
  options.singleton = false;
  
  var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_core_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);
  
  
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_core_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/theme.css":
  /*!******************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/theme.css ***!
    \******************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_theme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!../../../postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./theme.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/theme.css");
  
              
  
  var options = {};
  
  options.insert = "head";
  options.singleton = false;
  
  var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_theme_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);
  
  
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_theme_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});
  
  /***/ }),
  
  /***/ "./node_modules/jquery-ui/themes/base/tooltip.css":
  /*!********************************************************!*\
    !*** ./node_modules/jquery-ui/themes/base/tooltip.css ***!
    \********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_tooltip_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!../../../postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./tooltip.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/jquery-ui/themes/base/tooltip.css");
  
              
  
  var options = {};
  
  options.insert = "head";
  options.singleton = false;
  
  var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_tooltip_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);
  
  
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_tooltip_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});
  
  /***/ }),
  
  /***/ "./node_modules/js-datepicker/dist/datepicker.min.css":
  /*!************************************************************!*\
    !*** ./node_modules/js-datepicker/dist/datepicker.min.css ***!
    \************************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_datepicker_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!../../postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./datepicker.min.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/js-datepicker/dist/datepicker.min.css");
  
              
  
  var options = {};
  
  options.insert = "head";
  options.singleton = false;
  
  var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_datepicker_min_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);
  
  
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_datepicker_min_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});
  
  /***/ }),
  
  /***/ "./node_modules/select2/dist/css/select2.css":
  /*!***************************************************!*\
    !*** ./node_modules/select2/dist/css/select2.css ***!
    \***************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
  /* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
  /* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_select2_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!../../../postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./select2.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].oneOf[1].use[2]!./node_modules/select2/dist/css/select2.css");
  
              
  
  var options = {};
  
  options.insert = "head";
  options.singleton = false;
  
  var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_select2_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);
  
  
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_1_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_oneOf_1_use_2_select2_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});
  
  /***/ }),
  
  /***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
    \****************************************************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  
  "use strict";
  
  
  var isOldIE = function isOldIE() {
    var memo;
    return function memorize() {
      if (typeof memo === 'undefined') {
        // Test for IE <= 9 as proposed by Browserhacks
        // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
        // Tests for existence of standard globals is to allow style-loader
        // to operate correctly into non-standard environments
        // @see https://github.com/webpack-contrib/style-loader/issues/177
        memo = Boolean(window && document && document.all && !window.atob);
      }
  
      return memo;
    };
  }();
  
  var getTarget = function getTarget() {
    var memo = {};
    return function memorize(target) {
      if (typeof memo[target] === 'undefined') {
        var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself
  
        if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
          try {
            // This will throw an exception if access to iframe is blocked
            // due to cross-origin restrictions
            styleTarget = styleTarget.contentDocument.head;
          } catch (e) {
            // istanbul ignore next
            styleTarget = null;
          }
        }
  
        memo[target] = styleTarget;
      }
  
      return memo[target];
    };
  }();
  
  var stylesInDom = [];
  
  function getIndexByIdentifier(identifier) {
    var result = -1;
  
    for (var i = 0; i < stylesInDom.length; i++) {
      if (stylesInDom[i].identifier === identifier) {
        result = i;
        break;
      }
    }
  
    return result;
  }
  
  function modulesToDom(list, options) {
    var idCountMap = {};
    var identifiers = [];
  
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      var id = options.base ? item[0] + options.base : item[0];
      var count = idCountMap[id] || 0;
      var identifier = "".concat(id, " ").concat(count);
      idCountMap[id] = count + 1;
      var index = getIndexByIdentifier(identifier);
      var obj = {
        css: item[1],
        media: item[2],
        sourceMap: item[3]
      };
  
      if (index !== -1) {
        stylesInDom[index].references++;
        stylesInDom[index].updater(obj);
      } else {
        stylesInDom.push({
          identifier: identifier,
          updater: addStyle(obj, options),
          references: 1
        });
      }
  
      identifiers.push(identifier);
    }
  
    return identifiers;
  }
  
  function insertStyleElement(options) {
    var style = document.createElement('style');
    var attributes = options.attributes || {};
  
    if (typeof attributes.nonce === 'undefined') {
      var nonce =  true ? __webpack_require__.nc : 0;
  
      if (nonce) {
        attributes.nonce = nonce;
      }
    }
  
    Object.keys(attributes).forEach(function (key) {
      style.setAttribute(key, attributes[key]);
    });
  
    if (typeof options.insert === 'function') {
      options.insert(style);
    } else {
      var target = getTarget(options.insert || 'head');
  
      if (!target) {
        throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
      }
  
      target.appendChild(style);
    }
  
    return style;
  }
  
  function removeStyleElement(style) {
    // istanbul ignore if
    if (style.parentNode === null) {
      return false;
    }
  
    style.parentNode.removeChild(style);
  }
  /* istanbul ignore next  */
  
  
  var replaceText = function replaceText() {
    var textStore = [];
    return function replace(index, replacement) {
      textStore[index] = replacement;
      return textStore.filter(Boolean).join('\n');
    };
  }();
  
  function applyToSingletonTag(style, index, remove, obj) {
    var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE
  
    /* istanbul ignore if  */
  
    if (style.styleSheet) {
      style.styleSheet.cssText = replaceText(index, css);
    } else {
      var cssNode = document.createTextNode(css);
      var childNodes = style.childNodes;
  
      if (childNodes[index]) {
        style.removeChild(childNodes[index]);
      }
  
      if (childNodes.length) {
        style.insertBefore(cssNode, childNodes[index]);
      } else {
        style.appendChild(cssNode);
      }
    }
  }
  
  function applyToTag(style, options, obj) {
    var css = obj.css;
    var media = obj.media;
    var sourceMap = obj.sourceMap;
  
    if (media) {
      style.setAttribute('media', media);
    } else {
      style.removeAttribute('media');
    }
  
    if (sourceMap && typeof btoa !== 'undefined') {
      css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
    } // For old IE
  
    /* istanbul ignore if  */
  
  
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      while (style.firstChild) {
        style.removeChild(style.firstChild);
      }
  
      style.appendChild(document.createTextNode(css));
    }
  }
  
  var singleton = null;
  var singletonCounter = 0;
  
  function addStyle(obj, options) {
    var style;
    var update;
    var remove;
  
    if (options.singleton) {
      var styleIndex = singletonCounter++;
      style = singleton || (singleton = insertStyleElement(options));
      update = applyToSingletonTag.bind(null, style, styleIndex, false);
      remove = applyToSingletonTag.bind(null, style, styleIndex, true);
    } else {
      style = insertStyleElement(options);
      update = applyToTag.bind(null, style, options);
  
      remove = function remove() {
        removeStyleElement(style);
      };
    }
  
    update(obj);
    return function updateStyle(newObj) {
      if (newObj) {
        if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
          return;
        }
  
        update(obj = newObj);
      } else {
        remove();
      }
    };
  }
  
  module.exports = function (list, options) {
    options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
    // tags it will allow on a page
  
    if (!options.singleton && typeof options.singleton !== 'boolean') {
      options.singleton = isOldIE();
    }
  
    list = list || [];
    var lastIdentifiers = modulesToDom(list, options);
    return function update(newList) {
      newList = newList || [];
  
      if (Object.prototype.toString.call(newList) !== '[object Array]') {
        return;
      }
  
      for (var i = 0; i < lastIdentifiers.length; i++) {
        var identifier = lastIdentifiers[i];
        var index = getIndexByIdentifier(identifier);
        stylesInDom[index].references--;
      }
  
      var newLastIdentifiers = modulesToDom(newList, options);
  
      for (var _i = 0; _i < lastIdentifiers.length; _i++) {
        var _identifier = lastIdentifiers[_i];
  
        var _index = getIndexByIdentifier(_identifier);
  
        if (stylesInDom[_index].references === 0) {
          stylesInDom[_index].updater();
  
          stylesInDom.splice(_index, 1);
        }
      }
  
      lastIdentifiers = newLastIdentifiers;
    };
  };
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/native.js":
  /*!******************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
    \******************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    randomUUID
  });
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/regex.js":
  /*!*****************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
    \*****************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/rng.js":
  /*!***************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
    \***************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (/* binding */ rng)
  /* harmony export */ });
  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
  
      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }
  
    return getRandomValues(rnds8);
  }
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
  /*!*********************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
    \*********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
  /* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
  /* harmony export */ });
  /* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
  
  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  
  const byteToHex = [];
  
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
  }
  
  function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
  
    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }
  
    return uuid;
  }
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/v4.js":
  /*!**************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
    \**************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
  /* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
  /* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
  
  
  
  
  function v4(options, buf, offset) {
    if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
      return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
    }
  
    options = options || {};
    const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
  
    if (buf) {
      offset = offset || 0;
  
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
  
      return buf;
    }
  
    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
  }
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);
  
  /***/ }),
  
  /***/ "./node_modules/uuid/dist/esm-browser/validate.js":
  /*!********************************************************!*\
    !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
    \********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  "use strict";
  __webpack_require__.r(__webpack_exports__);
  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
  /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
  /* harmony export */ });
  /* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");
  
  
  function validate(uuid) {
    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
  }
  
  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);
  
  /***/ })
  
  /******/ 	});
  /************************************************************************/
  /******/ 	// The module cache
  /******/ 	var __webpack_module_cache__ = {};
  /******/ 	
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/ 		// Check if module is in cache
  /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
  /******/ 		if (cachedModule !== undefined) {
  /******/ 			return cachedModule.exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = __webpack_module_cache__[moduleId] = {
  /******/ 			id: moduleId,
  /******/ 			// no module.loaded needed
  /******/ 			exports: {}
  /******/ 		};
  /******/ 	
  /******/ 		// Execute the module function
  /******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/ 	
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/ 	
  /************************************************************************/
  /******/ 	/* webpack/runtime/compat get default export */
  /******/ 	(() => {
  /******/ 		// getDefaultExport function for compatibility with non-harmony modules
  /******/ 		__webpack_require__.n = (module) => {
  /******/ 			var getter = module && module.__esModule ?
  /******/ 				() => (module['default']) :
  /******/ 				() => (module);
  /******/ 			__webpack_require__.d(getter, { a: getter });
  /******/ 			return getter;
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/define property getters */
  /******/ 	(() => {
  /******/ 		// define getter functions for harmony exports
  /******/ 		__webpack_require__.d = (exports, definition) => {
  /******/ 			for(var key in definition) {
  /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
  /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
  /******/ 				}
  /******/ 			}
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
  /******/ 	(() => {
  /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/make namespace object */
  /******/ 	(() => {
  /******/ 		// define __esModule on exports
  /******/ 		__webpack_require__.r = (exports) => {
  /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 			}
  /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/nonce */
  /******/ 	(() => {
  /******/ 		__webpack_require__.nc = undefined;
  /******/ 	})();
  /******/ 	
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  (() => {
  "use strict";
  /*!*************************!*\
    !*** ./src/js/index.js ***!
    \*************************/
  __webpack_require__.r(__webpack_exports__);
  /* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ "./node_modules/alpinejs/dist/module.esm.js");
  /* harmony import */ var _modules_dashboard_LoadLayout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/dashboard/LoadLayout */ "./src/js/modules/dashboard/LoadLayout.js");
  /* harmony import */ var _modules_dashboard_ModalDialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/dashboard/ModalDialog */ "./src/js/modules/dashboard/ModalDialog.js");
  /* harmony import */ var _modules_dashboard_Tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/dashboard/Tables */ "./src/js/modules/dashboard/Tables.js");
  /* harmony import */ var _modules_dashboard_Tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/dashboard/Tooltip */ "./src/js/modules/dashboard/Tooltip.js");
  /* harmony import */ var _modules_dashboard_Generic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/dashboard/Generic */ "./src/js/modules/dashboard/Generic.js");
  /* harmony import */ var _modules_dashboard_ResizeInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/dashboard/ResizeInput */ "./src/js/modules/dashboard/ResizeInput.js");
  /* harmony import */ var _modules_dashboard_Inputs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/dashboard/Inputs */ "./src/js/modules/dashboard/Inputs.js");
  /* harmony import */ var _modules_dashboard_ImageSelect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/dashboard/ImageSelect */ "./src/js/modules/dashboard/ImageSelect.js");
  /* harmony import */ var _modules_dashboard_ImageUpload__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/dashboard/ImageUpload */ "./src/js/modules/dashboard/ImageUpload.js");
  /* harmony import */ var _modules_dashboard_Calendar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/dashboard/Calendar */ "./src/js/modules/dashboard/Calendar.js");
  /* harmony import */ var _modules_dashboard_Specifics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/dashboard/Specifics */ "./src/js/modules/dashboard/Specifics.js");
  /* harmony import */ var _modules_dashboard_Tabs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/dashboard/Tabs */ "./src/js/modules/dashboard/Tabs.js");
  /* harmony import */ var _modules_dashboard_Recruitment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/dashboard/Recruitment */ "./src/js/modules/dashboard/Recruitment.js");
  /* harmony import */ var _modules_dashboard_Kanban__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/dashboard/Kanban */ "./src/js/modules/dashboard/Kanban.js");
  /* harmony import */ var _modules_dashboard_Chat__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/dashboard/Chat */ "./src/js/modules/dashboard/Chat.js");
  /* harmony import */ var _modules_dashboard_Dashboard__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/dashboard/Dashboard */ "./src/js/modules/dashboard/Dashboard.js");
  /* harmony import */ var _modules_dashboard_OrgChart__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/dashboard/OrgChart */ "./src/js/modules/dashboard/OrgChart.js");
  // Imports
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  // import WorkEntry from "./modules/dashboard/WorkEntry";
  
  // Instantiate a new objects
  window.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_0__["default"];
  alpinejs__WEBPACK_IMPORTED_MODULE_0__["default"].start();
  var loadLayout = new _modules_dashboard_LoadLayout__WEBPACK_IMPORTED_MODULE_1__["default"]();
  // const tables = new Tables();
  var modalDialog = new _modules_dashboard_ModalDialog__WEBPACK_IMPORTED_MODULE_2__["default"]();
  var tooltip = new _modules_dashboard_Tooltip__WEBPACK_IMPORTED_MODULE_4__["default"]();
  var generic = new _modules_dashboard_Generic__WEBPACK_IMPORTED_MODULE_5__["default"]();
  var resizeInput = new _modules_dashboard_ResizeInput__WEBPACK_IMPORTED_MODULE_6__["default"]();
  var inputs = new _modules_dashboard_Inputs__WEBPACK_IMPORTED_MODULE_7__["default"]();
  var imageSelect = new _modules_dashboard_ImageSelect__WEBPACK_IMPORTED_MODULE_8__["default"]();
  var imageUpload = new _modules_dashboard_ImageUpload__WEBPACK_IMPORTED_MODULE_9__["default"]();
  var calendar = new _modules_dashboard_Calendar__WEBPACK_IMPORTED_MODULE_10__["default"]();
  var specifics = new _modules_dashboard_Specifics__WEBPACK_IMPORTED_MODULE_11__["default"]();
  var tabs = new _modules_dashboard_Tabs__WEBPACK_IMPORTED_MODULE_12__["default"]();
  var recruitment = new _modules_dashboard_Recruitment__WEBPACK_IMPORTED_MODULE_13__["default"]();
  var kanban = new _modules_dashboard_Kanban__WEBPACK_IMPORTED_MODULE_14__["default"]();
  var chat = new _modules_dashboard_Chat__WEBPACK_IMPORTED_MODULE_15__["default"]();
  var dashbaord = new _modules_dashboard_Dashboard__WEBPACK_IMPORTED_MODULE_16__["default"]();
  var orgChart = new _modules_dashboard_OrgChart__WEBPACK_IMPORTED_MODULE_17__["default"]();
  // const workEntry = new WorkEntry();
  })();
  
  /******/ })()
  ;