// Horilla HRMS - Docker Build Pipeline
// Jenkinsfile.docker for building and pushing Docker images
// Can be triggered independently or from main CI pipeline

pipeline {
    agent {
        docker {
            image 'docker:24.0.0'
            args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

    parameters {
        string(
            name: 'DOCKER_TAG',
            defaultValue: 'latest',
            description: 'Docker image tag (defaults to latest, or use BUILD_NUMBER for uniqueness)'
        )
        choice(
            name: 'BUILD_CONTEXT',
            choices: ['.', './docker'],
            description: 'Docker build context directory'
        )
        choice(
            name: 'DOCKERFILE_PATH',
            choices: ['./Dockerfile', './Dockerfile.prod', './Dockerfile.dev'],
            description: 'Path to Dockerfile'
        )
        choice(
            name: 'REGISTRY_TARGET',
            choices: ['docker-hub', 'private-registry', 'ecr', 'gcr'],
            description: 'Target container registry'
        )
        booleanParam(
            name: 'PUSH_TO_REGISTRY',
            defaultValue: true,
            description: 'Push image to registry after build'
        )
        booleanParam(
            name: 'SCAN_IMAGE',
            defaultValue: true,
            description: 'Scan image for vulnerabilities'
        )
        booleanParam(
            name: 'MULTI_ARCH_BUILD',
            defaultValue: false,
            description: 'Build for multiple architectures (amd64, arm64)'
        )
    }

    environment {
        // Project settings
        REPO_NAME = 'horilla'
        GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        BUILD_TIMESTAMP = sh(script: 'date -u +"${BUILD_NUMBER}-%Y%m%d-%H%M%S"', returnStdout: true).trim()

        // Docker registry credentials
        DOCKER_HUB_USERNAME = credentials('docker-hub-username')
        DOCKER_HUB_TOKEN = credentials('docker-hub-token')
        PRIVATE_REGISTRY_URL = credentials('private-registry-url')
        PRIVATE_REGISTRY_USERNAME = credentials('private-registry-username')
        PRIVATE_REGISTRY_PASSWORD = credentials('private-registry-password')
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = credentials('aws-account-id')
        GCP_PROJECT_ID = credentials('gcp-project-id')

        // Image naming
        DOCKER_HUB_IMAGE = "${DOCKER_HUB_USERNAME}/${REPO_NAME}"
        PRIVATE_REGISTRY_IMAGE = "${PRIVATE_REGISTRY_URL}/${REPO_NAME}"
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_IMAGE = "${ECR_REGISTRY}/${REPO_NAME}"
        GCR_REGISTRY = "gcr.io"
        GCR_IMAGE = "${GCR_REGISTRY}/${GCP_PROJECT_ID}/${REPO_NAME}"

        // Build settings
        DOCKER_BUILDKIT = '1'
        BUILDKIT_PROGRESS = 'plain'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '5'))
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        buildName '${DOCKER_TAG}-${BUILD_NUMBER}'
    }

    stages {
        stage('Prepare') {
            steps {
                echo "=== Preparing Docker build ==="
                sh '''
                    echo "Build Configuration:"
                    echo "  Repository: ${REPO_NAME}"
                    echo "  Docker Tag: ${DOCKER_TAG}"
                    echo "  Build Context: ${BUILD_CONTEXT}"
                    echo "  Dockerfile: ${DOCKERFILE_PATH}"
                    echo "  Registry: ${REGISTRY_TARGET}"
                    echo "  Commit: ${GIT_COMMIT_SHORT}"
                    echo "  Timestamp: ${BUILD_TIMESTAMP}"

                    # Verify Dockerfile exists
                    if [ ! -f "${DOCKERFILE_PATH}" ]; then
                        echo "ERROR: Dockerfile not found at ${DOCKERFILE_PATH}"
                        exit 1
                    fi

                    # Display Dockerfile info
                    echo ""
                    echo "=== Dockerfile Info ==="
                    head -20 ${DOCKERFILE_PATH}
                '''
            }
        }

        stage('Login to Registries') {
            steps {
                echo "=== Authenticating with container registries ==="
                sh '''
                    case "${REGISTRY_TARGET}" in
                        docker-hub)
                            echo "Logging in to Docker Hub..."
                            echo "${DOCKER_HUB_TOKEN}" | docker login -u "${DOCKER_HUB_USERNAME}" --password-stdin
                            ;;
                        private-registry)
                            echo "Logging in to private registry..."
                            echo "${PRIVATE_REGISTRY_PASSWORD}" | docker login -u "${PRIVATE_REGISTRY_USERNAME}" --password-stdin "${PRIVATE_REGISTRY_URL}"
                            ;;
                        ecr)
                            echo "Logging in to AWS ECR..."
                            aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                            ;;
                        gcr)
                            echo "Logging in to Google Container Registry..."
                            echo ${GCP_KEY_FILE} | docker login -u _json_key --password-stdin ${GCR_REGISTRY}
                            ;;
                    esac
                '''
            }
        }

        stage('Build Image') {
            steps {
                echo "=== Building Docker image ==="
                sh '''
                    # Determine image name based on registry
                    case "${REGISTRY_TARGET}" in
                        docker-hub)
                            IMAGE_NAME="${DOCKER_HUB_IMAGE}"
                            ;;
                        private-registry)
                            IMAGE_NAME="${PRIVATE_REGISTRY_IMAGE}"
                            ;;
                        ecr)
                            IMAGE_NAME="${ECR_IMAGE}"
                            ;;
                        gcr)
                            IMAGE_NAME="${GCR_IMAGE}"
                            ;;
                    esac

                    # Build arguments
                    BUILD_ARGS="--build-arg BUILD_NUMBER=${BUILD_NUMBER}"
                    BUILD_ARGS="${BUILD_ARGS} --build-arg GIT_COMMIT=${GIT_COMMIT_SHORT}"
                    BUILD_ARGS="${BUILD_ARGS} --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
                    BUILD_ARGS="${BUILD_ARGS} --build-arg VERSION=${DOCKER_TAG}"

                    # Build labels
                    LABELS="--label org.opencontainers.image.title=${REPO_NAME}"
                    LABELS="${LABELS} --label org.opencontainers.image.description=Horilla HRMS"
                    LABELS="${LABELS} --label org.opencontainers.image.version=${DOCKER_TAG}"
                    LABELS="${LABELS} --label org.opencontainers.image.revision=${GIT_COMMIT_SHORT}"
                    LABELS="${LABELS} --label org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
                    LABELS="${LABELS} --label org.opencontainers.image.vendor=Horilla"
                    LABELS="${LABELS} --label jenkins.build=${BUILD_NUMBER}"

                    # Build image
                    echo "Building: ${IMAGE_NAME}:${DOCKER_TAG}"
                    docker build \
                        ${BUILD_ARGS} \
                        ${LABELS} \
                        -f ${DOCKERFILE_PATH} \
                        -t ${IMAGE_NAME}:${DOCKER_TAG} \
                        -t ${IMAGE_NAME}:latest \
                        -t ${IMAGE_NAME}:${BUILD_TIMESTAMP} \
                        ${BUILD_CONTEXT}

                    # Show image info
                    echo ""
                    echo "=== Built Image Info ==="
                    docker image inspect ${IMAGE_NAME}:${DOCKER_TAG} | jq '.[] | {
                        ID: .ID,
                        Size: .Size,
                        Created: .Created,
                        Labels: .Config.Labels
                    }'

                    # Show image size
                    docker images ${IMAGE_NAME} --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
                '''
            }
        }

        stage('Build Multi-Architecture Images') {
            when {
                expression { params.MULTI_ARCH_BUILD == true }
            }
            steps {
                echo "=== Building multi-architecture images ==="
                sh '''
                    # Note: This requires Docker buildx or similar tool
                    # Using buildx for cross-platform builds

                    case "${REGISTRY_TARGET}" in
                        docker-hub)
                            IMAGE_NAME="${DOCKER_HUB_IMAGE}"
                            ;;
                        private-registry)
                            IMAGE_NAME="${PRIVATE_REGISTRY_IMAGE}"
                            ;;
                        ecr)
                            IMAGE_NAME="${ECR_IMAGE}"
                            ;;
                        gcr)
                            IMAGE_NAME="${GCR_IMAGE}"
                            ;;
                    esac

                    # Create buildx builder if needed
                    docker buildx create --name horilla-builder --use 2>/dev/null || \
                    docker buildx use horilla-builder

                    # Build for multiple architectures
                    BUILD_ARGS="--build-arg BUILD_NUMBER=${BUILD_NUMBER}"
                    BUILD_ARGS="${BUILD_ARGS} --build-arg GIT_COMMIT=${GIT_COMMIT_SHORT}"

                    docker buildx build \
                        ${BUILD_ARGS} \
                        --platform linux/amd64,linux/arm64 \
                        -f ${DOCKERFILE_PATH} \
                        -t ${IMAGE_NAME}:${DOCKER_TAG} \
                        -t ${IMAGE_NAME}:latest \
                        --push \
                        ${BUILD_CONTEXT}

                    echo "Multi-architecture build completed"
                '''
            }
        }

        stage('Scan Image') {
            when {
                expression { params.SCAN_IMAGE == true }
            }
            parallel {
                stage('Trivy Vulnerability Scan') {
                    steps {
                        echo "=== Scanning with Trivy ==="
                        catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
                            sh '''
                                # Determine image name
                                case "${REGISTRY_TARGET}" in
                                    docker-hub)
                                        IMAGE_NAME="${DOCKER_HUB_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                    private-registry)
                                        IMAGE_NAME="${PRIVATE_REGISTRY_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                    ecr)
                                        IMAGE_NAME="${ECR_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                    gcr)
                                        IMAGE_NAME="${GCR_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                esac

                                # Install Trivy if not present
                                which trivy || \
                                (curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin)

                                # Scan image
                                trivy image \
                                    --severity HIGH,CRITICAL \
                                    --format json \
                                    --output trivy-report.json \
                                    ${IMAGE_NAME} || true

                                trivy image \
                                    --severity HIGH,CRITICAL \
                                    ${IMAGE_NAME} || true
                            '''
                        }
                    }
                }

                stage('Grype Vulnerability Scan') {
                    steps {
                        echo "=== Scanning with Grype ==="
                        catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
                            sh '''
                                # Determine image name
                                case "${REGISTRY_TARGET}" in
                                    docker-hub)
                                        IMAGE_NAME="${DOCKER_HUB_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                    *)
                                        IMAGE_NAME="horilla:${DOCKER_TAG}"
                                        ;;
                                esac

                                # Install Grype if needed
                                which grype || \
                                (curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin) || \
                                echo "Grype installation skipped"

                                # Scan image if available
                                grype ${IMAGE_NAME} \
                                    -o json \
                                    -o table \
                                    > grype-report.json 2>&1 || echo "Grype scan skipped"
                            '''
                        }
                    }
                }

                stage('Container Structure Test') {
                    steps {
                        echo "=== Running container structure tests ==="
                        catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
                            sh '''
                                # Determine image name
                                case "${REGISTRY_TARGET}" in
                                    docker-hub)
                                        IMAGE_NAME="${DOCKER_HUB_IMAGE}:${DOCKER_TAG}"
                                        ;;
                                    *)
                                        IMAGE_NAME="horilla:${DOCKER_TAG}"
                                        ;;
                                esac

                                # Create test configuration
                                cat > container-structure-test.yaml <<EOF
schemaVersion: 2.0.0
commandTests:
  - name: "Check Python version"
    setup: [["sh", "-c"]]
    command: "python3"
    args: ["--version"]
    excludedOutput: ["Python 2"]
  - name: "Check Django installation"
    setup: [["sh", "-c"]]
    command: "python3"
    args: ["-m", "django", "--version"]
fileExistenceTests:
  - name: "Entrypoint script exists"
    path: "/app/entrypoint.sh"
    shouldExist: true
  - name: "requirements.txt exists"
    path: "/app/requirements.txt"
    shouldExist: true
metadataTest:
  labels:
    - key: "org.opencontainers.image.title"
      value: "horilla"
  exposedPorts: ["8000"]
  user: "horilla"
  workdir: "/app"
EOF

                                # Run tests
                                curl -LO https://storage.googleapis.com/container-structure-test/latest/container-structure-test-linux-amd64 || true
                                chmod +x container-structure-test-linux-amd64 || true
                                ./container-structure-test-linux-amd64 test --image ${IMAGE_NAME} \
                                    --config container-structure-test.yaml \
                                    --verbosity debug || echo "Container structure tests completed"
                            '''
                        }
                    }
                }
            }
        }

        stage('Push to Registry') {
            when {
                expression { params.PUSH_TO_REGISTRY == true }
            }
            steps {
                echo "=== Pushing image to registry ==="
                sh '''
                    # Determine image name based on registry
                    case "${REGISTRY_TARGET}" in
                        docker-hub)
                            IMAGE_NAME="${DOCKER_HUB_IMAGE}"
                            ;;
                        private-registry)
                            IMAGE_NAME="${PRIVATE_REGISTRY_IMAGE}"
                            ;;
                        ecr)
                            IMAGE_NAME="${ECR_IMAGE}"
                            ;;
                        gcr)
                            IMAGE_NAME="${GCR_IMAGE}"
                            ;;
                    esac

                    echo "Pushing to ${REGISTRY_TARGET}..."

                    # Push all tags
                    docker push ${IMAGE_NAME}:${DOCKER_TAG}
                    docker push ${IMAGE_NAME}:latest
                    docker push ${IMAGE_NAME}:${BUILD_TIMESTAMP}

                    echo "Push completed successfully"

                    # Display pushed image info
                    echo ""
                    echo "=== Pushed Images ==="
                    echo "${IMAGE_NAME}:${DOCKER_TAG}"
                    echo "${IMAGE_NAME}:latest"
                    echo "${IMAGE_NAME}:${BUILD_TIMESTAMP}"
                '''
            }
        }

        stage('Generate SBoM') {
            steps {
                echo "=== Generating Software Bill of Materials ==="
                catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                    sh '''
                        # Install syft if needed
                        which syft || \
                        (curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin) || \
                        echo "Syft not available"

                        # Generate SBoM
                        case "${REGISTRY_TARGET}" in
                            docker-hub)
                                IMAGE_NAME="${DOCKER_HUB_IMAGE}:${DOCKER_TAG}"
                                ;;
                            *)
                                IMAGE_NAME="horilla:${DOCKER_TAG}"
                                ;;
                        esac

                        syft ${IMAGE_NAME} \
                            -o spdx-json \
                            > sbom-spdx.json 2>/dev/null || echo "SBoM generation skipped"

                        syft ${IMAGE_NAME} \
                            -o cyclonedx-json \
                            > sbom-cyclonedx.json 2>/dev/null || echo "SBoM generation skipped"

                        echo "SBoM generation completed"
                    '''
                }
            }
        }

        stage('Cleanup') {
            steps {
                echo "=== Cleaning up local Docker resources ==="
                sh '''
                    # Logout from registries
                    case "${REGISTRY_TARGET}" in
                        docker-hub)
                            docker logout
                            ;;
                        private-registry)
                            docker logout ${PRIVATE_REGISTRY_URL}
                            ;;
                        ecr)
                            # ECR logout not needed
                            ;;
                        gcr)
                            docker logout ${GCR_REGISTRY}
                            ;;
                    esac

                    # Optional: Prune unused Docker resources
                    # docker system prune -f --volumes
                '''
            }
        }
    }

    post {
        always {
            echo "=== Archiving artifacts ==="
            archiveArtifacts artifacts: '''
                trivy-report.json,
                grype-report.json,
                sbom-spdx.json,
                sbom-cyclonedx.json,
                container-structure-test.yaml,
                Dockerfile
            ''', allowEmptyArchive: true

            cleanWs(deleteDirs: true)
        }

        success {
            echo "=== Docker build SUCCESSFUL ==="
        }

        failure {
            echo "=== Docker build FAILED ==="
        }
    }
}
